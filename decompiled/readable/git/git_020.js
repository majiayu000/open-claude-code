/**
 * Claude Code Decompiled - Readable Version
 *
 * NOTE: This code has been decompiled from minified source.
 * Variable names have been partially restored based on context analysis.
 * Some names may still be unclear - look for nearby string constants for hints.
 *
 * Original file: cli.js (v2.0.57)
 * Processed: 2025-12-08T11:28:37.979Z
 */

/**
 * Claude Code Decompiled
 * Category: git
 * File: 20/34
 * Lines: 237577 - 239076 (1500 lines)
 * Original file: cli.js
 */

        [194777, 1, "望"],
        [194778, 1, "朡"],
        [194779, 1, "杞"],
        [194780, 1, "杓"],
        [194781, 1, "𣏃"],
        [194782, 1, "㭉"],
        [194783, 1, "柺"],
        [194784, 1, "枅"],
        [194785, 1, "桒"],
        [194786, 1, "梅"],
        [194787, 1, "𣑭"],
        [194788, 1, "梎"],
        [194789, 1, "栟"],
        [194790, 1, "椔"],
        [194791, 1, "㮝"],
        [194792, 1, "楂"],
        [194793, 1, "榣"],
        [194794, 1, "槪"],
        [194795, 1, "檨"],
        [194796, 1, "𣚣"],
        [194797, 1, "櫛"],
        [194798, 1, "㰘"],
        [194799, 1, "次"],
        [194800, 1, "𣢧"],
        [194801, 1, "歔"],
        [194802, 1, "㱎"],
        [194803, 1, "歲"],
        [194804, 1, "殟"],
        [194805, 1, "殺"],
        [194806, 1, "殻"],
        [194807, 1, "𣪍"],
        [194808, 1, "𡴋"],
        [194809, 1, "𣫺"],
        [194810, 1, "汎"],
        [194811, 1, "𣲼"],
        [194812, 1, "沿"],
        [194813, 1, "泍"],
        [194814, 1, "汧"],
        [194815, 1, "洖"],
        [194816, 1, "派"],
        [194817, 1, "海"],
        [194818, 1, "流"],
        [194819, 1, "浩"],
        [194820, 1, "浸"],
        [194821, 1, "涅"],
        [194822, 1, "𣴞"],
        [194823, 1, "洴"],
        [194824, 1, "港"],
        [194825, 1, "湮"],
        [194826, 1, "㴳"],
        [194827, 1, "滋"],
        [194828, 1, "滇"],
        [194829, 1, "𣻑"],
        [194830, 1, "淹"],
        [194831, 1, "潮"],
        [194832, 1, "𣽞"],
        [194833, 1, "𣾎"],
        [194834, 1, "濆"],
        [194835, 1, "瀹"],
        [194836, 1, "瀞"],
        [194837, 1, "瀛"],
        [194838, 1, "㶖"],
        [194839, 1, "灊"],
        [194840, 1, "災"],
        [194841, 1, "灷"],
        [194842, 1, "炭"],
        [194843, 1, "𠔥"],
        [194844, 1, "煅"],
        [194845, 1, "𤉣"],
        [194846, 1, "熜"],
        [194847, 1, "𤎫"],
        [194848, 1, "爨"],
        [194849, 1, "爵"],
        [194850, 1, "牐"],
        [194851, 1, "𤘈"],
        [194852, 1, "犀"],
        [194853, 1, "犕"],
        [194854, 1, "𤜵"],
        [194855, 1, "𤠔"],
        [194856, 1, "獺"],
        [194857, 1, "王"],
        [194858, 1, "㺬"],
        [194859, 1, "玥"],
        [
            [194860, 194861], 1, "㺸"
        ],
        [194862, 1, "瑇"],
        [194863, 1, "瑜"],
        [194864, 1, "瑱"],
        [194865, 1, "璅"],
        [194866, 1, "瓊"],
        [194867, 1, "㼛"],
        [194868, 1, "甤"],
        [194869, 1, "𤰶"],
        [194870, 1, "甾"],
        [194871, 1, "𤲒"],
        [194872, 1, "異"],
        [194873, 1, "𢆟"],
        [194874, 1, "瘐"],
        [194875, 1, "𤾡"],
        [194876, 1, "𤾸"],
        [194877, 1, "𥁄"],
        [194878, 1, "㿼"],
        [194879, 1, "䀈"],
        [194880, 1, "直"],
        [194881, 1, "𥃳"],
        [194882, 1, "𥃲"],
        [194883, 1, "𥄙"],
        [194884, 1, "𥄳"],
        [194885, 1, "眞"],
        [
            [194886, 194887], 1, "真"
        ],
        [194888, 1, "睊"],
        [194889, 1, "䀹"],
        [194890, 1, "瞋"],
        [194891, 1, "䁆"],
        [194892, 1, "䂖"],
        [194893, 1, "𥐝"],
        [194894, 1, "硎"],
        [194895, 1, "碌"],
        [194896, 1, "磌"],
        [194897, 1, "䃣"],
        [194898, 1, "𥘦"],
        [194899, 1, "祖"],
        [194900, 1, "𥚚"],
        [194901, 1, "𥛅"],
        [194902, 1, "福"],
        [194903, 1, "秫"],
        [194904, 1, "䄯"],
        [194905, 1, "穀"],
        [194906, 1, "穊"],
        [194907, 1, "穏"],
        [194908, 1, "𥥼"],
        [
            [194909, 194910], 1, "𥪧"
        ],
        [194911, 1, "竮"],
        [194912, 1, "䈂"],
        [194913, 1, "𥮫"],
        [194914, 1, "篆"],
        [194915, 1, "築"],
        [194916, 1, "䈧"],
        [194917, 1, "𥲀"],
        [194918, 1, "糒"],
        [194919, 1, "䊠"],
        [194920, 1, "糨"],
        [194921, 1, "糣"],
        [194922, 1, "紀"],
        [194923, 1, "𥾆"],
        [194924, 1, "絣"],
        [194925, 1, "䌁"],
        [194926, 1, "緇"],
        [194927, 1, "縂"],
        [194928, 1, "繅"],
        [194929, 1, "䌴"],
        [194930, 1, "𦈨"],
        [194931, 1, "𦉇"],
        [194932, 1, "䍙"],
        [194933, 1, "𦋙"],
        [194934, 1, "罺"],
        [194935, 1, "𦌾"],
        [194936, 1, "羕"],
        [194937, 1, "翺"],
        [194938, 1, "者"],
        [194939, 1, "𦓚"],
        [194940, 1, "𦔣"],
        [194941, 1, "聠"],
        [194942, 1, "𦖨"],
        [194943, 1, "聰"],
        [194944, 1, "𣍟"],
        [194945, 1, "䏕"],
        [194946, 1, "育"],
        [194947, 1, "脃"],
        [194948, 1, "䐋"],
        [194949, 1, "脾"],
        [194950, 1, "媵"],
        [194951, 1, "𦞧"],
        [194952, 1, "𦞵"],
        [194953, 1, "𣎓"],
        [194954, 1, "𣎜"],
        [194955, 1, "舁"],
        [194956, 1, "舄"],
        [194957, 1, "辞"],
        [194958, 1, "䑫"],
        [194959, 1, "芑"],
        [194960, 1, "芋"],
        [194961, 1, "芝"],
        [194962, 1, "劳"],
        [194963, 1, "花"],
        [194964, 1, "芳"],
        [194965, 1, "芽"],
        [194966, 1, "苦"],
        [194967, 1, "𦬼"],
        [194968, 1, "若"],
        [194969, 1, "茝"],
        [194970, 1, "荣"],
        [194971, 1, "莭"],
        [194972, 1, "茣"],
        [194973, 1, "莽"],
        [194974, 1, "菧"],
        [194975, 1, "著"],
        [194976, 1, "荓"],
        [194977, 1, "菊"],
        [194978, 1, "菌"],
        [194979, 1, "菜"],
        [194980, 1, "𦰶"],
        [194981, 1, "𦵫"],
        [194982, 1, "𦳕"],
        [194983, 1, "䔫"],
        [194984, 1, "蓱"],
        [194985, 1, "蓳"],
        [194986, 1, "蔖"],
        [194987, 1, "𧏊"],
        [194988, 1, "蕤"],
        [194989, 1, "𦼬"],
        [194990, 1, "䕝"],
        [194991, 1, "䕡"],
        [194992, 1, "𦾱"],
        [194993, 1, "𧃒"],
        [194994, 1, "䕫"],
        [194995, 1, "虐"],
        [194996, 1, "虜"],
        [194997, 1, "虧"],
        [194998, 1, "虩"],
        [194999, 1, "蚩"],
        [195000, 1, "蚈"],
        [195001, 1, "蜎"],
        [195002, 1, "蛢"],
        [195003, 1, "蝹"],
        [195004, 1, "蜨"],
        [195005, 1, "蝫"],
        [195006, 1, "螆"],
        [195007, 1, "䗗"],
        [195008, 1, "蟡"],
        [195009, 1, "蠁"],
        [195010, 1, "䗹"],
        [195011, 1, "衠"],
        [195012, 1, "衣"],
        [195013, 1, "𧙧"],
        [195014, 1, "裗"],
        [195015, 1, "裞"],
        [195016, 1, "䘵"],
        [195017, 1, "裺"],
        [195018, 1, "㒻"],
        [195019, 1, "𧢮"],
        [195020, 1, "𧥦"],
        [195021, 1, "䚾"],
        [195022, 1, "䛇"],
        [195023, 1, "誠"],
        [195024, 1, "諭"],
        [195025, 1, "變"],
        [195026, 1, "豕"],
        [195027, 1, "𧲨"],
        [195028, 1, "貫"],
        [195029, 1, "賁"],
        [195030, 1, "贛"],
        [195031, 1, "起"],
        [195032, 1, "𧼯"],
        [195033, 1, "𠠄"],
        [195034, 1, "跋"],
        [195035, 1, "趼"],
        [195036, 1, "跰"],
        [195037, 1, "𠣞"],
        [195038, 1, "軔"],
        [195039, 1, "輸"],
        [195040, 1, "𨗒"],
        [195041, 1, "𨗭"],
        [195042, 1, "邔"],
        [195043, 1, "郱"],
        [195044, 1, "鄑"],
        [195045, 1, "𨜮"],
        [195046, 1, "鄛"],
        [195047, 1, "鈸"],
        [195048, 1, "鋗"],
        [195049, 1, "鋘"],
        [195050, 1, "鉼"],
        [195051, 1, "鏹"],
        [195052, 1, "鐕"],
        [195053, 1, "𨯺"],
        [195054, 1, "開"],
        [195055, 1, "䦕"],
        [195056, 1, "閷"],
        [195057, 1, "𨵷"],
        [195058, 1, "䧦"],
        [195059, 1, "雃"],
        [195060, 1, "嶲"],
        [195061, 1, "霣"],
        [195062, 1, "𩅅"],
        [195063, 1, "𩈚"],
        [195064, 1, "䩮"],
        [195065, 1, "䩶"],
        [195066, 1, "韠"],
        [195067, 1, "𩐊"],
        [195068, 1, "䪲"],
        [195069, 1, "𩒖"],
        [
            [195070, 195071], 1, "頋"
        ],
        [195072, 1, "頩"],
        [195073, 1, "𩖶"],
        [195074, 1, "飢"],
        [195075, 1, "䬳"],
        [195076, 1, "餩"],
        [195077, 1, "馧"],
        [195078, 1, "駂"],
        [195079, 1, "駾"],
        [195080, 1, "䯎"],
        [195081, 1, "𩬰"],
        [195082, 1, "鬒"],
        [195083, 1, "鱀"],
        [195084, 1, "鳽"],
        [195085, 1, "䳎"],
        [195086, 1, "䳭"],
        [195087, 1, "鵧"],
        [195088, 1, "𪃎"],
        [195089, 1, "䳸"],
        [195090, 1, "𪄅"],
        [195091, 1, "𪈎"],
        [195092, 1, "𪊑"],
        [195093, 1, "麻"],
        [195094, 1, "䵖"],
        [195095, 1, "黹"],
        [195096, 1, "黾"],
        [195097, 1, "鼅"],
        [195098, 1, "鼏"],
        [195099, 1, "鼖"],
        [195100, 1, "鼻"],
        [195101, 1, "𪘀"],
        [
            [195102, 196605], 3
        ],
        [
            [196606, 196607], 3
        ],
        [
            [196608, 201546], 2
        ],
        [
            [201547, 201551], 3
        ],
        [
            [201552, 205743], 2
        ],
        [
            [205744, 262141], 3
        ],
        [
            [262142, 262143], 3
        ],
        [
            [262144, 327677], 3
        ],
        [
            [327678, 327679], 3
        ],
        [
            [327680, 393213], 3
        ],
        [
            [393214, 393215], 3
        ],
        [
            [393216, 458749], 3
        ],
        [
            [458750, 458751], 3
        ],
        [
            [458752, 524285], 3
        ],
        [
            [524286, 524287], 3
        ],
        [
            [524288, 589821], 3
        ],
        [
            [589822, 589823], 3
        ],
        [
            [589824, 655357], 3
        ],
        [
            [655358, 655359], 3
        ],
        [
            [655360, 720893], 3
        ],
        [
            [720894, 720895], 3
        ],
        [
            [720896, 786429], 3
        ],
        [
            [786430, 786431], 3
        ],
        [
            [786432, 851965], 3
        ],
        [
            [851966, 851967], 3
        ],
        [
            [851968, 917501], 3
        ],
        [
            [917502, 917503], 3
        ],
        [917504, 3],
        [917505, 3],
        [
            [917506, 917535], 3
        ],
        [
            [917536, 917631], 3
        ],
        [
            [917632, 917759], 3
        ],
        [
            [917760, 917999], 7
        ],
        [
            [918000, 983037], 3
        ],
        [
            [983038, 983039], 3
        ],
        [
            [983040, 1048573], 3
        ],
        [
            [1048574, 1048575], 3
        ],
        [
            [1048576, 1114109], 3
        ],
        [
            [1114110, 1114111], 3
        ]
    ]
});
var KpB = U((Xp6, VpB) => {
    Xp6.STATUS_MAPPING = {
        mapped: 1,
        valid: 2,
        disallowed: 3,
        deviation: 6,
        ignored: 7
    }
});
var zpB = U((K8G, EpB) => {
    var el1 = JpB(),
        MM = XpB(),
        DpB = FpB(),
        {
            STATUS_MAPPING: sp
        } = KpB();

function tl1(A) {
        return /[^\x00-\x7F]/u.test(A)
    }

function HpB(A) {
        let Q = 0,
            B = DpB.length - 1;
        while (Q <= B) {
            let G = Math.floor((Q + B) / 2),
                Z = DpB[G],
                I = Array.isArray(Z[0]) ? Z[0][0] : Z[0],
                Y = Array.isArray(Z[0]) ? Z[0][1] : Z[0];
            if (I <= A && Y >= A) return Z.slice(1);
            else if (I > A) B = G - 1;
            else Q = G + 1
        }
        return null
    }

function Vp6(A, {
        transitionalProcessing: Q
    }) {
        let B = "";
        for (let G of A) {
            let [Z, I] = HpB(G.codePointAt(0));
            switch (Z) {
                case sp.disallowed:
                    B += G;
                    break;
                case sp.ignored:
                    break;
                case sp.mapped:
                    if (Q && G === "ẞ") B += "ss";
                    else B += I;
                    break;
                case sp.deviation:
                    if (Q) B += I;
                    else B += G;
                    break;
                case sp.valid:
                    B += G;
                    break
            }
        }
        return B
    }

function Kp6(A, {
        checkHyphens: Q,
        checkBidi: B,
        checkJoiners: G,
        transitionalProcessing: Z,
        useSTD3ASCIIRules: I,
        isBidi: Y
    }) {
        if (A.length === 0) return !0;
        if (A.normalize("NFC") !== A) return !1;
        let J = Array.from(A);
        if (Q) {
            if (J[2] === "-" && J[3] === "-" || (A.startsWith("-") || A.endsWith("-"))) return !1
        }
        if (!Q) {
            if (A.startsWith("xn--")) return !1
        }
        if (A.includes(".")) return !1;
        if (MM.combiningMarks.test(J[0])) return !1;
        for (let W of J) {
            let X = W.codePointAt(0),
                [F] = HpB(X);
            if (Z) {
                if (F !== sp.valid) return !1
            } else if (F !== sp.valid && F !== sp.deviation) return !1;
            if (I && X <= 127) {
                if (!/^(?:[a-z]|[0-9]|-)$/u.test(W)) return !1
            }
        }
        if (G) {
            let W = 0;
            for (let [X, F] of J.entries())
                if (F === "‌" || F === "‍") {
                    if (X > 0) {
                        if (MM.combiningClassVirama.test(J[X - 1])) continue;
                        if (F === "‌") {
                            let V = J.indexOf("‌", X + 1),
                                K = V < 0 ? J.slice(W) : J.slice(W, V);
                            if (MM.validZWNJ.test(K.join(""))) {
                                W = X + 1;
                                continue
                            }
                        }
                    }
                    return !1
                }
        }
        if (B && Y) {
            let W;
            if (MM.bidiS1LTR.test(J[0])) W = !1;
            else if (MM.bidiS1RTL.test(J[0])) W = !0;
            else return !1;
            if (W) {
                if (!MM.bidiS2.test(A) || !MM.bidiS3.test(A) || MM.bidiS4EN.test(A) && MM.bidiS4AN.test(A)) return !1
            } else if (!MM.bidiS5.test(A) || !MM.bidiS6.test(A)) return !1
        }
        return !0
    }

function Dp6(A) {
        let Q = A.map((B) => {
            if (B.startsWith("xn--")) try {
                return el1.decode(B.substring(4))
            } catch {
                return ""
            }
            return B
        }).join(".");
        return MM.bidiDomain.test(Q)
    }

function CpB(A, Q) {
        let B = Vp6(A, Q);
        B = B.normalize("NFC");
        let G = B.split("."),
            Z = Dp6(G),
            I = !1;
        for (let [Y, J] of G.entries()) {
            let W = J,
                X = Q.transitionalProcessing;
            if (W.startsWith("xn--")) {
                if (tl1(W)) {
                    I = !0;
                    continue
                }
                try {
                    W = el1.decode(W.substring(4))
                } catch {
                    if (!Q.ignoreInvalidPunycode) {
                        I = !0;
                        continue
                    }
                }
                if (G[Y] = W, W === "" || !tl1(W)) I = !0;
                X = !1
            }
            if (I) continue;
            if (!Kp6(W, {
                    ...Q,
                    transitionalProcessing: X,
                    isBidi: Z
                })) I = !0
        }
        return {
            string: G.join("."),
            error: I
        }
    }

function Hp6(A, {
        checkHyphens: Q = !1,
        checkBidi: B = !1,
        checkJoiners: G = !1,
        useSTD3ASCIIRules: Z = !1,
        verifyDNSLength: I = !1,
        transitionalProcessing: Y = !1,
        ignoreInvalidPunycode: J = !1
    } = {}) {
        let W = CpB(A, {
                checkHyphens: Q,
                checkBidi: B,
                checkJoiners: G,
                useSTD3ASCIIRules: Z,
                transitionalProcessing: Y,
                ignoreInvalidPunycode: J
            }),
            X = W.string.split(".");
        if (X = X.map((F) => {
                if (tl1(F)) try {
                    return `xn--${el1.encode(F)}`
                } catch {
                    W.error = !0
                }
                return F
            }), I) {
            let F = X.join(".").length;
            if (F > 253 || F === 0) W.error = !0;
            for (let V = 0; V < X.length; ++V)
                if (X[V].length > 63 || X[V].length === 0) {
                    W.error = !0;
                    break
                }
        }
        if (W.error) return null;
        return X.join(".")
    }

function Cp6(A, {
        checkHyphens: Q = !1,
        checkBidi: B = !1,
        checkJoiners: G = !1,
        useSTD3ASCIIRules: Z = !1,
        transitionalProcessing: I = !1,
        ignoreInvalidPunycode: Y = !1
    } = {}) {
        let J = CpB(A, {
            checkHyphens: Q,
            checkBidi: B,
            checkJoiners: G,
            useSTD3ASCIIRules: Z,
            transitionalProcessing: I,
            ignoreInvalidPunycode: Y
        });
        return {
            domain: J.string,
            error: J.error
        }
    }
    EpB.exports = {
        toASCII: Hp6,
        toUnicode: Cp6
    }
});
var Qi1 = U((D8G, $pB) => {
    function Ai1(A) {
        return A >= 48 && A <= 57
    }

function UpB(A) {
        return A >= 65 && A <= 90 || A >= 97 && A <= 122
    }

function Ep6(A) {
        return UpB(A) || Ai1(A)
    }

function zp6(A) {
        return Ai1(A) || A >= 65 && A <= 70 || A >= 97 && A <= 102
    }
    $pB.exports = {
        isASCIIDigit: Ai1,
        isASCIIAlpha: UpB,
        isASCIIAlphanumeric: Ep6,
        isASCIIHex: zp6
    }
});
var leA = U((H8G, wpB) => {
    var Up6 = new TextEncoder,
        $p6 = new TextDecoder("utf-8", {
            ignoreBOM: !0
        });

function wp6(A) {
        return Up6.encode(A)
    }

function qp6(A) {
        return $p6.decode(A)
    }
    wpB.exports = {
        utf8Encode: wp6,
        utf8DecodeWithoutBOM: qp6
    }
});
var ieA = U((C8G, TpB) => {
    var {
        isASCIIHex: qpB
    } = Qi1(), {
        utf8Encode: NpB
    } = leA();

function u5(A) {
        return A.codePointAt(0)
    }

function Np6(A) {
        let Q = A.toString(16).toUpperCase();
        if (Q.length === 1) Q = `0${Q}`;
        return `%${Q}`
    }

function LpB(A) {
        let Q = new Uint8Array(A.byteLength),
            B = 0;
        for (let G = 0; G < A.byteLength; ++G) {
            let Z = A[G];
            if (Z !== 37) Q[B++] = Z;
            else if (Z === 37 && (!qpB(A[G + 1]) || !qpB(A[G + 2]))) Q[B++] = Z;
            else {
                let I = parseInt(String.fromCodePoint(A[G + 1], A[G + 2]), 16);
                Q[B++] = I, G += 2
            }
        }
        return Q.slice(0, B)
    }

function Lp6(A) {
        let Q = NpB(A);
        return LpB(Q)
    }

function Bi1(A) {
        return A <= 31 || A > 126
    }
    var Mp6 = new Set([u5(" "), u5('"'), u5("<"), u5(">"), u5("`")]);

function Op6(A) {
        return Bi1(A) || Mp6.has(A)
    }
    var Rp6 = new Set([u5(" "), u5('"'), u5("#"), u5("<"), u5(">")]);

function Gi1(A) {
        return Bi1(A) || Rp6.has(A)
    }

function Tp6(A) {
        return Gi1(A) || A === u5("'")
    }
    var Pp6 = new Set([u5("?"), u5("`"), u5("{"), u5("}"), u5("^")]);

function MpB(A) {
        return Gi1(A) || Pp6.has(A)
    }
    var jp6 = new Set([u5("/"), u5(":"), u5(";"), u5("="), u5("@"), u5("["), u5("\\"), u5("]"), u5("|")]);

function OpB(A) {
        return MpB(A) || jp6.has(A)
    }
    var Sp6 = new Set([u5("$"), u5("%"), u5("&"), u5("+"), u5(",")]);

function _p6(A) {
        return OpB(A) || Sp6.has(A)
    }
    var kp6 = new Set([u5("!"), u5("'"), u5("("), u5(")"), u5("~")]);

function yp6(A) {
        return _p6(A) || kp6.has(A)
    }

function RpB(A, Q) {
        let B = NpB(A),
            G = "";
        for (let Z of B)
            if (!Q(Z)) G += String.fromCharCode(Z);
            else G += Np6(Z);
        return G
    }

function xp6(A, Q) {
        return RpB(String.fromCodePoint(A), Q)
    }

function vp6(A, Q, B = !1) {
        let G = "";
        for (let Z of A)
            if (B && Z === " ") G += "+";
            else G += RpB(Z, Q);
        return G
    }
    TpB.exports = {
        isC0ControlPercentEncode: Bi1,
        isFragmentPercentEncode: Op6,
        isQueryPercentEncode: Gi1,
        isSpecialQueryPercentEncode: Tp6,
        isPathPercentEncode: MpB,
        isUserinfoPercentEncode: OpB,
        isURLEncodedPercentEncode: yp6,
        percentDecodeString: Lp6,
        percentDecodeBytes: LpB,
        utf8PercentEncodeString: vp6,
        utf8PercentEncodeCodePoint: xp6
    }
});
var Xi1 = U((Wl6, UE) => {
    var bp6 = zpB(),
        $D = Qi1(),
        {
            utf8DecodeWithoutBOM: fp6
        } = leA(),
        {
            percentDecodeString: hp6,
            utf8PercentEncodeCodePoint: aeA,
            utf8PercentEncodeString: seA,
            isC0ControlPercentEncode: kpB,
            isFragmentPercentEncode: gp6,
            isQueryPercentEncode: up6,
            isSpecialQueryPercentEncode: mp6,
            isPathPercentEncode: dp6,
            isUserinfoPercentEncode: Yi1
        } = ieA();

function RQ(A) {
        return A.codePointAt(0)
    }

var ypB = {
            ftp: 21,
            file: null,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        },
        D8 = Symbol("failure");

function PpB(A) {
        return [...A].length
    }

function jpB(A, Q) {
        let B = A[Q];
        return isNaN(B) ? void 0 : String.fromCodePoint(B)
    }

function SpB(A) {
        return A === "." || A.toLowerCase() === "%2e"
    }

function cp6(A) {
        return A = A.toLowerCase(), A === ".." || A === "%2e." || A === ".%2e" || A === "%2e%2e"
    }

function pp6(A, Q) {
        return $D.isASCIIAlpha(A) && (Q === RQ(":") || Q === RQ("|"))
    }

function xpB(A) {
        return A.length === 2 && $D.isASCIIAlpha(A.codePointAt(0)) && (A[1] === ":" || A[1] === "|")
    }

function lp6(A) {
        return A.length === 2 && $D.isASCIIAlpha(A.codePointAt(0)) && A[1] === ":"
    }

function vpB(A) {
        return A.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1
    }

function ip6(A) {
        return vpB(A) || A.search(/[\u0000-\u001F]|%|\u007F/u) !== -1
    }

function neA(A) {
        return ypB[A] !== void 0
    }

function UD(A) {
        return neA(A.scheme)
    }

function Zi1(A) {
        return !neA(A.scheme)
    }

function bpB(A) {
        return ypB[A]
    }

function fpB(A) {
        if (A === "") return D8;
        let Q = 10;
        if (A.length >= 2 && A.charAt(0) === "0" && A.charAt(1).toLowerCase() === "x") A = A.substring(2), Q = 16;
        else if (A.length >= 2 && A.charAt(0) === "0") A = A.substring(1), Q = 8;
        if (A === "") return 0;
        let B = /[^0-7]/u;
        if (Q === 10) B = /[^0-9]/u;
        if (Q === 16) B = /[^0-9A-Fa-f]/u;
        if (B.test(A)) return D8;
        return parseInt(A, Q)
    }

function np6(A) {
        let Q = A.split(".");
        if (Q[Q.length - 1] === "") {
            if (Q.length > 1) Q.pop()
        }
        if (Q.length > 4) return D8;
        let B = [];
        for (let I of Q) {
            let Y = fpB(I);
            if (Y === D8) return D8;
            B.push(Y)
        }
        for (let I = 0; I < B.length - 1; ++I)
            if (B[I] > 255) return D8;
        if (B[B.length - 1] >= 256 ** (5 - B.length)) return D8;
        let G = B.pop(),
            Z = 0;
        for (let I of B) G += I * 256 ** (3 - Z), ++Z;
        return G
    }

function ap6(A) {
        let Q = "",
            B = A;
        for (let G = 1; G <= 4; ++G) {
            if (Q = String(B % 256) + Q, G !== 4) Q = `.${Q}`;
            B = Math.floor(B / 256)
        }
        return Q
    }

function sp6(A) {
        let Q = [0, 0, 0, 0, 0, 0, 0, 0],
            B = 0,
            G = null,
            Z = 0;
        if (A = Array.from(A, (I) => I.codePointAt(0)), A[Z] === RQ(":")) {
            if (A[Z + 1] !== RQ(":")) return D8;
            Z += 2, ++B, G = B
        }
        while (Z < A.length) {
            if (B === 8) return D8;
            if (A[Z] === RQ(":")) {
                if (G !== null) return D8;
                ++Z, ++B, G = B;
                continue
            }
            let I = 0,
                Y = 0;
            while (Y < 4 && $D.isASCIIHex(A[Z])) I = I * 16 + parseInt(jpB(A, Z), 16), ++Z, ++Y;
            if (A[Z] === RQ(".")) {
                if (Y === 0) return D8;
                if (Z -= Y, B > 6) return D8;
                let J = 0;
                while (A[Z] !== void 0) {
                    let W = null;
                    if (J > 0)
                        if (A[Z] === RQ(".") && J < 4) ++Z;
                        else return D8;
                    if (!$D.isASCIIDigit(A[Z])) return D8;
                    while ($D.isASCIIDigit(A[Z])) {
                        let X = parseInt(jpB(A, Z));
                        if (W === null) W = X;
                        else if (W === 0) return D8;
                        else W = W * 10 + X;
                        if (W > 255) return D8;
                        ++Z
                    }
                    if (Q[B] = Q[B] * 256 + W, ++J, J === 2 || J === 4) ++B
                }
                if (J !== 4) return D8;
                break
            } else if (A[Z] === RQ(":")) {
                if (++Z, A[Z] === void 0) return D8
            } else if (A[Z] !== void 0) return D8;
            Q[B] = I, ++B
        }
        if (G !== null) {
            let I = B - G;
            B = 7;
            while (B !== 0 && I > 0) {
                let Y = Q[G + I - 1];
                Q[G + I - 1] = Q[B], Q[B] = Y, --B, --I
            }
        } else if (G === null && B !== 8) return D8;
        return Q
    }

function rp6(A) {
        let Q = "",
            B = ep6(A),
            G = !1;
        for (let Z = 0; Z <= 7; ++Z) {
            if (G && A[Z] === 0) continue;
            else if (G) G = !1;
            if (B === Z) {
                Q += Z === 0 ? "::" : ":", G = !0;
                continue
            }
            if (Q += A[Z].toString(16), Z !== 7) Q += ":"
        }
        return Q
    }

function Ii1(A, Q = !1) {
        if (A[0] === "[") {
            if (A[A.length - 1] !== "]") return D8;
            return sp6(A.substring(1, A.length - 1))
        }
        if (Q) return tp6(A);
        let B = fp6(hp6(A)),
            G = Al6(B);
        if (G === D8) return D8;
        if (op6(G)) return np6(G);
        return G
    }

function op6(A) {
        let Q = A.split(".");
        if (Q[Q.length - 1] === "") {
            if (Q.length === 1) return !1;
            Q.pop()
        }
        let B = Q[Q.length - 1];
        if (fpB(B) !== D8) return !0;
        if (/^[0-9]+$/u.test(B)) return !0;
        return !1
    }

function tp6(A) {
        if (vpB(A)) return D8;
        return seA(A, kpB)
    }

function ep6(A) {
        let Q = null,
            B = 1,
            G = null,
            Z = 0;
        for (let I = 0; I < A.length; ++I)
            if (A[I] !== 0) {
                if (Z > B) Q = G, B = Z;
                G = null, Z = 0
            } else {
                if (G === null) G = I;
                ++Z
            } if (Z > B) return G;
        return Q
    }

function Ji1(A) {
        if (typeof A === "number") return ap6(A);
        if (A instanceof Array) return `[${rp6(A)}]`;
        return A
    }

function Al6(A, Q = !1) {
        let B = bp6.toASCII(A, {
            checkHyphens: Q,
            checkBidi: !0,
            checkJoiners: !0,
            useSTD3ASCIIRules: Q,
            transitionalProcessing: !1,
            verifyDNSLength: Q,
            ignoreInvalidPunycode: !1
        });
        if (B === null) return D8;
        if (!Q) {
            if (B === "") return D8;
            if (ip6(B)) return D8
        }
        return B
    }

function Ql6(A) {
        let Q = 0,
            B = A.length;
        for (; Q < B; ++Q)
            if (A.charCodeAt(Q) > 32) break;
        for (; B > Q; --B)
            if (A.charCodeAt(B - 1) > 32) break;
        return A.substring(Q, B)
    }

function Bl6(A) {
        return A.replace(/\u0009|\u000A|\u000D/ug, "")
    }

function hpB(A) {
        let {
            path: Q
        } = A;
        if (Q.length === 0) return;
        if (A.scheme === "file" && Q.length === 1 && Zl6(Q[0])) return;
        Q.pop()
    }

function gpB(A) {
        return A.username !== "" || A.password !== ""
    }

function Gl6(A) {
        return A.host === null || A.host === "" || A.scheme === "file"
    }

function nwA(A) {
        return typeof A.path === "string"
    }

function Zl6(A) {
        return /^[A-Za-z]:$/u.test(A)
    }

function TJ(A, Q, B, G, Z) {
        if (this.pointer = 0, this.input = A, this.base = Q || null, this.encodingOverride = B || "utf-8", this.stateOverride = Z, this.url = G, this.failure = !1, this.parseError = !1, !this.url) {
            this.url = {
                scheme: "",
                username: "",
                password: "",
                host: null,
                port: null,
                path: [],
                query: null,
                fragment: null
            };
            let Y = Ql6(this.input);
            if (Y !== this.input) this.parseError = !0;
            this.input = Y
        }
        let I = Bl6(this.input);
        if (I !== this.input) this.parseError = !0;
        this.input = I, this.state = Z || "scheme start", this.buffer = "", this.atFlag = !1, this.arrFlag = !1, this.passwordTokenSeenFlag = !1, this.input = Array.from(this.input, (Y) => Y.codePointAt(0));
        for (; this.pointer <= this.input.length; ++this.pointer) {
            let Y = this.input[this.pointer],
                J = isNaN(Y) ? void 0 : String.fromCodePoint(Y),
                W = this[`parse ${this.state}`](Y, J);
            if (!W) break;
            else if (W === D8) {
                this.failure = !0;
                break
            }
        }
    }
    TJ.prototype["parse scheme start"] = function(Q, B) {
        if ($D.isASCIIAlpha(Q)) this.buffer += B.toLowerCase(), this.state = "scheme";
        else if (!this.stateOverride) this.state = "no scheme", --this.pointer;
        else return this.parseError = !0, D8;
        return !0
    };
    TJ.prototype["parse scheme"] = function(Q, B) {
        if ($D.isASCIIAlphanumeric(Q) || Q === RQ("+") || Q === RQ("-") || Q === RQ(".")) this.buffer += B.toLowerCase();
        else if (Q === RQ(":")) {
            if (this.stateOverride) {
                if (UD(this.url) && !neA(this.buffer)) return !1;
                if (!UD(this.url) && neA(this.buffer)) return !1;
                if ((gpB(this.url) || this.url.port !== null) && this.buffer === "file") return !1;
                if (this.url.scheme === "file" && this.url.host === "") return !1
            }
            if (this.url.scheme = this.buffer, this.stateOverride) {
                if (this.url.port === bpB(this.url.scheme)) this.url.port = null;
                return !1
            }
            if (this.buffer = "", this.url.scheme === "file") {
                if (this.input[this.pointer + 1] !== RQ("/") || this.input[this.pointer + 2] !== RQ("/")) this.parseError = !0;
                this.state = "file"
            } else if (UD(this.url) && this.base !== null && this.base.scheme === this.url.scheme) this.state = "special relative or authority";
            else if (UD(this.url)) this.state = "special authority slashes";
            else if (this.input[this.pointer + 1] === RQ("/")) this.state = "path or authority", ++this.pointer;
            else this.url.path = "", this.state = "opaque path"
        } else if (!this.stateOverride) this.buffer = "", this.state = "no scheme", this.pointer = -1;
        else return this.parseError = !0, D8;
        return !0
    };
    TJ.prototype["parse no scheme"] = function(Q) {
        if (this.base === null || nwA(this.base) && Q !== RQ("#")) return D8;
        else if (nwA(this.base) && Q === RQ("#")) this.url.scheme = this.base.scheme, this.url.path = this.base.path, this.url.query = this.base.query, this.url.fragment = "", this.state = "fragment";
        else if (this.base.scheme === "file") this.state = "file", --this.pointer;
        else this.state = "relative", --this.pointer;
        return !0
    };
    TJ.prototype["parse special relative or authority"] = function(Q) {
        if (Q === RQ("/") && this.input[this.pointer + 1] === RQ("/")) this.state = "special authority ignore slashes", ++this.pointer;
        else this.parseError = !0, this.state = "relative", --this.pointer;
        return !0
    };
    TJ.prototype["parse path or authority"] = function(Q) {
        if (Q === RQ("/")) this.state = "authority";
        else this.state = "path", --this.pointer;
        return !0
    };
    TJ.prototype["parse relative"] = function(Q) {
        if (this.url.scheme = this.base.scheme, Q === RQ("/")) this.state = "relative slash";
        else if (UD(this.url) && Q === RQ("\\")) this.parseError = !0, this.state = "relative slash";
        else if (this.url.username = this.base.username, this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, this.url.path = this.base.path.slice(), this.url.query = this.base.query, Q === RQ("?")) this.url.query = "", this.state = "query";
        else if (Q === RQ("#")) this.url.fragment = "", this.state = "fragment";
        else if (!isNaN(Q)) this.url.query = null, this.url.path.pop(), this.state = "path", --this.pointer;
        return !0
    };
    TJ.prototype["parse relative slash"] = function(Q) {
        if (UD(this.url) && (Q === RQ("/") || Q === RQ("\\"))) {
            if (Q === RQ("\\")) this.parseError = !0;
            this.state = "special authority ignore slashes"
        } else if (Q === RQ("/")) this.state = "authority";
        else this.url.username = this.base.username, this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, this.state = "path", --this.pointer;
        return !0
    };
    TJ.prototype["parse special authority slashes"] = function(Q) {
        if (Q === RQ("/") && this.input[this.pointer + 1] === RQ("/")) this.state = "special authority ignore slashes", ++this.pointer;
        else this.parseError = !0, this.state = "special authority ignore slashes", --this.pointer;
        return !0
    };
    TJ.prototype["parse special authority ignore slashes"] = function(Q) {
        if (Q !== RQ("/") && Q !== RQ("\\")) this.state = "authority", --this.pointer;
        else this.parseError = !0;
        return !0
    };
    TJ.prototype["parse authority"] = function(Q, B) {
        if (Q === RQ("@")) {
            if (this.parseError = !0, this.atFlag) this.buffer = `%40${this.buffer}`;
            this.atFlag = !0;
            let G = PpB(this.buffer);
            for (let Z = 0; Z < G; ++Z) {
                let I = this.buffer.codePointAt(Z);
                if (I === RQ(":") && !this.passwordTokenSeenFlag) {
                    this.passwordTokenSeenFlag = !0;
                    continue
                }
                let Y = aeA(I, Yi1);
                if (this.passwordTokenSeenFlag) this.url.password += Y;
                else this.url.username += Y
            }
            this.buffer = ""
        } else if (isNaN(Q) || Q === RQ("/") || Q === RQ("?") || Q === RQ("#") || UD(this.url) && Q === RQ("\\")) {
            if (this.atFlag && this.buffer === "") return this.parseError = !0, D8;
            this.pointer -= PpB(this.buffer) + 1, this.buffer = "", this.state = "host"
        } else this.buffer += B;
        return !0
    };
    TJ.prototype["parse hostname"] = TJ.prototype["parse host"] = function(Q, B) {
        if (this.stateOverride && this.url.scheme === "file") --this.pointer, this.state = "file host";
        else if (Q === RQ(":") && !this.arrFlag) {
            if (this.buffer === "") return this.parseError = !0, D8;
            if (this.stateOverride === "hostname") return !1;
            let G = Ii1(this.buffer, Zi1(this.url));
            if (G === D8) return D8;
            this.url.host = G, this.buffer = "", this.state = "port"
        } else if (isNaN(Q) || Q === RQ("/") || Q === RQ("?") || Q === RQ("#") || UD(this.url) && Q === RQ("\\")) {
            if (--this.pointer, UD(this.url) && this.buffer === "") return this.parseError = !0, D8;
            else if (this.stateOverride && this.buffer === "" && (gpB(this.url) || this.url.port !== null)) return this.parseError = !0, !1;
            let G = Ii1(this.buffer, Zi1(this.url));
            if (G === D8) return D8;
            if (this.url.host = G, this.buffer = "", this.state = "path start", this.stateOverride) return !1
        } else {
            if (Q === RQ("[")) this.arrFlag = !0;
            else if (Q === RQ("]")) this.arrFlag = !1;
            this.buffer += B
        }
        return !0
    };
    TJ.prototype["parse port"] = function(Q, B) {
        if ($D.isASCIIDigit(Q)) this.buffer += B;
        else if (isNaN(Q) || Q === RQ("/") || Q === RQ("?") || Q === RQ("#") || UD(this.url) && Q === RQ("\\") || this.stateOverride) {
            if (this.buffer !== "") {
                let G = parseInt(this.buffer);
                if (G > 65535) return this.parseError = !0, D8;
                this.url.port = G === bpB(this.url.scheme) ? null : G, this.buffer = ""
            }
            if (this.stateOverride) return !1;
            this.state = "path start", --this.pointer
        } else return this.parseError = !0, D8;
        return !0
    };
    var Il6 = new Set([RQ("/"), RQ("\\"), RQ("?"), RQ("#")]);

function upB(A, Q) {
        let B = A.length - Q;
        return B >= 2 && pp6(A[Q], A[Q + 1]) && (B === 2 || Il6.has(A[Q + 2]))
    }
    TJ.prototype["parse file"] = function(Q) {
        if (this.url.scheme = "file", this.url.host = "", Q === RQ("/") || Q === RQ("\\")) {
            if (Q === RQ("\\")) this.parseError = !0;
            this.state = "file slash"
        } else if (this.base !== null && this.base.scheme === "file") {
            if (this.url.host = this.base.host, this.url.path = this.base.path.slice(), this.url.query = this.base.query, Q === RQ("?")) this.url.query = "", this.state = "query";
            else if (Q === RQ("#")) this.url.fragment = "", this.state = "fragment";
            else if (!isNaN(Q)) {
                if (this.url.query = null, !upB(this.input, this.pointer)) hpB(this.url);
                else this.parseError = !0, this.url.path = [];
                this.state = "path", --this.pointer
            }
        } else this.state = "path", --this.pointer;
        return !0
    };
    TJ.prototype["parse file slash"] = function(Q) {
        if (Q === RQ("/") || Q === RQ("\\")) {
            if (Q === RQ("\\")) this.parseError = !0;
            this.state = "file host"
        } else {
            if (this.base !== null && this.base.scheme === "file") {
                if (!upB(this.input, this.pointer) && lp6(this.base.path[0])) this.url.path.push(this.base.path[0]);
                this.url.host = this.base.host
            }
            this.state = "path", --this.pointer
        }
        return !0
    };
    TJ.prototype["parse file host"] = function(Q, B) {
        if (isNaN(Q) || Q === RQ("/") || Q === RQ("\\") || Q === RQ("?") || Q === RQ("#"))
            if (--this.pointer, !this.stateOverride && xpB(this.buffer)) this.parseError = !0, this.state = "path";
            else if (this.buffer === "") {
            if (this.url.host = "", this.stateOverride) return !1;
            this.state = "path start"
        } else {
            let G = Ii1(this.buffer, Zi1(this.url));
            if (G === D8) return D8;
            if (G === "localhost") G = "";
            if (this.url.host = G, this.stateOverride) return !1;
            this.buffer = "", this.state = "path start"
        } else this.buffer += B;
        return !0
    };
    TJ.prototype["parse path start"] = function(Q) {
        if (UD(this.url)) {
            if (Q === RQ("\\")) this.parseError = !0;
            if (this.state = "path", Q !== RQ("/") && Q !== RQ("\\")) --this.pointer
        } else if (!this.stateOverride && Q === RQ("?")) this.url.query = "", this.state = "query";
        else if (!this.stateOverride && Q === RQ("#")) this.url.fragment = "", this.state = "fragment";
        else if (Q !== void 0) {
            if (this.state = "path", Q !== RQ("/")) --this.pointer
        } else if (this.stateOverride && this.url.host === null) this.url.path.push("");
        return !0
    };
    TJ.prototype["parse path"] = function(Q) {
        if (isNaN(Q) || Q === RQ("/") || UD(this.url) && Q === RQ("\\") || !this.stateOverride && (Q === RQ("?") || Q === RQ("#"))) {
            if (UD(this.url) && Q === RQ("\\")) this.parseError = !0;
            if (cp6(this.buffer)) {
                if (hpB(this.url), Q !== RQ("/") && !(UD(this.url) && Q === RQ("\\"))) this.url.path.push("")
            } else if (SpB(this.buffer) && Q !== RQ("/") && !(UD(this.url) && Q === RQ("\\"))) this.url.path.push("");
            else if (!SpB(this.buffer)) {
                if (this.url.scheme === "file" && this.url.path.length === 0 && xpB(this.buffer)) this.buffer = `${this.buffer[0]}:`;
                this.url.path.push(this.buffer)
            }
            if (this.buffer = "", Q === RQ("?")) this.url.query = "", this.state = "query";
            if (Q === RQ("#")) this.url.fragment = "", this.state = "fragment"
        } else {
            if (Q === RQ("%") && (!$D.isASCIIHex(this.input[this.pointer + 1]) || !$D.isASCIIHex(this.input[this.pointer + 2]))) this.parseError = !0;
            this.buffer += aeA(Q, dp6)
        }
        return !0
    };
    TJ.prototype["parse opaque path"] = function(Q) {
        if (Q === RQ("?")) this.url.query = "", this.state = "query";
        else if (Q === RQ("#")) this.url.fragment = "", this.state = "fragment";
        else if (Q === RQ(" ")) {
            let B = this.input[this.pointer + 1];
            if (B === RQ("?") || B === RQ("#")) this.url.path += "%20";
            else this.url.path += " "
        } else {
            if (!isNaN(Q) && Q !== RQ("%")) this.parseError = !0;
            if (Q === RQ("%") && (!$D.isASCIIHex(this.input[this.pointer + 1]) || !$D.isASCIIHex(this.input[this.pointer + 2]))) this.parseError = !0;
            if (!isNaN(Q)) this.url.path += aeA(Q, kpB)
        }
        return !0
    };
    TJ.prototype["parse query"] = function(Q, B) {
        if (!UD(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") this.encodingOverride = "utf-8";
        if (!this.stateOverride && Q === RQ("#") || isNaN(Q)) {
            let G = UD(this.url) ? mp6 : up6;
            if (this.url.query += seA(this.buffer, G), this.buffer = "", Q === RQ("#")) this.url.fragment = "", this.state = "fragment"
        } else if (!isNaN(Q)) {
            if (Q === RQ("%") && (!$D.isASCIIHex(this.input[this.pointer + 1]) || !$D.isASCIIHex(this.input[this.pointer + 2]))) this.parseError = !0;
            this.buffer += B
        }
        return !0
    };
    TJ.prototype["parse fragment"] = function(Q) {
        if (!isNaN(Q)) {
            if (Q === RQ("%") && (!$D.isASCIIHex(this.input[this.pointer + 1]) || !$D.isASCIIHex(this.input[this.pointer + 2]))) this.parseError = !0;
            this.url.fragment += aeA(Q, gp6)
        }
        return !0
    };

function Yl6(A, Q) {
        let B = `${A.scheme}:`;
        if (A.host !== null) {
            if (B += "//", A.username !== "" || A.password !== "") {
                if (B += A.username, A.password !== "") B += `:${A.password}`;
                B += "@"
            }
            if (B += Ji1(A.host), A.port !== null) B += `:${A.port}`
        }
        if (A.host === null && !nwA(A) && A.path.length > 1 && A.path[0] === "") B += "/.";
        if (B += Wi1(A), A.query !== null) B += `?${A.query}`;
        if (!Q && A.fragment !== null) B += `#${A.fragment}`;
        return B
    }

function Jl6(A) {
        let Q = `${A.scheme}://`;
        if (Q += Ji1(A.host), A.port !== null) Q += `:${A.port}`;
        return Q
    }

function Wi1(A) {
        if (nwA(A)) return A.path;
        let Q = "";
        for (let B of A.path) Q += `/${B}`;
        return Q
    }
    Wl6.serializeURL = Yl6;
    Wl6.serializePath = Wi1;
    Wl6.serializeURLOrigin = function(A) {
        switch (A.scheme) {
            case "blob": {
                let Q = Wl6.parseURL(Wi1(A));
                if (Q === null) return "null";
                if (Q.scheme !== "http" && Q.scheme !== "https") return "null";
                return Wl6.serializeURLOrigin(Q)
            }
            case "ftp":
            case "http":
            case "https":
            case "ws":
            case "wss":
                return Jl6({
                    scheme: A.scheme,
                    host: A.host,
                    port: A.port
                });
            case "file":
                return "null";
            default:
                return "null"
        }
    };
    Wl6.basicURLParse = function(A, Q) {
        if (Q === void 0) Q = {};
        let B = new TJ(A, Q.baseURL, Q.encodingOverride, Q.url, Q.stateOverride);
        if (B.failure) return null;
        return B.url
    };
    Wl6.setTheUsername = function(A, Q) {
        A.username = seA(Q, Yi1)
    };
    Wl6.setThePassword = function(A, Q) {
        A.password = seA(Q, Yi1)
    };
    Wl6.serializeHost = Ji1;
    Wl6.cannotHaveAUsernamePasswordPort = Gl6;
    Wl6.hasAnOpaquePath = nwA;
    Wl6.serializeInteger = function(A) {
        return String(A)
    };
    Wl6.parseURL = function(A, Q) {
        if (Q === void 0) Q = {};
        return Wl6.basicURLParse(A, {
            baseURL: Q.baseURL,
            encodingOverride: Q.encodingOverride
        })
    }
});
var Fi1 = U((E8G, apB) => {
    var {
        utf8Encode: Ul6,
        utf8DecodeWithoutBOM: dpB
    } = leA(), {
        percentDecodeBytes: cpB,
        utf8PercentEncodeString: ppB,
        isURLEncodedPercentEncode: lpB
    } = ieA();
