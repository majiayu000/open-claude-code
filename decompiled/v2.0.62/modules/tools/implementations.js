/**
 * Claude Code v2.0.62 - 工具实现
 *
 * 原始位置: 行 340001 - 360000
 * 模块: tools/implementations
 */

    renderToolUseProgressMessage: TJB,
    renderToolResultMessage: PJB,
    renderToolUseRejectedMessage: jJB,
    renderToolUseErrorMessage: SJB,
    async *call({ plan: A }, B) {
      let Q = B.agentId !== U2();
      yield { type: "result", data: { plan: A, isAgent: Q } };
    },
    mapToolResultToToolResultBlockParam({ isAgent: A }, B) {
      if (A)
        return {
          type: "tool_result",
          content: 'User has approved the plan. There is nothing else needed from you now. Please respond with "ok"',
          tool_use_id: B,
        };
      return {
        type: "tool_result",
        content:
          "User has approved your plan. You can now start coding. Start with updating your todo list if applicable",
        tool_use_id: B,
      };
    },
  };
var REQUEST_INTERRUPTED_MESSAGE = "[Request interrupted by user]",
  P$ = "[Request interrupted by user for tool use]",
  XE0 = "Tool call rejected -- yielding control back to user for further instructions.",
  Ub =
    "The user doesn't want to take this action right now. STOP what you are doing and wait for the user to tell you how to proceed.",
  WI1 =
    "The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.",
  FE0 = `The agent proposed a plan that was rejected by the user. The user chose to stay in plan mode rather than proceed with implementation.

Rejected plan:
`,
  JI1 = "No response requested.",
  xq0 = new Set([REQUEST_INTERRUPTED_MESSAGE, P$, Ub, WI1, XE0, JI1]);
function XI1(A) {
  return (
    A.type !== "progress" &&
    A.type !== "attachment" &&
    A.type !== "system" &&
    Array.isArray(A.message.content) &&
    A.message.content[0]?.type === "text" &&
    xq0.has(A.message.content[0].text)
  );
}
function E25(A) {
  return A.type === "assistant" && A.isApiErrorMessage === !0 && A.message.model === "<synthetic>";
}
function yJB({
  content: A,
  isApiErrorMessage: B = !1,
  usage: Q = {
    input_tokens: 0,
    output_tokens: 0,
    cache_creation_input_tokens: 0,
    cache_read_input_tokens: 0,
    server_tool_use: { web_search_requests: 0 },
    service_tier: null,
    cache_creation: { ephemeral_1h_input_tokens: 0, ephemeral_5m_input_tokens: 0 },
  },
}) {
  return {
    type: "assistant",
    uuid: $E(),
    timestamp: new Date().toISOString(),
    message: {
      id: $E(),
      container: null,
      model: "<synthetic>",
      role: "assistant",
      stop_reason: "stop_sequence",
      stop_sequence: "",
      type: "message",
      usage: Q,
      content: A,
    },
    requestId: void 0,
    isApiErrorMessage: B,
  };
}
function wE({ content: A, usage: B }) {
  return yJB({ content: typeof A === "string" ? [{ type: "text", text: A === "" ? PD : A }] : A, usage: B });
}
function PY({ content: A }) {
  return yJB({ content: [{ type: "text", text: A === "" ? PD : A }], isApiErrorMessage: !0 });
}
function bA({
  content: A,
  isMeta: B,
  isVisibleInTranscriptOnly: Q,
  isCompactSummary: Z,
  autocheckpoint: G,
  toolUseResult: Y,
  uuid: I,
  thinkingMetadata: W,
}) {
  return {
    type: "user",
    message: { role: "user", content: A || PD },
    isMeta: B,
    isVisibleInTranscriptOnly: Q,
    isCompactSummary: Z,
    autocheckpoint: G,
    uuid: I ?? $E(),
    timestamp: new Date().toISOString(),
    toolUseResult: Y,
    thinkingMetadata: W,
  };
}
function hH({ inputString: A, precedingInputBlocks: B }) {
  if (B.length === 0) return A;
  return [...B, { text: A, type: "text" }];
}
function FI1({ toolUse: A = !1 }) {
  return bA({ content: [{ type: "text", text: A ? P$ : REQUEST_INTERRUPTED_MESSAGE }] });
}
function oV() {
  return bA({
    content:
      "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.",
    isMeta: !0,
  });
}
function kJB({ toolUseID: A, parentToolUseID: B, data: Q }) {
  return {
    type: "progress",
    data: Q,
    toolUseID: A,
    parentToolUseID: B,
    uuid: $E(),
    timestamp: new Date().toISOString(),
  };
}
function qb1(A) {
  return { type: "tool_result", content: Ub, is_error: !0, tool_use_id: A };
}
function tQ(A, B) {
  if (!A.trim() || !B.trim()) return null;
  let Q = B.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
    Z = new RegExp(`<${Q}(?:\\s+[^>]*)?>([\\s\\S]*?)<\\/${Q}>`, "gi"),
    G,
    Y = 0,
    I = 0,
    W = new RegExp(`<${Q}(?:\\s+[^>]*?)?>`, "gi"),
    J = new RegExp(`<\\/${Q}>`, "gi");
  while ((G = Z.exec(A)) !== null) {
    let X = G[1],
      F = A.slice(I, G.index);
    ((Y = 0), (W.lastIndex = 0));
    while (W.exec(F) !== null) Y++;
    J.lastIndex = 0;
    while (J.exec(F) !== null) Y--;
    if (Y === 0 && X) return X;
    I = G.index + G[0].length;
  }
  return null;
}
function Eb1(A) {
  if (A.type === "progress" || A.type === "attachment" || A.type === "system") return !0;
  if (typeof A.message.content === "string") return A.message.content.trim().length > 0;
  if (A.message.content.length === 0) return !1;
  if (A.message.content.length > 1) return !0;
  if (A.message.content[0].type !== "text") return !0;
  return (
    A.message.content[0].text.trim().length > 0 && A.message.content[0].text !== PD && A.message.content[0].text !== P$
  );
}
function OI(A) {
  let B = !1;
  return A.flatMap((Q) => {
    switch (Q.type) {
      case "assistant":
        return (
          (B = B || Q.message.content.length > 1),
          Q.message.content.map((Z) => {
            let G = B ? $E() : Q.uuid;
            return {
              type: "assistant",
              timestamp: new Date().toISOString(),
              message: { ...Q.message, content: [Z] },
              isMeta: Q.isMeta,
              requestId: Q.requestId,
              uuid: G,
            };
          })
        );
      case "attachment":
        return [Q];
      case "progress":
        return [Q];
      case "system":
        return [Q];
      case "user": {
        if (typeof Q.message.content === "string") {
          let Z = B ? $E() : Q.uuid;
          return [{ ...Q, uuid: Z, message: { ...Q.message, content: [{ type: "text", text: Q.message.content }] } }];
        }
        return (
          (B = B || Q.message.content.length > 1),
          Q.message.content.map((Z) => ({
            ...bA({
              content: [Z],
              toolUseResult: Q.toolUseResult,
              isMeta: Q.isMeta,
              isVisibleInTranscriptOnly: Q.isVisibleInTranscriptOnly,
            }),
            uuid: B ? $E() : Q.uuid,
          }))
        );
      }
    }
  });
}
function N25(A) {
  return A.type === "assistant" && A.message.content.some((B) => B.type === "tool_use");
}
function _JB(A, B) {
  let Q = [],
    Z = [];
  for (let G of A) {
    if (N25(G)) Z.push(G);
    if (G.type === "user" && Array.isArray(G.message.content) && G.message.content[0]?.type === "tool_result") {
      let Y = G.message.content[0]?.tool_use_id,
        I = Z.find((W) => W.message.content[0]?.id === Y);
      if (I) {
        Q.splice(Q.indexOf(I) + 1, 0, G);
        continue;
      }
    } else Q.push(G);
  }
  for (let G of B) Q.push(G);
  return Q;
}
var Nb1 = VE0((A) =>
  Object.fromEntries(
    A.flatMap((B) =>
      B.type === "user" && B.message.content[0]?.type === "tool_result"
        ? [[B.message.content[0].tool_use_id, B.message.content[0].is_error ?? !1]]
        : [],
    ),
  ),
);
function VE0(A) {
  return zq1(A, (B) => {
    return B.map((Q) => Q.uuid).join(",");
  });
}
function xJB(A, B) {
  let Q = KI1(A);
  if (!Q) return new Set();
  let Z = B.find((I) => I.type === "assistant" && I.message.content.some((W) => W.type === "tool_use" && W.id === Q));
  if (!Z) return new Set();
  let G = Z.message.id,
    Y = B.filter((I) => I.type === "assistant" && I.message.id === G);
  return new Set(Y.flatMap((I) => I.message.content.filter((W) => W.type === "tool_use").map((W) => W.id)));
}
function KE0(A) {
  let B = Nb1(A),
    Q = L25(A);
  return LJB(Q, new Set(Object.keys(B)));
}
var L25 = VE0(
    (A) =>
      new Set(
        A.filter(
          (B) =>
            B.type === "assistant" && Array.isArray(B.message.content) && B.message.content[0]?.type === "tool_use",
        ).map((B) => B.message.content[0].id),
      ),
  ),
  vJB = VE0((A) => {
    let B = Nb1(A);
    return new Set(
      A.filter(
        (Q) =>
          Q.type === "assistant" &&
          Array.isArray(Q.message.content) &&
          Q.message.content[0]?.type === "tool_use" &&
          Q.message.content[0]?.id in B &&
          B[Q.message.content[0]?.id] === !0,
      ).map((Q) => Q.message.content[0].id),
    );
  });
function M25(A) {
  let B = [],
    Q = [];
  for (let Z = A.length - 1; Z >= 0; Z--) {
    let G = A[Z];
    if (G.type === "attachment") Q.unshift(G);
    else if (
      (G.type === "assistant" ||
        (G.type === "user" && Array.isArray(G.message.content) && G.message.content[0]?.type === "tool_result")) &&
      Q.length > 0
    )
      (B.unshift(G, ...Q), (Q.length = 0));
    else B.unshift(G);
  }
  return (B.unshift(...Q), B);
}
function dG(A) {
  let Q = M25(A).map((G) => {
      if (G.type === "system" && G.subtype === "post_tool_hook_success") return bA({ content: G.content });
      return G;
    }),
    Z = [];
  return (
    Q.filter((G) => {
      if (G.type === "progress" || G.type === "system" || E25(G)) return !1;
      return !0;
    }).forEach((G) => {
      switch (G.type) {
        case "user": {
          let Y = gJ(Z);
          if (Y?.type === "user") {
            Z[Z.indexOf(Y)] = T25(Y, G);
            return;
          }
          Z.push(G);
          return;
        }
        case "assistant": {
          let Y = gJ(Z);
          if (Y?.type === "assistant" && Y.message.id === G.message.id) {
            Z[Z.indexOf(Y)] = R25(Y, G);
            return;
          }
          Z.push(G);
          return;
        }
        case "attachment": {
          let Y = y25(G.attachment),
            I = gJ(Z);
          if (I?.type === "user") {
            Z[Z.indexOf(I)] = Y.reduce((W, J) => O25(W, J), I);
            return;
          }
          Z.push(...Y);
          return;
        }
      }
    }),
    Z
  );
}
function O25(A, B) {
  let Q = wb1(A.message.content),
    Z = wb1(B.message.content);
  return { ...A, message: { ...A.message, content: P25(Q, Z) } };
}
function R25(A, B) {
  return { ...A, message: { ...A.message, content: [...A.message.content, ...B.message.content] } };
}
function T25(A, B) {
  let Q = wb1(A.message.content),
    Z = wb1(B.message.content);
  return { ...A, message: { ...A.message, content: [...Q, ...Z] } };
}
function wb1(A) {
  if (typeof A === "string") return [{ type: "text", text: A }];
  return A;
}
function P25(A, B) {
  let Q = gJ(A);
  if (Q?.type === "tool_result" && typeof Q.content === "string" && B.every((Z) => Z.type === "text"))
    return [
      ...A.slice(0, -1),
      {
        ...Q,
        content: [Q.content, ...B.map((Z) => Z.text)].map((Z) => Z.trim()).filter(Boolean).join(`

`),
      },
    ];
  return [...A, ...B];
}
function QI1(A, B) {
  return A.map((Q) => {
    switch (Q.type) {
      case "tool_use": {
        if (typeof Q.input !== "string" && !VZ(Q.input)) throw new Error("Tool use input must be a string or object");
        let Z = typeof Q.input === "string" ? (d3(Q.input) ?? {}) : Q.input;
        if (typeof Z === "object" && Z !== null) {
          let G = B.find((Y) => Y.name === Q.name);
          if (G)
            try {
              Z = dWB(G, Z);
            } catch (Y) {
              U1(new Error("Error normalizing tool input: " + Y), VGA);
            }
        }
        return { ...Q, input: Z };
      }
      case "text":
        if (Q.text.trim().length === 0) return (Y1("tengu_empty_model_response", {}), { type: "text", text: PD });
        return Q;
      case "code_execution_tool_result":
      case "mcp_tool_use":
      case "mcp_tool_result":
      case "container_upload":
      case "server_tool_use":
        return Q;
      default:
        return Q;
    }
  });
}
function VI1(A) {
  return $Y1(A).trim() === "" || A.trim() === PD;
}
var j25 = ["commit_analysis", "context", "function_analysis", "pr_analysis"];
function $Y1(A) {
  let B = new RegExp(
    `<(${j25.join("|")})>.*?</\\1>
?`,
    "gs",
  );
  return A.replace(B, "").trim();
}
function KI1(A) {
  switch (A.type) {
    case "attachment":
      return null;
    case "assistant":
      if (A.message.content[0]?.type !== "tool_use") return null;
      return A.message.content[0].id;
    case "user":
      if (A.message.content[0]?.type !== "tool_result") return null;
      return A.message.content[0].tool_use_id;
    case "progress":
      return A.toolUseID;
    case "system":
      return A.subtype === "informational" ? (A.toolUseID ?? null) : null;
  }
}
function bJB(A) {
  let B = OI(A),
    Q = KE0(B);
  return B.filter((G, Y) => {
    if (G.type === "assistant" && G.message.content[0]?.type === "tool_use" && Q.has(G.message.content[0].id))
      return !1;
    return !0;
  });
}
function S25(A) {
  if (A.type !== "user") return !1;
  return A.message.content !== void 0 && typeof A.message.content === "string";
}
function $b(A) {
  if (A.type !== "assistant") return null;
  if (Array.isArray(A.message.content))
    return (
      A.message.content
        .filter((B) => B.type === "text")
        .map((B) => (B.type === "text" ? B.text : ""))
        .join(
          `
`,
        )
        .trim() || null
    );
  return null;
}
function Lb1(A) {
  if (typeof A === "string") return A;
  if (Array.isArray(A))
    return (
      A.filter((B) => B.type === "text")
        .map((B) => (B.type === "text" ? B.text : ""))
        .join(
          `
`,
        )
        .trim() || null
    );
  return null;
}
function fJB(A, B) {
  let Q = KI1(A);
  if (!Q) return [];
  return B.filter((Z) => Z.type === "progress" && Z.parentToolUseID === Q);
}
function HI1(A, B, Q, Z, G, Y) {
  if (A.type !== "stream_event" && A.type !== "stream_request_start") {
    B(A);
    return;
  }
  if (A.type === "stream_request_start") {
    G("requesting");
    return;
  }
  if (A.event.type === "message_stop") {
    (G("tool-use"), Y(() => []));
    return;
  }
  switch (A.event.type) {
    case "content_block_start":
      switch (A.event.content_block.type) {
        case "thinking":
        case "redacted_thinking":
          G("thinking");
          return;
        case "text":
          G("responding");
          return;
        case "tool_use": {
          G("tool-input");
          let I = A.event.content_block,
            W = A.event.index;
          Y((J) => [...J, { index: W, contentBlock: I, unparsedToolInput: "" }]);
          return;
        }
        case "server_tool_use":
        case "web_search_tool_result":
        case "code_execution_tool_result":
        case "mcp_tool_use":
        case "mcp_tool_result":
        case "container_upload":
          G("tool-input");
          return;
      }
      break;
    case "content_block_delta":
      switch (A.event.delta.type) {
        case "text_delta":
          Z(A.event.delta.text);
          return;
        case "input_json_delta": {
          let I = A.event.delta.partial_json,
            W = A.event.index;
          (Z(I),
            Y((J) => {
              let X = J.find((F) => F.index === W);
              if (!X) return J;
              return [...J.filter((F) => F !== X), { ...X, unparsedToolInput: X.unparsedToolInput + I }];
            }));
          return;
        }
        case "thinking_delta":
          Z(A.event.delta.thinking);
          return;
        case "signature_delta":
          Z(A.event.delta.signature);
          return;
        default:
          return;
      }
    case "message_delta":
      if (A.event.delta.stop_reason === "end_turn") Q();
      G("responding");
      return;
    default:
      G("responding");
      return;
  }
}
function JE0(A) {
  return `<system-reminder>
${A}
</system-reminder>`;
}
function r3(A) {
  return A.map((B) => {
    if (typeof B.message.content === "string")
      return { ...B, message: { ...B.message, content: JE0(B.message.content) } };
    else if (Array.isArray(B.message.content)) {
      let Q = B.message.content.map((Z) => {
        if (Z.type === "text") return { ...Z, text: JE0(Z.text) };
        return Z;
      });
      return { ...B, message: { ...B.message, content: Q } };
    }
    return B;
  });
}
function y25(A) {
  switch (A.type) {
    case "command_permissions":
      return [];
    case "directory":
      return r3([
        II1(gQ.name, { command: `ls ${k8([A.path])}`, description: `Lists files in ${A.path}` }),
        YI1(gQ, { stdout: A.content, stderr: "", interrupted: !1 }),
      ]);
    case "edited_text_file":
      return r3([
        bA({
          content: `Note: ${A.filename} was modified, either by the user or by a linter. This change was intentional, so make sure to take it into account as you proceed (ie. don't revert it unless the user asks you to). Don't tell the user this, since they are already aware. Here are the relevant changes (shown with line numbers):
${A.snippet}`,
          isMeta: !0,
        }),
      ]);
    case "edited_image_file":
      return [];
    case "file": {
      let Q = A.content;
      switch (Q.type) {
        case "image":
          return r3([II1(Q6.name, { file_path: A.filename }), YI1(Q6, Q)]);
        case "text":
          return r3([
            II1(Q6.name, { file_path: A.filename }),
            YI1(Q6, Q),
            ...(A.truncated
              ? [
                  bA({
                    content: `Note: The file ${A.filename} was too large and has been truncated to the first ${i41} lines. Don't tell the user about this truncation. Use ${Q6.name} to read more of the file if you need.`,
                    isMeta: !0,
                  }),
                ]
              : []),
          ]);
        case "notebook":
          return r3([II1(Q6.name, { file_path: A.filename }), YI1(Q6, Q)]);
        case "pdf":
          return r3([II1(Q6.name, { file_path: A.filename }), YI1(Q6, Q)]);
      }
      break;
    }
    case "compact_file_reference":
      return r3([
        bA({
          content: `Note: ${A.filename} was read before the last conversation was summarized, but the contents are too large to include. Use ${Q6.name} tool if you need to access it.`,
          isMeta: !0,
        }),
      ]);
    case "already_read_file":
      return [];
    case "selected_lines_in_ide": {
      let Z =
        A.content.length > 2000
          ? A.content.substring(0, 2000) +
            `
... (truncated)`
          : A.content;
      return r3([
        bA({
          content: `The user selected the lines ${A.lineStart} to ${A.lineEnd} from ${A.filename}:
${Z}

This may or may not be related to the current task.`,
          isMeta: !0,
        }),
      ]);
    }
    case "opened_file_in_ide":
      return r3([
        bA({
          content: `The user opened the file ${A.filename} in the IDE. This may or may not be related to the current task.`,
          isMeta: !0,
        }),
      ]);
    case "todo":
      if (A.itemCount === 0)
        return r3([
          bA({
            content: `This is a reminder that your todo list is currently empty. DO NOT mention this to the user explicitly because they are already aware. If you are working on tasks that would benefit from a todo list please use the ${FG.name} tool to create one. If not, please feel free to ignore. Again do not mention this message to the user.`,
            isMeta: !0,
          }),
        ]);
      else
        return r3([
          bA({
            content: `Your todo list has changed. DO NOT mention this explicitly to the user. Here are the latest contents of your todo list:

${JSON.stringify(A.content)}. Continue on with the tasks at hand if applicable.`,
            isMeta: !0,
          }),
        ]);
    case "todo_reminder": {
      let Q = A.content.map((G, Y) => `${Y + 1}. [${G.status}] ${G.content}`).join(`
`),
        Z = `The TodoWrite tool hasn't been used recently. If you're working on tasks that would benefit from tracking progress, consider using the TodoWrite tool to track progress. Also consider cleaning up the todo list if has become stale and no longer matches what you are working on. Only use it if it's relevant to the current work. This is just a gentle reminder - ignore if not applicable.
`;
      if (Q.length > 0)
        Z += `

Here are the existing contents of your todo list:

[${Q}]`;
      return r3([bA({ content: Z, isMeta: !0 })]);
    }
    case "nested_memory":
      return r3([
        bA({
          content: `Contents of ${A.content.path}:

${A.content.content}`,
          isMeta: !0,
        }),
      ]);
    case "queued_command": {
      let Q = Array.isArray(A.prompt)
        ? A.prompt.map((Z) => (Z.type === "text" ? Z.text : "")).join(`
`)
        : A.prompt;
      return r3([
        bA({
          content: `The user sent the following message:
${Q}

Please address this message and continue with your tasks.`,
          isMeta: !0,
        }),
      ]);
    }
    case "ultramemory":
      return r3([bA({ content: A.content, isMeta: !0 })]);
    case "output_style": {
      let Q = Uu[A.style];
      if (!Q) return [];
      return r3([
        bA({
          content: `${Q.name} output style is active. Remember to follow the specific guidelines for this style.`,
          isMeta: !0,
        }),
      ]);
    }
    case "diagnostics": {
      if (A.files.length === 0) return [];
      let Q = FE.formatDiagnosticsSummary(A.files);
      return r3([
        bA({
          content: `<new-diagnostics>The following new diagnostic issues were detected:

${Q}</new-diagnostics>`,
          isMeta: !0,
        }),
      ]);
    }
    case "plan_mode":
      return r3([
        bA({
          content: `Plan mode is active. The user indicated that they do not want you to execute yet -- you MUST NOT make any edits, run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to the system. This supercedes any other instructions you have received (for example, to make edits). Instead, you should:
1. Answer the user's query comprehensively
2. When you're done researching, present your plan by calling the ${CO.name} tool, which will prompt the user to confirm the plan. Do NOT make any file changes or run any tools that modify the system state in any way until the user has confirmed the plan.`,
          isMeta: !0,
        }),
      ]);
    case "mcp_resource": {
      let Q = A.content;
      if (!Q || !Q.contents || Q.contents.length === 0)
        return r3([
          bA({ content: `<mcp-resource server="${A.server}" uri="${A.uri}">(No content)</mcp-resource>`, isMeta: !0 }),
        ]);
      let Z = [];
      for (let G of Q.contents)
        if (G && typeof G === "object") {
          if ("text" in G && typeof G.text === "string")
            Z.push(
              { type: "text", text: "Full contents of resource:" },
              { type: "text", text: G.text },
              {
                type: "text",
                text: "Do NOT read this resource again unless you think it may have changed, since you already have the full contents.",
              },
            );
          else if ("blob" in G) {
            let Y = "mimeType" in G ? String(G.mimeType) : "application/octet-stream";
            Z.push({ type: "text", text: `[Binary content: ${Y}]` });
          }
        }
      if (Z.length > 0) return r3([bA({ content: Z, isMeta: !0 })]);
      else
        return (
          DA(A.server, `No displayable content found in MCP resource ${A.uri}.`),
          r3([
            bA({
              content: `<mcp-resource server="${A.server}" uri="${A.uri}">(No displayable content)</mcp-resource>`,
              isMeta: !0,
            }),
          ])
        );
    }
    case "agent_mention":
      return r3([
        bA({
          content: `The user has expressed a desire to invoke the agent "${A.agentType}". Please invoke the agent appropriately, passing in the required context to it. `,
          isMeta: !0,
        }),
      ]);
    case "background_remote_session_status":
      return r3([
        bA({
          content: `<background-remote-session-status>Task id:${A.taskId}
Title:${A.title}
Status:${A.status}
Delta summary since last flush:${A.deltaSummarySinceLastFlushToAttachment}</background-remote-session-status>`,
          isMeta: !0,
        }),
      ]);
    case "background_shell_status": {
      let Q = [`Background Bash ${A.taskId}`, `(command: ${A.command})`, `(status: ${A.status})`];
      if (A.exitCode !== void 0) Q.push(`(exit code: ${A.exitCode})`);
      if (A.hasNewOutput) Q.push("Has new output available. You can check its output using the BashOutput tool.");
      return [bA({ content: JE0(Q.join(" ")), isMeta: !0 })];
    }
    case "async_hook_response": {
      let Q = A.response,
        Z = [];
      if (Q.systemMessage) Z.push(bA({ content: Q.systemMessage, isMeta: !0 }));
      if (Q.hookSpecificOutput && "additionalContext" in Q.hookSpecificOutput && Q.hookSpecificOutput.additionalContext)
        Z.push(bA({ content: Q.hookSpecificOutput.additionalContext, isMeta: !0 }));
      return r3(Z);
    }
    case "memory": {
      let Q = A.memories.map((Z) => {
        let G = Z.remainingLines && Z.remainingLines > 0 ? ` (${Z.remainingLines} more lines in full file)` : "";
        return `## Previous Session (${(Z.lastModified instanceof Date ? Z.lastModified : new Date(Z.lastModified)).toLocaleDateString()})
Full session notes: ${Z.fullPath}${G}

${Z.content}`;
      }).join(`

---

`);
      return r3([
        bA({
          content: `<session-memory>
These session summaries are from PAST sessions that might not be related to the current task and may have outdated info. Do not assume the current task is related to these summaries, until the user's messages indicate so or reference similar tasks. Only a preview of each memory is shown - use the Read tool with the provided path to access full session memory when a session is relevant.

${Q}
</session-memory>`,
          isMeta: !0,
        }),
      ]);
    }
  }
  if (["autocheckpointing", "background_task_status"].includes(A.type)) return [];
  return (mk("normalizeAttachmentForAPI", new Error(`Unknown attachment type: ${A.type}`)), []);
}
function YI1(A, B) {
  try {
    let Q = A.mapToolResultToToolResultBlockParam(B, "1");
    if (Array.isArray(Q.content) && Q.content.some((Z) => Z.type === "image"))
      return bA({ content: Q.content, isMeta: !0 });
    return bA({ content: `Result of calling the ${A.name} tool: ${JSON.stringify(Q.content)}`, isMeta: !0 });
  } catch {
    return bA({ content: `Result of calling the ${A.name} tool: Error`, isMeta: !0 });
  }
}
function II1(A, B) {
  return bA({ content: `Called the ${A} tool with the following input: ${JSON.stringify(B)}`, isMeta: !0 });
}
function X3(A, B, Q, Z) {
  return {
    type: "system",
    subtype: "informational",
    content: A,
    isMeta: !1,
    timestamp: new Date().toISOString(),
    uuid: $E(),
    toolUseID: Q,
    level: B,
    ...(Z && { preventContinuation: Z }),
  };
}
function hJB(A, B) {
  return {
    type: "system",
    subtype: "post_tool_hook_success",
    content: B,
    toolName: A,
    level: "info",
    timestamp: new Date().toISOString(),
    uuid: $E(),
    isMeta: !1,
  };
}
function HE0(A) {
  return {
    type: "system",
    subtype: "post_tool_hook_cancelled",
    content: "cancelled",
    toolName: A,
    level: "info",
    timestamp: new Date().toISOString(),
    uuid: $E(),
    isMeta: !1,
  };
}
function gJB(A, B) {
  return {
    type: "system",
    subtype: "compact_boundary",
    content: "Conversation compacted",
    isMeta: !1,
    timestamp: new Date().toISOString(),
    uuid: $E(),
    level: "info",
    compactMetadata: { trigger: A, preTokens: B },
  };
}
function zI1(A) {
  return A?.type === "system" && A.subtype === "compact_boundary";
}
function k25(A) {
  for (let B = A.length - 1; B >= 0; B--) {
    let Q = A[B];
    if (Q && zI1(Q)) return B;
  }
  return -1;
}
function wb(A) {
  let B = k25(A);
  if (B === -1) return A;
  return A.slice(B);
}
function uJB(A, B) {
  if (A.type !== "user") return !0;
  if (A.isMeta) return !1;
  if (A.isVisibleInTranscriptOnly && !B) return !1;
  return !0;
}
async function* mJB(A) {
  let B = [];
  for await (let Q of A)
    if (S25(Q.message)) B.push(Q);
    else yield Q;
  for (let Q of B) yield Q;
}
import { join as w21 } from "path";
import { basename as nV5 } from "path";
import { randomUUID as _25 } from "crypto";
var x25 = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function tV(A) {
  if (typeof A !== "string") return null;
  return x25.test(A) ? A : null;
}
function dJB() {
  return _25();
}
function v25() {
  let A = k7A();
  if (A !== void 0) return A;
  let B = process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR;
  if (!B) return (vn(null), null);
  let Q = parseInt(B, 10);
  if (Number.isNaN(Q))
    return (
      d0(`CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${B}`),
      vn(null),
      null
    );
  try {
    let Z = w1(),
      G = process.platform === "darwin" || process.platform === "freebsd" ? `/dev/fd/${Q}` : `/proc/self/fd/${Q}`,
      Y = Z.readFileSync(G, { encoding: "utf8" }).trim();
    if (!Y) return (d0("File descriptor contained empty token"), vn(null), null);
    return (F1(`Successfully read token from file descriptor ${Q}`), vn(Y), Y);
  } catch (Z) {
    return (
      d0(`Failed to read token from file descriptor ${Q}: ${Z instanceof Error ? Z.message : String(Z)}`),
      vn(null),
      null
    );
  }
}
function DI1() {
  let A = process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN;
  if (A) return A;
  return v25();
}
var zE0 = new Map();
async function cJB(A, B, Q) {
  let Z = DI1();
  if (!Z) return (F1("No session token available for session persistence"), !1);
  try {
    let G = { Authorization: `Bearer ${Z}`, "Content-Type": "application/json" },
      Y = zE0.get(A);
    if (Y) G["Last-Uuid"] = Y;
    let I = await $2.put(Q, B, { headers: G, validateStatus: (W) => W < 500 });
    if (I.status === 200 || I.status === 201) {
      if ("uuid" in B && B.uuid) zE0.set(A, B.uuid);
      return (F1(`Successfully persisted session log entry for session ${A}`), !0);
    }
    if (I.status === 409) {
      let J = I.data.error?.message || "Concurrent modification detected";
      return (U1(new Error(`Session persistence conflict: UUID mismatch for session ${A}. ${J}`), rGA), !1);
    }
    if (I.status === 401) return (F1("Session token expired or invalid"), !1);
    return (F1(`Failed to persist session log: ${I.status} ${I.statusText}`), !1);
  } catch (G) {
    let Y = G;
    if (Y.response?.status === 409) {
      let I = Y.response.data;
      return (
        U1(
          new Error(
            `Session persistence conflict: UUID mismatch for session ${A}. ${I?.error?.message || "Concurrent modification detected"}`,
          ),
          oGA,
        ),
        !1
      );
    } else U1(new Error(`Error persisting session log: ${Y.message}`), tGA);
    return !1;
  }
}
async function lJB(A, B) {
  let Q = DI1();
  if (!Q) return (F1("No session token available for fetching session logs"), null);
  try {
    let Z = await $2.get(B, { headers: { Authorization: `Bearer ${Q}` }, validateStatus: (G) => G < 500 });
    if (Z.status === 200) {
      let G = Z.data;
      if (!G || typeof G !== "object" || !Array.isArray(G.loglines))
        return (U1(new Error(`Invalid session logs response format: ${JSON.stringify(G)}`), sGA), null);
      let Y = G.loglines;
      if (Array.isArray(Y) && Y.length > 0) {
        let I = Y[Y.length - 1];
        if (I && "uuid" in I && I.uuid) zE0.set(A, I.uuid);
      }
      return (F1(`Fetched ${Y.length} session logs for session ${A}`), Y);
    }
    if (Z.status === 404) return (F1(`No existing logs for session ${A}`), []);
    if (Z.status === 401) return (F1("Session token expired or invalid"), null);
    return (F1(`Failed to fetch session logs: ${Z.status} ${Z.statusText}`), null);
  } catch (Z) {
    return (U1(new Error(`Error fetching session logs: ${Z.message}`), aGA), null);
  }
}
var H2 = A1(V1(), 1),
  j$ = A1(V1(), 1);
var f25 = 7250,
  pJB = "https://github.com/anthropics/claude-code/issues";
function u01(A) {
  let B = A;
  return (
    (B = B.replace(/"(sk-ant[^\s"']{24,})"/g, '"[REDACTED_API_KEY]"')),
    (B = B.replace(/(?<![A-Za-z0-9"'])(sk-ant-?[A-Za-z0-9_-]{10,})(?![A-Za-z0-9"'])/g, "[REDACTED_API_KEY]")),
    (B = B.replace(/AWS key: "(AWS[A-Z0-9]{20,})"/g, 'AWS key: "[REDACTED_AWS_KEY]"')),
    (B = B.replace(/(AKIA[A-Z0-9]{16})/g, "[REDACTED_AWS_KEY]")),
    (B = B.replace(/(?<![A-Za-z0-9])(AIza[A-Za-z0-9_-]{35})(?![A-Za-z0-9])/g, "[REDACTED_GCP_KEY]")),
    (B = B.replace(
      /(?<![A-Za-z0-9])([a-z0-9-]+@[a-z0-9-]+\.iam\.gserviceaccount\.com)(?![A-Za-z0-9])/g,
      "[REDACTED_GCP_SERVICE_ACCOUNT]",
    )),
    (B = B.replace(/(["']?x-api-key["']?\s*[:=]\s*["']?)[^"',\s)}\]]+/gi, "$1[REDACTED_API_KEY]")),
    (B = B.replace(/(["']?authorization["']?\s*[:=]\s*["']?(bearer\s+)?)[^"',\s)}\]]+/gi, "$1[REDACTED_TOKEN]")),
    (B = B.replace(/(AWS[_-][A-Za-z0-9_]+\s*[=:]\s*)["']?[^"',\s)}\]]+["']?/gi, "$1[REDACTED_AWS_VALUE]")),
    (B = B.replace(/(GOOGLE[_-][A-Za-z0-9_]+\s*[=:]\s*)["']?[^"',\s)}\]]+["']?/gi, "$1[REDACTED_GCP_VALUE]")),
    (B = B.replace(/((API[-_]?KEY|TOKEN|SECRET|PASSWORD)\s*[=:]\s*)["']?[^"',\s)}\]]+["']?/gi, "$1[REDACTED]")),
    B
  );
}
function iJB() {
  return sJB().map((A) => {
    let B = { ...A };
    if (B && typeof B.error === "string") B.error = u01(B.error);
    return B;
  });
}
function aJB({ messages: A, initialDescription: B, onDone: Q }) {
  let [Z, G] = j$.useState("userInput"),
    [Y, I] = j$.useState(0),
    [W, J] = j$.useState(B ?? ""),
    [X, F] = j$.useState(null),
    [V, K] = j$.useState(null),
    [H, z] = j$.useState({ isGit: !1, gitState: null }),
    [D, C] = j$.useState(null),
    w = IB().columns - 4;
  j$.useEffect(() => {
    async function O() {
      let R = await JL(),
        P = null;
      if (R) P = await v$A();
      z({ isGit: R, gitState: P });
    }
    O();
  }, []);
  let E = Z2(),
    L = j$.useCallback(async () => {
      (G("submitting"), K(null), F(null));
      let O = iJB(),
        R = {
          message_count: A.length,
          datetime: new Date().toISOString(),
          description: W,
          platform: tA.platform,
          gitRepo: H.isGit,
          terminal: tA.terminal,
          version: {
            ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
            PACKAGE_URL: "@anthropic-ai/claude-code",
            README_URL: "https://docs.anthropic.com/s/claude-code",
            VERSION: "1.0.119",
          }.VERSION,
          transcript: dG(A),
          errors: O,
          lastApiRequest: qD1(),
        },
        [P, _] = await Promise.all([u25(R), g25(W)]);
      if ((C(_), P.success)) {
        if (P.feedbackId) (F(P.feedbackId), Y1("tengu_bug_report_submitted", { feedback_id: P.feedbackId }));
        G("done");
      } else {
        if (P.isZdrOrg)
          K("Feedback collection is not available for organizations with custom data retention policies.");
        else K("Could not submit feedback. Please try again later.");
        G("done");
      }
    }, [W, H.isGit, A]);
  return (
    s0((O, R) => {
      if (Z === "done") {
        if (R.return && D) {
          let P = h25(X ?? "", D, W, iJB());
          N$(P);
        }
        if (V) Q("Error submitting feedback / bug report");
        else Q("Feedback / bug report submitted");
        return;
      }
      if (V) {
        Q("Error submitting feedback / bug report");
        return;
      }
      if (R.escape) {
        Q("Feedback / bug report cancelled");
        return;
      }
      if (Z === "consent" && (R.return || O === " ")) L();
    }),
    H2.createElement(
      H2.Fragment,
      null,
      H2.createElement(
        y,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderColor: "permission",
          paddingX: 1,
          paddingBottom: 1,
          gap: 1,
        },
        H2.createElement(M, { bold: !0, color: "permission" }, "Submit Feedback / Bug Report"),
        Z === "userInput" &&
          H2.createElement(
            y,
            { flexDirection: "column", gap: 1 },
            H2.createElement(M, null, "Describe the issue below:"),
            H2.createElement(s4, {
              value: W,
              onChange: J,
              columns: w,
              onSubmit: () => G("consent"),
              onExitMessage: () => Q("Feedback cancelled"),
              cursorOffset: Y,
              onChangeCursorOffset: I,
            }),
            V &&
              H2.createElement(
                y,
                { flexDirection: "column", gap: 1 },
                H2.createElement(M, { color: "error" }, V),
                H2.createElement(M, { dimColor: !0 }, "Press any key to close"),
              ),
          ),
        Z === "consent" &&
          H2.createElement(
            y,
            { flexDirection: "column" },
            H2.createElement(M, null, "This report will include:"),
            H2.createElement(
              y,
              { marginLeft: 2, flexDirection: "column" },
              H2.createElement(
                M,
                null,
                "- Your feedback / bug description:",
                " ",
                H2.createElement(M, { dimColor: !0 }, W),
              ),
              H2.createElement(
                M,
                null,
                "- Environment info:",
                " ",
                H2.createElement(
                  M,
                  { dimColor: !0 },
                  tA.platform,
                  ", ",
                  tA.terminal,
                  ", v",
                  {
                    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
                    PACKAGE_URL: "@anthropic-ai/claude-code",
                    README_URL: "https://docs.anthropic.com/s/claude-code",
                    VERSION: "1.0.119",
                  }.VERSION,
                ),
              ),
              H.gitState &&
                H2.createElement(
                  M,
                  null,
                  "- Git repo metadata:",
                  " ",
                  H2.createElement(
                    M,
                    { dimColor: !0 },
                    H.gitState.branchName,
                    H.gitState.commitHash ? `, ${H.gitState.commitHash.slice(0, 7)}` : "",
                    H.gitState.remoteUrl ? ` @ ${H.gitState.remoteUrl}` : "",
                    !H.gitState.isHeadOnRemote && ", not synced",
                    !H.gitState.isClean && ", has local changes",
                  ),
                ),
              H2.createElement(M, null, "- Current session transcript"),
            ),
            H2.createElement(
              y,
              { marginTop: 1 },
              H2.createElement(
                M,
                { wrap: "wrap", dimColor: !0 },
                "We will use your feedback to debug related issues or to improve",
                " ",
                "Claude Code's functionality (eg. to reduce the risk of bugs occurring in the future). Anthropic will not train generative models using feedback from Claude Code.",
              ),
            ),
            H2.createElement(
              y,
              { marginTop: 1 },
              H2.createElement(
                M,
                null,
                "Press ",
                H2.createElement(M, { bold: !0 }, "Enter"),
                " to confirm and submit.",
              ),
            ),
          ),
        Z === "submitting" &&
          H2.createElement(y, { flexDirection: "row", gap: 1 }, H2.createElement(M, null, "Submitting report…")),
        Z === "done" &&
          H2.createElement(
            y,
            { flexDirection: "column" },
            V
              ? H2.createElement(M, { color: "error" }, V)
              : H2.createElement(M, { color: "success" }, "Thank you for your report!"),
            X && H2.createElement(M, { dimColor: !0 }, "Feedback ID: ", X),
            H2.createElement(
              y,
              { marginTop: 1 },
              H2.createElement(M, null, "Press "),
              H2.createElement(M, { bold: !0 }, "Enter "),
              H2.createElement(M, null, "to also create a GitHub issue, or any other key to close."),
            ),
          ),
      ),
      H2.createElement(
        y,
        { marginLeft: 1 },
        H2.createElement(
          M,
          { dimColor: !0 },
          E.pending
            ? H2.createElement(H2.Fragment, null, "Press ", E.keyName, " again to exit")
            : Z === "userInput"
              ? H2.createElement(H2.Fragment, null, "Enter to continue · Esc to cancel")
              : Z === "consent"
                ? H2.createElement(H2.Fragment, null, "Enter to submit · Esc to cancel")
                : null,
        ),
      ),
    )
  );
}
function h25(A, B, Q, Z) {
  let G = u01(B),
    Y = u01(Q),
    I = encodeURIComponent(`**Bug Description**
${Y}

**Environment Info**
- Platform: ${tA.platform}
- Terminal: ${tA.terminal}
- Version: ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.anthropic.com/s/claude-code", VERSION: "1.0.119" }.VERSION || "unknown"}
- Feedback ID: ${A}

**Errors**
\`\`\`json
`),
    W = encodeURIComponent("\n```\n"),
    J = encodeURIComponent(`
**Note:** Error logs were truncated.
`),
    X = JSON.stringify(Z),
    F = encodeURIComponent(X),
    V = `${pJB}/new?title=${encodeURIComponent(G)}&labels=user-reported,bug&body=`,
    K = f25 - V.length - I.length - W.length - J.length,
    H = "";
  if (F.length <= K) H = I + F + W;
  else {
    let z = F.substring(0, K);
    H = I + z + W + J;
  }
  return `${pJB}/new?title=${encodeURIComponent(G)}&body=${H}&labels=user-reported,bug`;
}
async function g25(A) {
  try {
    let B = await NI({
        systemPrompt: [
          "Generate a concise, technical issue title (max 80 chars) for a public GitHub issue based on this bug report for Claude Code.",
          "Claude Code is an agentic coding CLI based on the Anthropic API.",
          "The title should:",
          "- Include the type of issue [Bug] or [Feature Request] as the first thing in the title",
          "- Be concise, specific and descriptive of the actual problem",
          "- Use technical terminology appropriate for a software issue",
          '- For error messages, extract the key error (e.g., "Missing Tool Result Block" rather than the full message)',
          "- Be direct and clear for developers to understand the problem",
          '- If you cannot determine a clear issue, use "Bug Report: [brief description]"',
          "- Any LLM API errors are from the Anthropic API, not from any other model provider",
          "Your response will be directly used as the title of the Github issue, and as such should not contain any other commentary or explaination",
          'Examples of good titles include: "[Bug] Auto-Compact triggers to soon", "[Bug] Anthropic API Error: Missing Tool Result Block", "[Bug] Error: Invalid Model Name for Opus"',
        ],
        userPrompt: A,
        isNonInteractiveSession: !1,
        promptCategory: "bug_title",
      }),
      Q = B.message.content[0]?.type === "text" ? B.message.content[0].text : "Bug Report";
    if (Q.startsWith(API_ERROR)) return nJB(A);
    return Q;
  } catch (B) {
    return (U1(B instanceof Error ? B : new Error(String(B)), W3A), nJB(A));
  }
}
function nJB(A) {
  let B =
    A.split(`
`)[0] || "";
  if (B.length <= 60 && B.length > 5) return B;
  let Q = B.slice(0, 60);
  if (B.length > 60) {
    let Z = Q.lastIndexOf(" ");
    if (Z > 30) Q = Q.slice(0, Z);
    Q += "...";
  }
  return Q.length < 10 ? "Bug Report" : Q;
}
function Mb1(A) {
  if (A instanceof Error) {
    let B = new Error(u01(A.message));
    if (A.stack) B.stack = u01(A.stack);
    U1(B, J3A);
  } else {
    let B = u01(String(A));
    U1(new Error(B), X3A);
  }
}
async function u25(A) {
  try {
    let B = yV(!1);
    if (B.error) return { success: !1 };
    let Q = { "Content-Type": "application/json", "User-Agent": FM(), ...B.headers },
      Z = await $2.post(
        "https://api.anthropic.com/api/claude_cli_feedback",
        { content: JSON.stringify(A) },
        { headers: Q },
      );
    if (Z.status === 200) {
      let G = Z.data;
      if (G?.feedback_id) return { success: !0, feedbackId: G.feedback_id };
      return (Mb1(new Error("Failed to submit feedback: request did not return feedback_id")), { success: !1 });
    }
    return (Mb1(new Error("Failed to submit feedback:" + Z.status)), { success: !1 });
  } catch (B) {
    if ($2.isAxiosError(B) && B.response?.status === 403) {
      let Q = B.response.data;
      if (Q?.error?.type === "permission_error" && Q?.error?.message?.includes("Custom data retention settings"))
        return (
          Mb1(new Error("Cannot submit feedback because custom data retention settings are enabled")),
          { success: !1, isZdrOrg: !0 }
        );
    }
    return (Mb1(B), { success: !1 });
  }
}
var DE0 = A1(V1(), 1),
  m25 = {
    aliases: ["bug"],
    type: "local-jsx",
    name: "feedback",
    description: "Submit feedback about Claude Code",
    argumentHint: "[report]",
    isEnabled: () =>
      !(
        process.env.CLAUDE_CODE_USE_BEDROCK ||
        process.env.CLAUDE_CODE_USE_VERTEX ||
        process.env.DISABLE_FEEDBACK_COMMAND ||
        process.env.DISABLE_BUG_COMMAND ||
        process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC
      ),
    isHidden: !1,
    async call(A, { messages: B }, Q) {
      return DE0.createElement(aJB, { messages: B, initialDescription: Q || "", onDone: A });
    },
    userFacingName() {
      return "feedback";
    },
  },
  rJB = m25;
import { join as Ob1, parse as oJB, dirname as Rb1, resolve as d25 } from "path";
var c25 =
    "Codebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.",
  ej = 40000,
  m01 = 3000;
function tJB(A) {
  return Cu(A, WQ());
}
function eJB(A, B) {
  try {
    if (w1().existsSync(A)) {
      if (!w1().statSync(A).isFile()) return null;
      let Z = w1().readFileSync(A, { encoding: "utf-8" });
      return { path: A, type: B, content: Z };
    }
  } catch (Q) {
    if (Q instanceof Error && Q.message.includes("EACCES"))
      Y1("tengu_claude_md_permission_error", { is_access_error: 1, has_home_dir: A.includes(IQ()) ? 1 : 0 });
  }
  return null;
}
function l25(A, B) {
  let Q = new Set(),
    G = new dV().lex(A);
  function Y(I) {
    for (let W of I) {
      if (W.type === "code" || W.type === "codespan") continue;
      if (W.type === "text") {
        let J = W.text || "",
          X = /(?:^|\s)@((?:[^\s\\]|\\ )+)/g,
          F;
        while ((F = X.exec(J)) !== null) {
          let V = F[1];
          if (!V) continue;
          if (((V = V.replace(/\\ /g, " ")), V)) {
            if (
              V.startsWith("./") ||
              V.startsWith("~/") ||
              (V.startsWith("/") && V !== "/") ||
              (!V.startsWith("@") && !V.match(/^[#%^&*()]+/) && V.match(/^[a-zA-Z0-9._-]/))
            ) {
              let H = i9(V, Rb1(B));
              Q.add(H);
            }
          }
        }
      }
      if (W.tokens) Y(W.tokens);
      if (W.items) Y(W.items);
    }
  }
  return (Y(G), [...Q]);
}
var p25 = 5;
function od(A, B, Q, Z, G = 0, Y) {
  if (Q.has(A) || G >= p25) return [];
  let I = eJB(A, B);
  if (!I || !I.content.trim()) return [];
  if (Y) I.parent = Y;
  Q.add(A);
  let W = [];
  W.push(I);
  let { resolvedPath: J } = cJ(w1(), A);
  if (J !== A) Q.add(J);
  let X = l25(I.content, J);
  for (let F of X) {
    if (!tJB(F) && !Z) continue;
    let K = od(F, B, Q, Z, G + 1, A);
    W.push(...K);
  }
  return W;
}
var RI = YA((A = !1) => {
  let B = [],
    Q = new Set(),
    Z = w9(),
    G = A || Z.hasClaudeMdExternalIncludesApproved || !1,
    Y = td("Managed");
  B.push(...od(Y, "Managed", Q, G));
  let I = td("User");
  B.push(...od(I, "User", Q, !0));
  let W = [],
    J = WQ();
  while (J !== oJB(J).root) (W.push(J), (J = Rb1(J)));
  for (let X of W.reverse()) {
    let F = Ob1(X, "CLAUDE.md");
    B.push(...od(F, "Project", Q, G));
    let V = Ob1(X, ".claude", "CLAUDE.md");
    B.push(...od(V, "Project", Q, G));
    let K = Ob1(X, "CLAUDE.local.md");
    B.push(...od(K, "Local", Q, G));
  }
  return B;
});
function ed() {
  return RI().filter((A) => A.content.length > ej);
}
var AXB = () => {
  let A = RI(),
    B = [];
  for (let Q of A)
    if (Q.content) {
      let Z =
        Q.type === "Project"
          ? " (project instructions, checked into the codebase)"
          : Q.type === "Local"
            ? " (user's private project instructions, not checked in)"
            : " (user's private global instructions for all projects)";
      B.push(`Contents of ${Q.path}${Z}:

${Q.content}`);
    }
  if (B.length === 0) return "";
  return `${c25}

${B.join(`

`)}`;
};
function Ac() {
  return null;
}
function CE0() {
  return [];
}
function BXB(A, B) {
  let Q = [];
  if (!BE(A, B)) return Q;
  let Z = new Set(),
    G = WQ(),
    Y = Rb1(d25(A)),
    I = [],
    W = Y;
  while (W !== G && W !== oJB(W).root) {
    if (W.startsWith(G)) I.push(W);
    W = Rb1(W);
  }
  for (let J of I.reverse()) {
    let X = Ob1(J, "CLAUDE.md");
    Q.push(...od(X, "Project", Z, !1));
  }
  return Q;
}
function UE0() {
  for (let A of RI(!0)) if (A.type !== "User" && A.parent && !tJB(A.path)) return !0;
  return !1;
}
async function QXB() {
  let A = w9();
  if (A.hasClaudeMdExternalIncludesApproved || A.hasClaudeMdExternalIncludesWarningShown) return !1;
  return UE0();
}
var ZXB = 40000,
  i25 = YA(async () => {
    if (!(await JL())) return null;
    try {
      let [A, B, Q, Z] = await Promise.all([
          B2("git", ["branch", "--show-current"], { preserveOutputOnError: !1 }).then(({ stdout: Y }) => Y.trim()),
          B2("git", ["rev-parse", "--abbrev-ref", "origin/HEAD"], { preserveOutputOnError: !1 }).then(({ stdout: Y }) =>
            Y.replace("origin/", "").trim(),
          ),
          B2("git", ["status", "--short"], { preserveOutputOnError: !1 }).then(({ stdout: Y }) => Y.trim()),
          B2("git", ["log", "--oneline", "-n", "5"], { preserveOutputOnError: !1 }).then(({ stdout: Y }) => Y.trim()),
        ]),
        G =
          Q.length > ZXB
            ? Q.substring(0, ZXB) +
              `
... (truncated because it exceeds 40k characters. If you need more information, run "git status" using BashTool)`
            : Q;
      return `This is the git status at the start of the conversation. Note that this status is a snapshot in time, and will not update during the conversation.
Current branch: ${A}

Main branch (you will usually use this for PRs): ${B}

Status:
${G || "(clean)"}

Recent commits:
${Z}`;
    } catch (A) {
      return (U1(A instanceof Error ? A : new Error(String(A)), $ZA), null);
    }
  }),
  jD = YA(async () => {
    let A = await i25();
    return { ...(A ? { gitStatus: A } : {}) };
  }),
  eV = YA(async () => {
    let B = process.env.CLAUDE_CODE_DISABLE_CLAUDE_MDS ? null : AXB();
    return {
      ...(B ? { claudeMd: B } : {}),
      "important-instruction-reminders": `Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.
`,
    };
  });
async function S$(A) {
  let B = [],
    Q = [];
  for await (let Z of ZMA(A)) {
    if (Z.message) B.push(Z.message);
    if (Z.additionalContexts && Z.additionalContexts.length > 0) Q.push(...Z.additionalContexts);
  }
  if (Q.length > 0) {
    let Z = bA({
      content: `<session-start-hook>${Q.join(`

`)}</session-start-hook>`,
    });
    B.push(Z);
  }
  return B;
}
async function n25({ setMessages: A, readFileState: B }) {
  (await s$1("clear"),
    await n7(),
    A([]),
    eV.cache.clear?.(),
    RI.cache.clear?.(),
    V$(WQ()),
    B.clear(),
    Z7A(),
    await YXB());
  let Q = await S$("clear");
  if (Q.length > 0) A(Q);
}
var a25 = {
    type: "local",
    name: "clear",
    description: "Clear conversation history and free up context",
    aliases: ["reset", "new"],
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    async call(A, B) {
      return (await n25(B), { type: "text", value: "" });
    },
    userFacingName() {
      return "clear";
    },
  },
  GXB = a25;
function Tb1(A) {
  if (!A || A.trim() === "")
    return `Your task is to create a detailed summary of the conversation so far, paying close attention to the user's explicit requests and your previous actions.
This summary should be thorough in capturing technical details, code patterns, and architectural decisions that would be essential for continuing development work without losing context.

Before providing your final summary, wrap your analysis in <analysis> tags to organize your thoughts and ensure you've covered all necessary points. In your analysis process:

1. Chronologically analyze each message and section of the conversation. For each section thoroughly identify:
   - The user's explicit requests and intents
   - Your approach to addressing the user's requests
   - Key decisions, technical concepts and code patterns
   - Specific details like:
     - file names
     - full code snippets
     - function signatures
     - file edits
  - Errors that you ran into and how you fixed them
  - Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
2. Double-check for technical accuracy and completeness, addressing each required element thoroughly.

Your summary should include the following sections:

1. Primary Request and Intent: Capture all of the user's explicit requests and intents in detail
2. Key Technical Concepts: List all important technical concepts, technologies, and frameworks discussed.
3. Files and Code Sections: Enumerate specific files and code sections examined, modified, or created. Pay special attention to the most recent messages and include full code snippets where applicable and include a summary of why this file read or edit is important.
4. Errors and fixes: List all errors that you ran into, and how you fixed them. Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
5. Problem Solving: Document problems solved and any ongoing troubleshooting efforts.
6. All user messages: List ALL user messages that are not tool results. These are critical for understanding the users' feedback and changing intent.
6. Pending Tasks: Outline any pending tasks that you have explicitly been asked to work on.
7. Current Work: Describe in detail precisely what was being worked on immediately before this summary request, paying special attention to the most recent messages from both user and assistant. Include file names and code snippets where applicable.
8. Optional Next Step: List the next step that you will take that is related to the most recent work you were doing. IMPORTANT: ensure that this step is DIRECTLY in line with the user's most recent explicit requests, and the task you were working on immediately before this summary request. If your last task was concluded, then only list next steps if they are explicitly in line with the users request. Do not start on tangential requests or really old requests that were already completed without confirming with the user first.
                       If there is a next step, include direct quotes from the most recent conversation showing exactly what task you were working on and where you left off. This should be verbatim to ensure there's no drift in task interpretation.

Here's an example of how your output should be structured:

<example>
<analysis>
[Your thought process, ensuring all points are covered thoroughly and accurately]
</analysis>

<summary>
1. Primary Request and Intent:
   [Detailed description]

2. Key Technical Concepts:
   - [Concept 1]
   - [Concept 2]
   - [...]

3. Files and Code Sections:
   - [File Name 1]
      - [Summary of why this file is important]
      - [Summary of the changes made to this file, if any]
      - [Important Code Snippet]
   - [File Name 2]
      - [Important Code Snippet]
   - [...]

4. Errors and fixes:
    - [Detailed description of error 1]:
      - [How you fixed the error]
      - [User feedback on the error if any]
    - [...]

5. Problem Solving:
   [Description of solved problems and ongoing troubleshooting]

6. All user messages: 
    - [Detailed non tool use user message]
    - [...]

7. Pending Tasks:
   - [Task 1]
   - [Task 2]
   - [...]

8. Current Work:
   [Precise description of current work]

9. Optional Next Step:
   [Optional Next step to take]

</summary>
</example>

Please provide your summary based on the conversation so far, following this structure and ensuring precision and thoroughness in your response. 

There may be additional summarization instructions provided in the included context. If so, remember to follow these instructions when creating the above summary. Examples of instructions include:
<example>
## Compact Instructions
When summarizing the conversation focus on typescript code changes and also remember the mistakes you made and how you fixed them.
</example>

<example>
# Summary instructions
When you are using compact - please focus on test output and code changes. Include file reads verbatim.
</example>
`;
  return `Your task is to create a detailed summary of the conversation so far, paying close attention to the user's explicit requests and your previous actions.
This summary should be thorough in capturing technical details, code patterns, and architectural decisions that would be essential for continuing development work without losing context.

Before providing your final summary, wrap your analysis in <analysis> tags to organize your thoughts and ensure you've covered all necessary points. In your analysis process:

1. Chronologically analyze each message and section of the conversation. For each section thoroughly identify:
   - The user's explicit requests and intents
   - Your approach to addressing the user's requests
   - Key decisions, technical concepts and code patterns
   - Specific details like:
     - file names
     - full code snippets
     - function signatures
     - file edits
  - Errors that you ran into and how you fixed them
  - Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
2. Double-check for technical accuracy and completeness, addressing each required element thoroughly.

Your summary should include the following sections:

1. Primary Request and Intent: Capture all of the user's explicit requests and intents in detail
2. Key Technical Concepts: List all important technical concepts, technologies, and frameworks discussed.
3. Files and Code Sections: Enumerate specific files and code sections examined, modified, or created. Pay special attention to the most recent messages and include full code snippets where applicable and include a summary of why this file read or edit is important.
4. Errors and fixes: List all errors that you ran into, and how you fixed them. Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
5. Problem Solving: Document problems solved and any ongoing troubleshooting efforts.
6. All user messages: List ALL user messages that are not tool results. These are critical for understanding the users' feedback and changing intent.
6. Pending Tasks: Outline any pending tasks that you have explicitly been asked to work on.
7. Current Work: Describe in detail precisely what was being worked on immediately before this summary request, paying special attention to the most recent messages from both user and assistant. Include file names and code snippets where applicable.
8. Optional Next Step: List the next step that you will take that is related to the most recent work you were doing. IMPORTANT: ensure that this step is DIRECTLY in line with the user's most recent explicit requests, and the task you were working on immediately before this summary request. If your last task was concluded, then only list next steps if they are explicitly in line with the users request. Do not start on tangential requests or really old requests that were already completed without confirming with the user first.
                       If there is a next step, include direct quotes from the most recent conversation showing exactly what task you were working on and where you left off. This should be verbatim to ensure there's no drift in task interpretation.

Here's an example of how your output should be structured:

<example>
<analysis>
[Your thought process, ensuring all points are covered thoroughly and accurately]
</analysis>

<summary>
1. Primary Request and Intent:
   [Detailed description]

2. Key Technical Concepts:
   - [Concept 1]
   - [Concept 2]
   - [...]

3. Files and Code Sections:
   - [File Name 1]
      - [Summary of why this file is important]
      - [Summary of the changes made to this file, if any]
      - [Important Code Snippet]
   - [File Name 2]
      - [Important Code Snippet]
   - [...]

4. Errors and fixes:
    - [Detailed description of error 1]:
      - [How you fixed the error]
      - [User feedback on the error if any]
    - [...]

5. Problem Solving:
   [Description of solved problems and ongoing troubleshooting]

6. All user messages: 
    - [Detailed non tool use user message]
    - [...]

7. Pending Tasks:
   - [Task 1]
   - [Task 2]
   - [...]

8. Current Work:
   [Precise description of current work]

9. Optional Next Step:
   [Optional Next step to take]

</summary>
</example>

Please provide your summary based on the conversation so far, following this structure and ensuring precision and thoroughness in your response. 

There may be additional summarization instructions provided in the included context. If so, remember to follow these instructions when creating the above summary. Examples of instructions include:
<example>
## Compact Instructions
When summarizing the conversation focus on typescript code changes and also remember the mistakes you made and how you fixed them.
</example>

<example>
# Summary instructions
When you are using compact - please focus on test output and code changes. Include file reads verbatim.
</example>


Additional Instructions:
${A}`;
}
function s25(A) {
  let B = A,
    Q = B.match(/<analysis>([\s\S]*?)<\/analysis>/);
  if (Q) {
    let G = Q[1] || "";
    B = B.replace(
      /<analysis>[\s\S]*?<\/analysis>/,
      `Analysis:
${G.trim()}`,
    );
  }
  let Z = B.match(/<summary>([\s\S]*?)<\/summary>/);
  if (Z) {
    let G = Z[1] || "";
    B = B.replace(
      /<summary>[\s\S]*?<\/summary>/,
      `Summary:
${G.trim()}`,
    );
  }
  return (
    (B = B.replace(
      /\n\n+/g,
      `

`,
    )),
    B.trim()
  );
}
function IXB(A, B) {
  let Z = `This session is being continued from a previous conversation that ran out of context. The conversation is summarized below:
${s25(A)}.`;
  if (B)
    return `${Z}
Please continue the conversation from where we left it off without asking the user any further questions. Continue with the last task that you were asked to work on.`;
  return Z;
}
var r25 = YA(() => {
    return null;
  }),
  o25 = YA(() => {
    return null;
  });
function Pb1(A, B) {
  return;
}
import { join as jb1 } from "path";
function $E0() {
  let A = jb1(IQ(), "todos");
  if (!w1().existsSync(A)) w1().mkdirSync(A);
  return A;
}
function qb(A) {
  let B = `${U2()}-agent-${A}.json`;
  return jb1($E0(), B);
}
function AS(A) {
  return WXB(qb(A));
}
function Sb1(A, B) {
  JXB(A, qb(B));
}
function yb1(A) {
  if (A.messages.length > 0) {
    let B = A.messages[0];
    if (B && "sessionId" in B) t25(B.sessionId, U2());
  }
}
function t25(A, B) {
  let Q = jb1($E0(), `${A}-agent-${A}.json`),
    Z = jb1($E0(), `${B}-agent-${B}.json`);
  try {
    let G = WXB(Q);
    if (G.length === 0) return !1;
    return (JXB(G, Z), !0);
  } catch (G) {
    return (U1(G instanceof Error ? G : new Error(String(G)), $YA), !1);
  }
}
function WXB(A) {
  if (!w1().existsSync(A)) return [];
  try {
    let B = JSON.parse(w1().readFileSync(A, { encoding: "utf-8" }));
    return g11.parse(B);
  } catch (B) {
    return (U1(B instanceof Error ? B : new Error(String(B)), wYA), []);
  }
}
function JXB(A, B) {
  try {
    WL(B, JSON.stringify(A, null, 2));
  } catch (Q) {
    U1(Q instanceof Error ? Q : new Error(String(Q)), qYA);
  }
}
import { randomUUID as wB5 } from "node:crypto";
import { basename as zB5 } from "path";
var Eb = ["red", "blue", "green", "yellow", "purple", "orange", "pink", "cyan"],
  CI1 = {
    red: "red_FOR_SUBAGENTS_ONLY",
    blue: "blue_FOR_SUBAGENTS_ONLY",
    green: "green_FOR_SUBAGENTS_ONLY",
    yellow: "yellow_FOR_SUBAGENTS_ONLY",
    purple: "purple_FOR_SUBAGENTS_ONLY",
    orange: "orange_FOR_SUBAGENTS_ONLY",
    pink: "pink_FOR_SUBAGENTS_ONLY",
    cyan: "cyan_FOR_SUBAGENTS_ONLY",
  };
function d01(A) {
  if (A === "general-purpose") return;
  let B = do1(),
    Q = B.get(A);
  if (Q && Eb.includes(Q)) return CI1[Q];
  let Z = j7A(),
    G = Eb[Z % Eb.length];
  if ((S7A(), G)) return (B.set(A, G), CI1[G]);
  return;
}
function c01(A, B) {
  let Q = do1();
  if (!B) {
    Q.delete(A);
    return;
  }
  if (Eb.includes(B)) Q.set(A, B);
}
var kb1 = {
  agentType: "general-purpose",
  whenToUse:
    "General-purpose agent for researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries use this agent to perform the search for you.",
  tools: ["*"],
  systemPrompt: `You are an agent for Claude Code, Anthropic's official CLI for Claude. Given the user's message, you should use the tools available to complete the task. Do what has been asked; nothing more, nothing less. When you complete the task simply respond with a detailed writeup.

Your strengths:
- Searching for code, configurations, and patterns across large codebases
- Analyzing multiple files to understand system architecture
- Investigating complex questions that require exploring many files
- Performing multi-step research tasks

Guidelines:
- For file searches: Use Grep or Glob when you need to search broadly. Use Read when you know the specific file path.
- For analysis: Start broad and narrow down. Use multiple search strategies if the first doesn't yield results.
- Be thorough: Check multiple locations, consider different naming conventions, look for related files.
- NEVER create files unless they're absolutely necessary for achieving your goal. ALWAYS prefer editing an existing file to creating a new one.
- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested.
- In your final response always share relevant file names and code snippets. Any file paths you return in your response MUST be absolute. Do NOT use relative paths.
- For clear communication, avoid using emojis.`,
  source: "built-in",
  baseDir: "built-in",
  model: "sonnet",
};
var XXB = {
  agentType: "output-style-setup",
  whenToUse: "Use this agent to create a Claude Code output style.",
  tools: [READ_TOOL_NAME, WRITE_TOOL_NAME, EDIT_TOOL_NAME, GLOB_TOOL_NAME, GREP_TOOL_NAME],
  systemPrompt: `Your job is to create a custom output style, which modifies the Claude Code system prompt, based on the user's description.

For example, Claude Code's default output style directs Claude to focus "on software engineering tasks", giving Claude guidance like "When you have completed a task, you MUST run the lint and typecheck commands".

# Step 1: Understand Requirements
Extract preferences from the user's request such as:
- Response length (concise, detailed, comprehensive, etc)
- Tone (formal, casual, educational, professional, etc)
- Output display (bullet points, numbered lists, sections, etc)
- Focus areas (task completion, learning, quality, speed, etc)
- Workflow (sequence of specific tools to use, steps to follow, etc)
- Filesystem setup (specific files to look for, track state in, etc)
    - The style instructions should mention to create the files if they don't exist.

If the user's request is underspecified, use your best judgment of what the
requirements should be.

# Step 2: Generate Configuration
Create a configuration with:
- A brief description explaining the benefit to display to the user
- The additional content for the system prompt 

# Step 3: Choose File Location
Default to the user-level output styles directory (~/.claude/output-styles/) unless the user specifies to save to the project-level directory (.claude/output-styles/).
Generate a short, descriptive filename, which becomes the style name (e.g., "code-reviewer.md" for "Code Reviewer" style).

# Step 4: Save the File
Format as markdown with frontmatter:
\`\`\`markdown
---
description: Brief description for the picker
---

[The additional content that will be added to the system prompt]
\`\`\`

After creating the file, ALWAYS:
1. **Validate the file**: Use Read tool to verify the file was created correctly with valid frontmatter and proper markdown formatting
2. **Check file length**: Report the file size in characters/tokens to ensure it's reasonable for a system prompt (aim for under 2000 characters)
3. **Verify frontmatter**: Ensure the YAML frontmatter can be parsed correctly and contains required 'description' field

## Output Style Examples

**Concise**:
- Keep responses brief and to the point
- Focus on actionable steps over explanations
- Use bullet points for clarity
- Minimize context unless requested

**Educational**:
- Include learning explanations
- Explain the "why" behind decisions
- Add insights about best practices
- Balance education with task completion

**Code Reviewer**:
- Provide structured feedback
- Include specific analysis criteria
- Use consistent formatting
- Focus on code quality and improvements

# Step 5: Report the result
Inform the user that the style has been created, including:
- The file path where it was saved
- Confirmation that validation passed (file format is correct and parseable)
- The file length in characters for reference

# General Guidelines
- Include concrete examples when they would clarify behavior
- Balance comprehensiveness with clarity - every instruction should add value. The system prompt itself should not take up too much context.
`,
  source: "built-in",
  baseDir: "built-in",
  model: "sonnet",
  color: "blue",
  callback: () => {
    SPA();
  },
};
var FXB = {
  agentType: "statusline-setup",
  whenToUse: "Use this agent to configure the user's Claude Code status line setting.",
  tools: ["Read", "Edit"],
  systemPrompt: `You are a status line setup agent for Claude Code. Your job is to create or update the statusLine command in the user's Claude Code settings.

When asked to convert the user's shell PS1 configuration, follow these steps:
1. Read the user's shell configuration files in this order of preference:
   - ~/.zshrc
   - ~/.bashrc  
   - ~/.bash_profile
   - ~/.profile

2. Extract the PS1 value using this regex pattern: /(?:^|\\n)\\s*(?:export\\s+)?PS1\\s*=\\s*["']([^"']+)["']/m

3. Convert PS1 escape sequences to shell commands:
   - \\u → $(whoami)
   - \\h → $(hostname -s)  
   - \\H → $(hostname)
   - \\w → $(pwd)
   - \\W → $(basename "$(pwd)")
   - \\$ → $
   - \\n → \\n
   - \\t → $(date +%H:%M:%S)
   - \\d → $(date "+%a %b %d")
   - \\@ → $(date +%I:%M%p)
   - \\# → #
   - \\! → !

4. When using ANSI color codes, be sure to use \`printf\`. Do not remove colors. Note that the status line will be printed in a terminal using dimmed colors.

5. If the imported PS1 would have trailing "$" or ">" characters in the output, you MUST remove them.

6. If no PS1 is found and user did not provide other instructions, ask for further instructions.

How to use the statusLine command:
1. The statusLine command will receive the following JSON input via stdin:
   {
     "session_id": "string", // Unique session ID
     "transcript_path": "string", // Path to the conversation transcript
     "cwd": "string",         // Current working directory
     "model": {
       "id": "string",           // Model ID (e.g., "claude-3-5-sonnet-20241022")
       "display_name": "string"  // Display name (e.g., "Claude 3.5 Sonnet")
     },
     "workspace": {
       "current_dir": "string",  // Current working directory path
       "project_dir": "string"   // Project root directory path
     },
     "version": "string",        // Claude Code app version (e.g., "1.0.71")
     "output_style": {
       "name": "string",         // Output style name (e.g., "default", "Explanatory", "Learning")
     }
   }
   
   You can use this JSON data in your command like:
   - $(cat | jq -r '.model.display_name')
   - $(cat | jq -r '.workspace.current_dir')
   - $(cat | jq -r '.output_style.name')
   
   Or store it in a variable first:
   - input=$(cat); echo "$(echo "$input" | jq -r '.model.display_name') in $(echo "$input" | jq -r '.workspace.current_dir')"

2. For longer commands, you can save a new file in the user's ~/.claude directory, e.g.:
   - ~/.claude/statusline-command.sh and reference that file in the settings.

3. Update the user's ~/.claude/settings.json with:
   {
     "statusLine": {
       "type": "command", 
       "command": "your_command_here"
     }
   }

4. If ~/.claude/settings.json is a symlink, update the target file instead.

Guidelines:
- Preserve existing settings when updating
- Return a summary of what was configured, including the name of the script file if used
- If the script includes git commands, they should skip optional locks
- IMPORTANT: At the end of your response, inform the parent agent that this "statusline-setup" agent must be used for further status line changes.
  Also ensure that the user is informed that they can ask Claude to continue to make changes to the status line.
`,
  source: "built-in",
  baseDir: "built-in",
  model: "sonnet",
  color: "orange",
};
function wE0() {
  return [kb1, FXB, XXB];
}
import { join as FB5, basename as VB5 } from "path";
import { join as UO, dirname as QB5 } from "path";
import { createRequire as ZB5 } from "module";
var e25 = f.object({
    name: f.string().min(1, "Author name cannot be empty"),
    email: f.string().optional(),
    url: f.string().optional(),
  }),
  VXB = f.object({
    name: f.string().min(1, "Plugin name cannot be empty"),
    version: f.string().optional(),
    description: f.string().optional(),
    author: e25.optional(),
  });
import { join as UI1 } from "path";
var EE0 = UI1(IQ(), "plugins"),
  NE0 = UI1(EE0, "repos"),
  qE0 = UI1(EE0, "config.json");
async function AB5() {
  let A = w1();
  (A.mkdirSync(EE0), A.mkdirSync(NE0));
}
async function LE0() {
  let A = w1();
  try {
    if (!A.existsSync(qE0)) return { repositories: {} };
    let B = A.readFileSync(qE0, { encoding: "utf-8" });
    return JSON.parse(B);
  } catch (B) {
    return (d0(`Failed to load plugin config: ${B}`), { repositories: {} });
  }
}
async function BB5(A) {
  (await AB5(), w1().writeFileSync(qE0, JSON.stringify(A, null, 2), { encoding: "utf-8", flush: !0 }));
}
async function KXB() {
  let A = await LE0(),
    B = w1();
  for (let Q of Object.keys(A.repositories))
    try {
      let [Z, G] = Q.split("/");
      if (!Z || !G) {
        d0(`Invalid repository key format: ${Q}`);
        continue;
      }
      let Y = UI1(NE0, Z, G);
      if (!B.existsSync(Y)) {
        d0(`Repository directory not found for ${Q}, skipping update`);
        continue;
      }
      F1(`Auto-updating repository ${Q}...`);
      let { code: I, stderr: W, stdout: J } = await B2("git", ["-C", Y, "pull", "--ff-only"]);
      if (I !== 0) {
        d0(`Failed to auto-update repository ${Q}: ${W}`);
        continue;
      }
      let { stdout: X } = await B2("git", ["-C", Y, "rev-parse", "HEAD"]),
        F = A.repositories[Q];
      if (F) ((F.lastUpdated = new Date().toISOString()), (F.commitSha = X.trim()));
      F1(`Successfully auto-updated repository ${Q}: ${J.trim()}`);
    } catch (Z) {
      d0(`Error auto-updating repository ${Q}: ${Z}`);
    }
  await BB5(A);
}
function HXB(A) {
  let [B, Q] = A.split("/");
  if (!B || !Q) throw new Error(`Invalid repository key format: ${A}`);
  return UI1(NE0, B, Q);
}
function GB5(A) {
  if (A.includes("..") || A.includes("//")) return !1;
  let B = /^@[a-z0-9][a-z0-9-._]*\/[a-z0-9][a-z0-9-._]*$/,
    Q = /^[a-z0-9][a-z0-9-._]*$/;
  return B.test(A) || Q.test(A);
}
function YB5(A, B, Q) {
  let Z = w1();
  if (!Z.existsSync(A)) return { name: B, description: `Plugin from ${Q}` };
  try {
    let G = Z.readFileSync(A, { encoding: "utf-8" }),
      Y = JSON.parse(G),
      I = VXB.safeParse(Y);
    if (I.success) return I.data;
    let W = I.error.errors.map((J) => `${J.path.join(".")}: ${J.message}`).join(", ");
    return (d0(`Invalid manifest for ${B}: ${W}`), { name: B, description: `Plugin from ${Q}` });
  } catch (G) {
    return (d0(`Failed to parse manifest for ${B}: ${G}`), { name: B, description: `Plugin from ${Q}` });
  }
}
function IB5(A, B, Q) {
  let Z = w1();
  if (!Z.existsSync(A)) return;
  try {
    let G = Z.readFileSync(A, { encoding: "utf-8" }),
      Y = JSON.parse(G),
      I = v10.parse(Y);
    return XB5(I, B);
  } catch (G) {
    d0(`Failed to parse hooks config for ${Q}: ${G}`);
    return;
  }
}
function zXB(A, B, Q, Z) {
  let G = w1(),
    Y = UO(A, "plugin.json"),
    I = YB5(Y, Z, B),
    W = { name: I.name, manifest: I, path: A, repository: B, enabled: Q },
    J = UO(A, "commands");
  if (G.existsSync(J)) W.commandsPath = J;
  let X = UO(A, "agents");
  if (G.existsSync(X)) W.agentsPath = X;
  let F = UO(A, "hooks", "hooks.json"),
    V = IB5(F, A, I.name);
  if (V) W.hooksConfig = V;
  return W;
}
function WB5(A, B) {
  let Q = [],
    Z = w1(),
    Y = E2().enabledPlugins?.[B],
    I = Array.isArray(Y) ? Y : [];
  try {
    let W = Z.readdirSync(A);
    for (let J of W) {
      if (!J.isDirectory()) continue;
      if (J.name.startsWith(".")) continue;
      let X = UO(A, J.name),
        F = zXB(X, B, !1, J.name),
        V = I.includes(F.name);
      if (((F.enabled = V), Q.push(F), V)) F1(`Loaded plugin: ${F.name} from ${B}`);
      else F1(`Found disabled plugin: ${F.name} from ${B}`);
    }
  } catch (W) {
    d0(`Failed to scan repository ${B}: ${W}`);
  }
  return Q;
}
async function JB5(A) {
  let B = w1();
  if (!GB5(A)) return (d0(`Invalid npm package name: ${A}`), { type: "invalid-name", packageName: A });
  try {
    let Q = ZB5(UO(AA(), "package.json")),
      Z;
    try {
      Z = await new Promise((V, K) => {
        try {
          V(Q.resolve(`${A}/package.json`));
        } catch (H) {
          K(H);
        }
      });
    } catch (V) {
      return (d0(`Package ${A} not found in node_modules: ${V}`), { type: "not-found", packageName: A });
    }
    let G = QB5(Z),
      Y = B.existsSync(UO(G, "commands")),
      I = B.existsSync(UO(G, "agents")),
      W = B.existsSync(UO(G, "plugin.json")),
      J = B.existsSync(UO(G, "hooks", "hooks.json"));
    if (!Y && !I && !W && !J)
      return (d0(`Package ${A} does not have plugin structure`), { type: "not-plugin", packageName: A });
    let X = A.split("/").pop() || A,
      F = zXB(G, `npm:${A}`, !0, X);
    return (F1(`Loaded npm plugin: ${F.name} from ${A}`), { type: "success", plugin: F });
  } catch (Q) {
    return (d0(`Failed to scan npm package ${A}: ${Q}`), { type: "not-found", packageName: A });
  }
}
var BS = YA(async () => {
  KXB();
  let A = await LE0(),
    B = E2(),
    Q = [],
    Z = [],
    G = [],
    Y = w1(),
    I = new Map();
  for (let K of Object.keys(A.repositories)) {
    let H;
    try {
      H = HXB(K);
    } catch {
      G.push({ repository: K, error: `Invalid repository key format: ${K}` });
      continue;
    }
    if (!Y.existsSync(H)) {
      G.push({ repository: K, error: `Repository directory not found: ${H}` });
      continue;
    }
    try {
      let z = WB5(H, K);
      for (let D of z) {
        let C = I.get(D.name);
        if (C) {
          G.push({ repository: K, plugin: D.name, error: `Plugin name '${D.name}' conflicts with plugin from ${C}` });
          continue;
        }
        if ((I.set(D.name, K), D.enabled)) Q.push(D);
        else Z.push(D);
      }
    } catch (z) {
      G.push({ repository: K, error: z instanceof Error ? z.message : String(z) });
    }
  }
  let W = B.enabledPlugins || {},
    J = Object.entries(W).filter(([K, H]) => K.startsWith("npm:") && H === !0),
    X = await Promise.all(
      J.map(async ([K, H]) => {
        let z = K.slice(4);
        try {
          let D = await JB5(z);
          return { key: K, packageName: z, result: D };
        } catch (D) {
          return {
            key: K,
            packageName: z,
            result: { type: "error", error: D instanceof Error ? D.message : String(D) },
          };
        }
      }),
    );
  for (let { key: K, packageName: H, result: z } of X) {
    if ("error" in z) {
      G.push({ repository: K, error: z.error });
      continue;
    }
    switch (z.type) {
      case "success": {
        let D = I.get(z.plugin.name);
        if (D)
          G.push({
            repository: K,
            plugin: z.plugin.name,
            error: `Plugin name '${z.plugin.name}' conflicts with plugin from ${D}`,
          });
        else (I.set(z.plugin.name, K), Q.push(z.plugin));
        break;
      }
      case "not-found":
        G.push({ repository: K, error: `Package ${H} not found in node_modules` });
        break;
      case "not-plugin":
        G.push({
          repository: K,
          error: `Package ${H} does not have plugin structure (missing commands/, agents/, plugin.json, or hooks/)`,
        });
        break;
      case "invalid-name":
        G.push({ repository: K, error: `Invalid npm package name: ${H}` });
        break;
    }
  }
  let F = Object.keys(A.repositories).length,
    V = Object.entries(W).filter(([K, H]) => K.startsWith("npm:") && H === !0).length;
  return (
    F1(
      `Found ${Q.length + Z.length} plugins (${Q.length} enabled, ${Z.length} disabled) from ${F} repositories and ${V} npm packages`,
    ),
    { enabled: Q, disabled: Z, errors: G }
  );
});
function XB5(A, B) {
  let Z = JSON.stringify(A).replace(/\$\{CLAUDE_PLUGIN_ROOT\}/g, B);
  return JSON.parse(Z);
}
function KB5(A, B, Q) {
  let Z = [],
    G = w1();
  function Y(I, W = []) {
    try {
      let J = G.readdirSync(I);
      for (let X of J) {
        let F = FB5(I, X.name);
        if (X.isDirectory()) Y(F, [...W, X.name]);
        else if (X.isFile() && X.name.endsWith(".md")) {
          let V = HB5(F, B, W, Q);
          if (V) Z.push(V);
        }
      }
    } catch (J) {
      d0(`Failed to scan agents directory ${I}: ${J}`);
    }
  }
  return (Y(A), Z);
}
function HB5(A, B, Q, Z) {
  let G = w1();
  try {
    let Y = G.readFileSync(A, { encoding: "utf-8" }),
      { frontmatter: I, content: W } = B_(Y),
      J = I.name || VB5(A).replace(/\.md$/, ""),
      F = [B, ...Q, J].join(":"),
      V = I.description || I["when-to-use"] || `Agent from ${B} plugin`,
      K = dw1(I.tools),
      H = I.color,
      z = I.model;
    return {
      agentType: F,
      whenToUse: V,
      tools: K,
      systemPrompt: W.trim(),
      source: "plugin",
      color: H,
      model: z,
      filename: J,
      plugin: Z,
    };
  } catch (Y) {
    return (d0(`Failed to load agent from ${A}: ${Y}`), null);
  }
}
var l01 = YA(async () => {
  let { enabled: A, errors: B } = await BS(),
    Q = [];
  if (B.length > 0) F1(`Plugin loading errors: ${B.map((Z) => Z.error).join(", ")}`);
  for (let Z of A) {
    if (!Z.agentsPath) continue;
    try {
      let G = KB5(Z.agentsPath, Z.name, Z.repository);
      if ((Q.push(...G), G.length > 0)) F1(`Loaded ${G.length} agents from plugin ${Z.name}`);
    } catch (G) {
      d0(`Failed to load agents from plugin ${Z.name}: ${G}`);
    }
  }
  return (F1(`Total plugin agents loaded: ${Q.length}`), Q);
});
function ME0() {
  l01.cache?.clear?.();
}
var QS = YA(async () => {
    return (await y$()).activeAgents;
  }),
  y$ = YA(async () => {
    try {
      let A = await OL("agents"),
        B = [],
        Q = A.map(({ filePath: K, baseDir: H, frontmatter: z, content: D, source: C }) => {
          let w = CB5(K, H, z, D, C);
          if (!w) {
            let E = DB5(z);
            return (
              B.push({ path: K, error: E }),
              F1(`Failed to parse agent from ${K}: ${E}`),
              U1(new Error(E), q3A),
              Y1("tengu_agent_parse_error", { error: E, location: C }),
              null
            );
          }
          return w;
        }).filter((K) => K !== null),
        Z = process.env.ENABLE_PLUGINS ? await l01() : [],
        G = new Map(),
        Y = [],
        I = wE0(),
        W = Q.filter((K) => K.source === "policySettings"),
        J = Q.filter((K) => K.source === "userSettings"),
        X = Q.filter((K) => K.source === "projectSettings"),
        F = [I, Z, J, X, W];
      for (let K of F) for (let H of K) (G.set(H.agentType, H), Y.push(H));
      let V = Array.from(G.values());
      for (let K of V) if (K.color) c01(K.agentType, K.color);
      return { activeAgents: V, allAgents: Y, failedFiles: B.length > 0 ? B : void 0 };
    } catch (A) {
      let B = A instanceof Error ? A.message : String(A);
      (F1(`Error loading agent definitions: ${B}`), U1(A instanceof Error ? A : new Error(String(A)), $3A));
      let Q = wE0();
      return { activeAgents: Q, allAgents: Q, failedFiles: [{ path: "unknown", error: B }] };
    }
  });
function Bc() {
  (QS.cache?.clear?.(), y$.cache?.clear?.(), OL.cache?.clear?.(), ME0());
}
function DB5(A) {
  let { name: B, description: Q, model: Z } = A;
  if (!B || typeof B !== "string") return 'Missing required "name" field in frontmatter';
  if (!Q || typeof Q !== "string") return 'Missing required "description" field in frontmatter';
  if (Z && typeof Z === "string" && !L31.includes(Z)) return `Invalid model "${Z}". Valid options: ${L31.join(", ")}`;
  return "Unknown parsing error";
}
function CB5(A, B, Q, Z, G) {
  try {
    let { name: Y, description: I } = Q;
    if (!Y || typeof Y !== "string" || !I || typeof I !== "string") {
      let H = `Agent file ${A} is missing required '${!Y || typeof Y !== "string" ? "name" : "description"}' in frontmatter`;
      return (F1(H), U1(new Error(H), w3A), null);
    }
    I = I.replace(
      /\\n/g,
      `
`,
    );
    let { color: W, model: J } = Q,
      X = J && typeof J === "string" && L31.includes(J);
    if (J && typeof J === "string" && !X) {
      let K = `Agent file ${A} has invalid model '${J}'. Valid options: ${L31.join(", ")}`;
      (F1(K), U1(new Error(K), U3A));
    }
    let F = zB5(A, ".md");
    return {
      baseDir: B,
      agentType: Y,
      whenToUse: I,
      tools: dw1(Q.tools),
      systemPrompt: Z.trim(),
      source: G,
      filename: F,
      ...(W && typeof W === "string" && Eb.includes(W) ? { color: W } : {}),
      ...(X ? { model: J } : {}),
    };
  } catch (Y) {
    let I = Y instanceof Error ? Y.message : String(Y);
    return (F1(`Error parsing agent from ${A}: ${I}`), U1(Y instanceof Error ? Y : new Error(String(Y)), E3A), null);
  }
}
import { join as DXB } from "path";
var UB5 = 1e4,
  $B5 = 300,
  OE0 = DXB(IQ(), "session-memory");
async function CXB(A, B, Q) {
  if (Q !== "repl_main_thread") return [];
  return [];
}
var UXB = { TURNS_SINCE_WRITE: 7, TURNS_BETWEEN_REMINDERS: 3 },
  qB5 = { TOKEN_COOLDOWN: 5000 };
async function EB5(A, B, Q, Z, G, Y) {
  let I = C4();
  setTimeout(() => {
    I.abort();
  }, 1000);
  let W = { ...B, abortController: I },
    J = B.agentId === U2(),
    X = A
      ? [
          SX("at_mentioned_files", () => PB5(A, W)),
          SX("mcp_resources", () => SB5(A, W)),
          SX("agent_mentions", () => jB5(A)),
        ]
      : [],
    F = [
      SX("changed_files", () => yB5(W)),
      SX("nested_memory", () => kB5(W)),
      SX("ultra_claude_md", async () => OB5(G)),
      SX("plan_mode", () => LB5(B)),
      SX("todo_reminders", () => mB5(G, B)),
    ],
    V = J
      ? [
          SX("ide_selection", async () => RB5(Q, B)),
          SX("ide_opened_file", async () => TB5(Q)),
          SX("output_style", async () => Promise.resolve(MB5())),
          SX("queued_commands", async () => NB5(Z)),
          SX("diagnostics", async () => gB5()),
          SX("background_shells", async () => cB5(B)),
          SX("background_remote_sessions", async () => dB5(B)),
          SX("async_hook_responses", async () => lB5()),
          SX("memory", async () => CXB(B, G, Y)),
        ]
      : [];
  return (await Promise.all([...X, ...F, ...V])).flat();
}
async function SX(A, B) {
  let Q = Date.now();
  try {
    let Z = await B(),
      G = Date.now() - Q;
    if (Math.random() < 0.05) Y1("tengu_attachment_compute_duration", { label: A, duration_ms: G });
    return Z;
  } catch (Z) {
    let G = Date.now() - Q;
    if (Math.random() < 0.05) Y1("tengu_attachment_compute_duration", { label: A, duration_ms: G, error: !0 });
    return (U1(Z, STYLE_CODE_213), mk(`Attachment error in ${A}`, Z), []);
  }
}
function NB5(A) {
  if (!A) return [];
  return A.filter((B) => B.mode === "prompt").map((B) => ({
    type: "queued_command",
    prompt: B.value,
    source_uuid: B.uuid,
  }));
}
async function LB5(A) {
  if ((await A.getAppState()).toolPermissionContext.mode !== "plan") return [];
  return [{ type: "plan_mode" }];
}
function MB5() {
  let B = E2()?.outputStyle || "default";
  if (B === "default") return [];
  return [{ type: "output_style", style: B }];
}
function OB5(A) {
  return [];
}
function RB5(A, B) {
  let Q = Uv1(B.options.mcpClients);
  if (!Q || A?.lineStart === void 0 || !A.text || !A.filePath) return [];
  if (z$(A.filePath)) return [];
  return [
    {
      type: "selected_lines_in_ide",
      ideName: Q,
      lineStart: A.lineStart,
      lineEnd: A.lineStart + A.lineCount - 1,
      filename: A.filePath,
      content: A.text,
    },
  ];
}
function TB5(A) {
  if (!A?.filePath || A.text) return [];
  if (z$(A.filePath)) return [];
  return [{ type: "opened_file_in_ide", filename: A.filePath }];
}
async function PB5(A, B) {
  let Q = _B5(A);
  return (
    await Promise.all(
      Q.map(async (G) => {
        try {
          let { filename: Y, lineStart: I, lineEnd: W } = bB5(G),
            J = i9(Y);
          if (z$(J)) return null;
          try {
            if (w1().statSync(J).isDirectory())
              try {
                let F = await QO(gQ.call({ command: `ls ${k8([J])}`, description: `Lists files in ${J}` }, B));
                return (
                  Y1("tengu_at_mention_extracting_directory_success", {}),
                  { type: "directory", path: J, content: F }
                );
              } catch {
                return null;
              }
          } catch {}
          return await RE0(
            J,
            B,
            "tengu_at_mention_extracting_filename_success",
            "tengu_at_mention_extracting_filename_error",
            "at-mention",
            { offset: I, limit: W && I ? W - I + 1 : void 0 },
          );
        } catch {
          Y1("tengu_at_mention_extracting_filename_error", {});
        }
      }),
    )
  ).filter(Boolean);
}
async function jB5(A) {
  let B = vB5(A);
  if (B.length === 0) return [];
  try {
    let Q = await QS();
    return B.map((G) => {
      let Y = G.replace("agent-", ""),
        I = Q.find((W) => W.agentType === Y);
      if (!I) return (Y1("tengu_at_mention_agent_not_found", {}), null);
      return (Y1("tengu_at_mention_agent_success", {}), { type: "agent_mention", agentType: I.agentType });
    }).filter((G) => G !== null);
  } catch (Q) {
    return (U1(Q, STYLE_CODE_213), []);
  }
}
async function SB5(A, B) {
  let Q = xB5(A);
  if (Q.length === 0) return [];
  let Z = B.options.mcpClients || [];
  return (
    await Promise.all(
      Q.map(async (Y) => {
        try {
          let [I, ...W] = Y.split(":"),
            J = W.join(":");
          if (!I || !J) return (Y1("tengu_at_mention_mcp_resource_error", {}), null);
          let X = Z.find((K) => K.name === I);
          if (!X || X.type !== "connected") return (Y1("tengu_at_mention_mcp_resource_error", {}), null);
          let V = (B.options.mcpResources?.[I] || []).find((K) => K.uri === J);
          if (!V) return (Y1("tengu_at_mention_mcp_resource_error", {}), null);
          try {
            let K = await X.client.readResource({ uri: J });
            return (
              Y1("tengu_at_mention_mcp_resource_success", {}),
              { type: "mcp_resource", server: I, uri: J, name: V.name || J, description: V.description, content: K }
            );
          } catch (K) {
            return (Y1("tengu_at_mention_mcp_resource_error", {}), U1(K, RD1), null);
          }
        } catch {
          return (Y1("tengu_at_mention_mcp_resource_error", {}), null);
        }
      }),
    )
  ).filter((Y) => Y !== null);
}
async function yB5(A) {
  return (
    await Promise.all(
      mv(A.readFileState).map(async (Q) => {
        let Z = A.readFileState.get(Q);
        if (!Z) return null;
        if (z$(Q)) return null;
        try {
          if (w1().statSync(Q).mtimeMs <= Z.timestamp) return null;
          let Y = { file_path: Q };
          if (!(await Q6.validateInput(Y)).result) return null;
          let W = await QO(Q6.call(Y, A));
          if ((Y1("tengu_watched_file_changed", {}), Q === qb(A.agentId))) {
            let J = AS(A.agentId);
            return { type: "todo", content: J, itemCount: J.length, context: "file-watch" };
          }
          if (W.data.type === "text") {
            if (sU0(Z.content, W.data.file.content) === "") return null;
            return { type: "edited_text_file", filename: Q, snippet: sU0(Z.content, W.data.file.content) };
          }
          return { type: "edited_image_file", filename: Q, content: W.data };
        } catch {
          return (Y1("tengu_watched_file_stat_error", {}), null);
        }
      }),
    )
  ).filter((Q) => Q !== null);
}
async function kB5(A) {
  let B = await A.getAppState(),
    Q = [];
  if (A.nestedMemoryAttachmentTriggers && A.nestedMemoryAttachmentTriggers.size > 0) {
    for (let Z of A.nestedMemoryAttachmentTriggers)
      try {
        let G = BXB(Z, B.toolPermissionContext);
        for (let Y of G)
          if (!A.readFileState.has(Y.path))
            (Q.push({ type: "nested_memory", path: Y.path, content: Y }),
              A.readFileState.set(Y.path, { content: Y.content, timestamp: Date.now() }));
      } catch (G) {
        U1(G, OD1);
      }
    A.nestedMemoryAttachmentTriggers.clear();
  }
  return Q;
}
function _B5(A) {
  let B = /(^|\s)@"([^"]+)"/g,
    Q = /(^|\s)@([^\s]+)\b/g,
    Z = [],
    G = [],
    Y;
  while ((Y = B.exec(A)) !== null) if (Y[2]) Z.push(Y[2]);
  return (
    (A.match(Q) || []).forEach((W) => {
      let J = W.slice(W.indexOf("@") + 1);
      if (!J.startsWith('"')) G.push(J);
    }),
    [...new Set([...Z, ...G])]
  );
}
function xB5(A) {
  let B = /(^|\s)@([^\s]+:[^\s]+)\b/g,
    Q = A.match(B) || [];
  return [...new Set(Q.map((Z) => Z.slice(Z.indexOf("@") + 1)))];
}
function vB5(A) {
  let B = /(^|\s)@(agent-[a-zA-Z0-9-]+)\b/g,
    Q = A.match(B) || [];
  return [...new Set(Q.map((Z) => Z.slice(Z.indexOf("@") + 1)))];
}
function bB5(A) {
  let B = A.match(/^([^#]+)(?:#L(\d+)(?:-(\d+))?)?$/);
  if (!B) return { filename: A };
  let [, Q, Z, G] = B,
    Y = Z ? parseInt(Z, 10) : void 0,
    I = G ? parseInt(G, 10) : Y;
  return { filename: Q ?? A, lineStart: Y, lineEnd: I };
}
function fB5(A) {
  let B = 0,
    Q = !1;
  for (let Z = A.length - 1; Z >= 0; Z--) {
    let G = A[Z];
    if (G?.type === "attachment" && G.attachment.type === "ultramemory") {
      Q = !0;
      break;
    }
    if (G?.type === "assistant") B += X9B(G);
  }
  return Q ? B : null;
}
function hB5(A) {
  if (!A || A.length === 0) return !0;
  let B = fB5(A);
  if (B === null) return !0;
  return B >= qB5.TOKEN_COOLDOWN;
}
async function gB5() {
  let A = await VE.getNewDiagnostics();
  if (A.length === 0) return [];
  return [{ type: "diagnostics", files: A, isNew: !0 }];
}
async function* p01(A, B, Q, Z, G, Y) {
  let I = await EB5(A, B, Q, Z, G, Y);
  if (I.length === 0) return;
  Y1("tengu_attachments", { attachment_types: I.map((W) => W.type) });
  for (let W of I) yield i01(W);
}
async function RE0(A, B, Q, Z, G, Y) {
  let { offset: I, limit: W } = Y ?? {};
  if (z$(A)) return null;
  let J = B.readFileState.get(A);
  if (J && G === "at-mention")
    try {
      let X = w1().statSync(A);
      if (J.timestamp <= X.mtimeMs && X.mtimeMs === J.timestamp)
        return (
          Y1(Q, {}),
          {
            type: "already_read_file",
            filename: A,
            content: {
              type: "text",
              file: {
                filePath: A,
                content: J.content,
                numLines: J.content.split(`
`).length,
                startLine: I ?? 1,
                totalLines: J.content.split(`
`).length,
              },
            },
          }
        );
    } catch {}
  try {
    let X = { file_path: A, offset: I, limit: W };
    async function F() {
      if (G === "compact") return { type: "compact_file_reference", filename: A };
      try {
        let K = { file_path: A, offset: I ?? 1, limit: i41 },
          H = await QO(Q6.call(K, B));
        return (Y1(Q, {}), { type: "file", filename: A, content: H.data, truncated: !0 });
      } catch {
        return (Y1(Z, {}), null);
      }
    }
    let V = await Q6.validateInput(X);
    if (!V.result) {
      if (V.meta?.fileSize) return await F();
      return null;
    }
    try {
      let K = await QO(Q6.call(X, B));
      return (Y1(Q, {}), { type: "file", filename: A, content: K.data });
    } catch (K) {
      if (K instanceof M_1) return await F();
      throw K;
    }
  } catch {
    return (Y1(Z, {}), null);
  }
}
function i01(A) {
  return { attachment: A, type: "attachment", uuid: wB5(), timestamp: new Date().toISOString() };
}
function uB5(A) {
  let B = -1,
    Q = -1,
    Z = 0,
    G = 0;
  for (let Y = A.length - 1; Y >= 0; Y--) {
    let I = A[Y];
    if (I?.type === "assistant") {
      if (B === -1) Z++;
      if (Q === -1) G++;
      if (
        B === -1 &&
        "message" in I &&
        Array.isArray(I.message?.content) &&
        I.message.content.some((W) => W.type === "tool_use" && W.name === "TodoWrite")
      )
        B = Y;
    } else if (Q === -1 && I?.type === "attachment" && I.attachment.type === "todo_reminder") Q = Y;
    if (B !== -1 && Q !== -1) break;
  }
  return { turnsSinceLastTodoWrite: Z, turnsSinceLastReminder: G };
}
async function mB5(A, B) {
  if (!A || A.length === 0) return [];
  let { turnsSinceLastTodoWrite: Q, turnsSinceLastReminder: Z } = uB5(A);
  if (Q >= UXB.TURNS_SINCE_WRITE && Z >= UXB.TURNS_BETWEEN_REMINDERS) {
    let G = AS(B.agentId);
    return [{ type: "todo_reminder", content: G, itemCount: G.length }];
  }
  return [];
}
async function dB5(A) {
  return [];
}
async function cB5(A) {
  let B = await A.getAppState(),
    Q = Object.values(B.backgroundTasks).filter((Y) => Y.type === "shell"),
    Z = _9B(Q)
      .filter((Y) => Y.hasNewOutput)
      .map((Y) => ({
        type: "background_shell_status",
        taskId: Y.id,
        command: Y.command,
        status: "running",
        hasNewOutput: Y.hasNewOutput,
      })),
    G = x9B(Q).map((Y) => ({
      type: "background_shell_status",
      taskId: Y.id,
      command: Y.command,
      status: Y.status,
      exitCode: Y.result?.code,
      hasNewOutput: uC0(Y),
    }));
  return (
    A.setAppState((Y) => ({
      ...Y,
      backgroundTasks: {
        ...Y.backgroundTasks,
        ...Object.fromEntries(Q.map((I) => [I.id, { ...I, completionStatusSentInAttachment: !0 }])),
      },
    })),
    [...Z, ...G]
  );
}
async function lB5() {
  F1("Hooks: getAsyncHookResponseAttachments called");
  let A = cLA();
  if (A.length === 0) return [];
  F1(`Hooks: getAsyncHookResponseAttachments found ${A.length} responses`);
  let B = A.map(({ processId: Q, response: Z, hookName: G, hookEvent: Y, toolName: I }) => {
    return (
      F1(`Hooks: Creating attachment for ${Q} (${G}): ${JSON.stringify(Z)}`),
      { type: "async_hook_response", processId: Q, hookName: G, hookEvent: Y, toolName: I, response: Z }
    );
  });
  if (A.length > 0) {
    let Q = A.map((Z) => Z.processId);
    (lLA(Q), F1(`Hooks: Removed ${Q.length} delivered hooks from registry`));
  }
  return B;
}
function _b1(A) {
  return A.attachment.type === "queued_command";
}
var $XB = ["User", "Project", "Local", "Managed", "ExperimentalUltraClaudeMd"];
function wXB(A) {
  if (A === "Local") return "project (local)";
  return A.toLowerCase();
}
var xb1 = 20000;
function Nb(A) {
  if (A.includes("[1m]")) return 1e6;
  return 200000;
}
function EXB(A) {
  let B = {
      toolRequests: new Map(),
      toolResults: new Map(),
      humanMessages: 0,
      assistantMessages: 0,
      localCommandOutputs: 0,
      other: 0,
      attachments: new Map(),
      duplicateFileReads: new Map(),
      total: 0,
    },
    Q = new Map(),
    Z = new Map(),
    G = new Map();
  return (
    A.forEach((I) => {
      if (I.type === "attachment") {
        let W = I.attachment.type || "unknown";
        B.attachments.set(W, (B.attachments.get(W) || 0) + 1);
      }
    }),
    dG(A).forEach((I) => {
      let { content: W } = I.message;
      if (typeof W === "string") {
        let J = w3(W);
        if (((B.total += J), I.type === "user" && W.includes("local-command-stdout"))) B.localCommandOutputs += J;
        else B[I.type === "user" ? "humanMessages" : "assistantMessages"] += J;
      } else W.forEach((J) => pB5(J, I, B, Q, Z, G));
    }),
    G.forEach((I, W) => {
      if (I.count > 1) {
        let X = Math.floor(I.totalTokens / I.count) * (I.count - 1);
        B.duplicateFileReads.set(W, { count: I.count, tokens: X });
      }
    }),
    B
  );
}
function pB5(A, B, Q, Z, G, Y) {
  let I = w3(JSON.stringify(A));
  switch (((Q.total += I), A.type)) {
    case "text":
      if (B.type === "user" && "text" in A && A.text.includes("local-command-stdout")) Q.localCommandOutputs += I;
      else Q[B.type === "user" ? "humanMessages" : "assistantMessages"] += I;
      break;
    case "tool_use": {
      if ("name" in A && "id" in A) {
        let W = A.name || "unknown";
        if (
          (qXB(Q.toolRequests, W, I),
          Z.set(A.id, W),
          W === "Read" && "input" in A && A.input && typeof A.input === "object" && "file_path" in A.input)
        ) {
          let J = String(A.input.file_path);
          G.set(A.id, J);
        }
      }
      break;
    }
    case "tool_result": {
      if ("tool_use_id" in A) {
        let W = Z.get(A.tool_use_id) || "unknown";
        if ((qXB(Q.toolResults, W, I), W === "Read")) {
          let J = G.get(A.tool_use_id);
          if (J) {
            let X = Y.get(J) || { count: 0, totalTokens: 0 };
            Y.set(J, { count: X.count + 1, totalTokens: X.totalTokens + I });
          }
        }
      }
      break;
    }
    case "image":
    case "server_tool_use":
    case "web_search_tool_result":
    case "search_result":
    case "document":
    case "thinking":
    case "redacted_thinking":
    case "code_execution_tool_result":
    case "mcp_tool_use":
    case "mcp_tool_result":
    case "container_upload":
      Q.other += I;
      break;
  }
}
function qXB(A, B, Q) {
  A.set(B, (A.get(B) || 0) + Q);
}
function NXB(A) {
  let B = {
    total_tokens: A.total,
    human_message_tokens: A.humanMessages,
    assistant_message_tokens: A.assistantMessages,
    local_command_output_tokens: A.localCommandOutputs,
    other_tokens: A.other,
  };
  (A.attachments.forEach((Z, G) => {
    B[`attachment_${G}_count`] = Z;
  }),
    A.toolRequests.forEach((Z, G) => {
      B[`tool_request_${G}_tokens`] = Z;
    }),
    A.toolResults.forEach((Z, G) => {
      B[`tool_result_${G}_tokens`] = Z;
    }));
  let Q = [...A.duplicateFileReads.values()].reduce((Z, G) => Z + G.tokens, 0);
  if (((B.duplicate_read_tokens = Q), (B.duplicate_read_file_count = A.duplicateFileReads.size), A.total > 0)) {
    ((B.human_message_percent = Math.round((A.humanMessages / A.total) * 100)),
      (B.assistant_message_percent = Math.round((A.assistantMessages / A.total) * 100)),
      (B.local_command_output_percent = Math.round((A.localCommandOutputs / A.total) * 100)),
      (B.duplicate_read_percent = Math.round((Q / A.total) * 100)));
    let Z = [...A.toolRequests.values()].reduce((Y, I) => Y + I, 0),
      G = [...A.toolResults.values()].reduce((Y, I) => Y + I, 0);
    ((B.tool_request_percent = Math.round((Z / A.total) * 100)),
      (B.tool_result_percent = Math.round((G / A.total) * 100)),
      A.toolRequests.forEach((Y, I) => {
        B[`tool_request_${I}_percent`] = Math.round((Y / A.total) * 100);
      }),
      A.toolResults.forEach((Y, I) => {
        B[`tool_result_${I}_percent`] = Math.round((Y / A.total) * 100);
      }));
  }
  return B;
}
var iB5 = 5,
  nB5 = 50000,
  aB5 = 5000,
  $I1 = "Not enough messages to compact.",
  sB5 = "Conversation too long. Press esc twice to go up a few messages and try again.",
  wI1 = "API Error: Request was aborted.";
async function vb1(A, B, Q, Z, G = !1) {
  try {
    if (A.length === 0) throw new Error($I1);
    let Y = jX(A),
      I = EXB(A),
      W = {};
    try {
      W = NXB(I);
    } catch (d) {
      (d0("Failed to get context analysis metrics"), U1(d, UZA));
    }
    let J = await B.getAppState();
    (Pb1(J.toolPermissionContext, "summary"),
      B.setSpinnerColor?.("claudeBlue_FOR_SYSTEM_SPINNER"),
      B.setSpinnerShimmerColor?.("claudeBlueShimmer_FOR_SYSTEM_SPINNER"),
      B.setSpinnerMessage?.("Running PreCompact hooks..."));
    let X = await GMA(
      { trigger: G ? "auto" : "manual", customInstructions: Z ?? null, sessionId: B.agentId },
      B.abortController.signal,
    );
    if (X.newCustomInstructions)
      Z = Z
        ? `${Z}

${X.newCustomInstructions}`
        : X.newCustomInstructions;
    let F = X.userDisplayMessage;
    (B.setStreamMode?.("requesting"), B.setResponseLength?.(() => 0), B.setSpinnerMessage?.("Compacting conversation"));
    let V = Tb1(Z),
      K = bA({ content: V }),
      z = b01(
        dG([...A, K]),
        ["You are a helpful AI assistant tasked with summarizing conversations."],
        0,
        [Q6],
        B.abortController.signal,
        {
          async getToolPermissionContext() {
            return (await B.getAppState()).toolPermissionContext;
          },
          model: uG(),
          prependCLISysprompt: !0,
          toolChoice: void 0,
          isNonInteractiveSession: B.options.isNonInteractiveSession,
          maxOutputTokensOverride: xb1,
          promptCategory: "compact",
        },
      )[Symbol.asyncIterator](),
      D = await z.next(),
      C = !1,
      w;
    while (!D.done) {
      let d = D.value;
      if (
        !C &&
        d.type === "stream_event" &&
        d.event.type === "content_block_start" &&
        d.event.content_block.type === "text"
      )
        ((C = !0), B.setStreamMode?.("responding"));
      if (d.type === "stream_event" && d.event.type === "content_block_delta" && d.event.delta.type === "text_delta") {
        let u = d.event.delta.text.length;
        B.setResponseLength?.((o) => o + u);
      }
      if (d.type === "assistant") w = d;
      D = await z.next();
    }
    if (!w) throw new Error("Failed to get summary response from streaming");
    let E = $b(w);
    if (!E)
      throw (
        Y1("tengu_compact_failed", { reason: "no_summary", preCompactTokenCount: Y }),
        new Error("Failed to generate conversation summary - response did not contain valid text content")
      );
    else if (E.startsWith(API_ERROR))
      throw (Y1("tengu_compact_failed", { reason: "api_error", preCompactTokenCount: Y }), new Error(E));
    else if (E.startsWith(GI1))
      throw (Y1("tengu_compact_failed", { reason: "prompt_too_long", preCompactTokenCount: Y }), new Error(sB5));
    let L = v9B(B.readFileState);
    B.readFileState.clear();
    let O = await oB5(L, B, iB5),
      R = tB5(B.agentId);
    if (R) O.push(R);
    B.setSpinnerMessage?.("Running SessionStart hooks...");
    let P = await S$("compact"),
      _ = jX([w]);
    Y1("tengu_compact", { preCompactTokenCount: Y, postCompactTokenCount: _, ...W });
    let b = gJB(G ? "auto" : "manual", Y ?? 0),
      S = [bA({ content: IXB(E, Q), isCompactSummary: !0, isVisibleInTranscriptOnly: !0 })];
    return {
      boundaryMarker: b,
      summaryMessages: S,
      attachments: O,
      hookResults: P,
      userDisplayMessage: F,
      preCompactTokenCount: Y,
      postCompactTokenCount: _,
    };
  } catch (Y) {
    throw (rB5(Y, B), Y);
  } finally {
    (B.setStreamMode?.("requesting"),
      B.setResponseLength?.(() => 0),
      B.setSpinnerMessage?.(null),
      B.setSpinnerColor?.(null),
      B.setSpinnerShimmerColor?.(null));
  }
}
function rB5(A, B) {
  if (B41(A, wI1) || B41(A, $I1)) B.addNotification?.({ text: "" }, { timeoutMs: 0 });
  else B.addNotification?.({ text: "Error compacting conversation", color: "error" }, { timeoutMs: 2000 });
}
async function oB5(A, B, Q) {
  let Z = Object.entries(A)
      .map(([I, W]) => ({ filename: I, ...W }))
      .filter((I) => !eB5(I.filename, B.agentId))
      .sort((I, W) => W.timestamp - I.timestamp)
      .slice(0, Q),
    G = await Promise.all(
      Z.map(async (I) => {
        let W = await RE0(
          I.filename,
          { ...B, fileReadingLimits: { maxTokens: aB5 } },
          "tengu_post_compact_file_restore_success",
          "tengu_post_compact_file_restore_error",
          "compact",
        );
        return W ? i01(W) : null;
      }),
    ),
    Y = 0;
  return G.filter((I) => {
    if (I === null) return !1;
    let W = w3(JSON.stringify(I));
    if (Y + W <= nB5) return ((Y += W), !0);
    return !1;
  });
}
function tB5(A) {
  let B = AS(A);
  if (B.length === 0) return null;
  return i01({ type: "todo", content: B, itemCount: B.length, context: "post-compact" });
}
function eB5(A, B) {
  let Q = Nd(A);
  try {
    let Z = Nd(qb(B));
    if (Q === Z) return !0;
  } catch {}
  try {
    if (new Set($XB.map((G) => Nd(td(G)))).has(Q)) return !0;
  } catch {}
  return !1;
}
function LXB() {
  let A = uG(),
    B = eq0(A);
  return Nb(A) - B;
}
var AQ5 = 13000,
  BQ5 = 20000,
  QQ5 = 20000;
function ZS(A) {
  let B = LXB() - AQ5,
    Q = Qc() ? B : LXB(),
    Z = Math.max(0, Math.round(((Q - A) / Q) * 100)),
    G = Q - BQ5,
    Y = Q - QQ5,
    I = A >= G,
    W = A >= Y,
    J = Qc() && A >= B;
  return { percentLeft: Z, isAboveWarningThreshold: I, isAboveErrorThreshold: W, isAboveAutoCompactThreshold: J };
}
function Qc() {
  return H0().autoCompactEnabled;
}
async function ZQ5(A, B) {
  if (B === "session_memory") return !1;
  if (!Qc()) return !1;
  let Q = jX(A),
    { isAboveAutoCompactThreshold: Z } = ZS(Q);
  return Z;
}
async function MXB(A, B, Q) {
  if (!(await ZQ5(A, Q))) return { wasCompacted: !1 };
  try {
    return { wasCompacted: !0, compactionResult: await vb1(A, B, !0, void 0, !0) };
  } catch (G) {
    if (!B41(G, wI1)) U1(G instanceof Error ? G : new Error(String(G)), h3A);
    return { wasCompacted: !1 };
  }
}
var hb1 = A1(V1(), 1);
var GQ5 = 20000,
  YQ5 = 40000,
  IQ5 = 3,
  WQ5 = 2000,
  JQ5 = new Set([READ_TOOL_NAME, BASH_TOOL_NAME, GREP_TOOL_NAME, GLOB_TOOL_NAME, WEB_SEARCH_TOOL_NAME, WEB_FETCH_TOOL_NAME, EDIT_TOOL_NAME, MULTI_EDIT_TOOL_NAME, WRITE_TOOL_NAME]),
  TE0 = new Set(),
  PE0 = new Set(),
  OXB = new Map();
var fb1 = !1,
  bb1 = [];
function XQ5(A) {
  if (!A.content) return 0;
  if (typeof A.content === "string") return w3(A.content);
  return A.content.reduce((B, Q) => {
    if (Q.type === "text") return B + w3(Q.text);
    else if (Q.type === "image") return B + WQ5;
    return B;
  }, 0);
}
function FQ5(A, B) {
  let Q = OXB.get(A);
  if (Q === void 0) ((Q = XQ5(B)), OXB.set(A, Q));
  return Q;
}
function VQ5(A) {
  return (
    bb1.push(A),
    () => {
      bb1 = bb1.filter((B) => B !== A);
    }
  );
}
function KQ5() {
  bb1.forEach((A) => A());
}
async function Lb(A, B, Q) {
  if (((fb1 = !1), EQ(process.env.DISABLE_MICROCOMPACT))) return { messages: A };
  EQ(process.env.USE_API_CONTEXT_MANAGEMENT);
  let Z = B !== void 0,
    G = Z ? B : YQ5,
    Y = [],
    I = new Map();
  for (let H of A)
    if ((H.type === "user" || H.type === "assistant") && Array.isArray(H.message.content)) {
      for (let z of H.message.content)
        if (z.type === "tool_use" && JQ5.has(z.name)) {
          if (!TE0.has(z.id)) Y.push(z.id);
        } else if (z.type === "tool_result" && Y.includes(z.tool_use_id)) {
          let D = FQ5(z.tool_use_id, z);
          I.set(z.tool_use_id, D);
        }
    }
  let W = Y.slice(-IQ5),
    J = Array.from(I.values()).reduce((H, z) => H + z, 0),
    X = 0,
    F = new Set();
  for (let H of Y) {
    if (W.includes(H)) continue;
    if (J - X > G) (F.add(H), (X += I.get(H) || 0));
  }
  if (!Z) {
    let H = jX(A);
    if (!ZS(H).isAboveWarningThreshold || X < GQ5) (F.clear(), (X = 0));
  }
  let V = (H) => {
    return TE0.has(H) || F.has(H);
  };
  if ((F.size > 0, F.size > 0))
    A.filter((z) => z && z.type === "attachment" && z.attachment.type === "memory" && !PE0.has(z.uuid))
      .map((z) => ({ uuid: z.uuid }))
      .forEach((z) => PE0.add(z.uuid));
  let K = [];
  for (let H of A) {
    if (H.type === "attachment" && PE0.has(H.uuid)) continue;
    if (H.type !== "user" && H.type !== "assistant") {
      K.push(H);
      continue;
    }
    if (!Array.isArray(H.message.content)) {
      K.push(H);
      continue;
    }
    if (H.type === "user") {
      let z = [];
      for (let D of H.message.content)
        if (D.type === "tool_result" && V(D.tool_use_id))
          z.push({ ...D, content: "[Old tool result content cleared]" });
        else z.push(D);
      if (z.length > 0) K.push({ ...H, message: { ...H.message, content: z } });
    } else {
      let z = [];
      for (let D of H.message.content) z.push(D);
      K.push({ ...H, message: { ...H.message, content: z } });
    }
  }
  if (Q && F.size > 0) {
    let H = new Map(),
      z = new Set();
    for (let D of A)
      if ((D.type === "user" || D.type === "assistant") && Array.isArray(D.message.content)) {
        for (let C of D.message.content)
          if (C.type === "tool_use" && C.name === READ_TOOL_NAME) {
            let w = C.input?.file_path;
            if (typeof w === "string")
              if (F.has(C.id)) H.set(w, C.id);
              else z.add(w);
          }
      }
    for (let [D] of H) if (!z.has(D)) Q.readFileState.delete(D);
  }
  for (let H of F) TE0.add(H);
  if (F.size > 0)
    return (
      Y1("tengu_microcompact", {
        toolsCompacted: F.size,
        totalUncompactedTokens: J,
        tokensAfterCompaction: J - X,
        tokensSaved: X,
        triggerType: Z ? "manual" : "auto",
      }),
      (fb1 = !0),
      KQ5(),
      { messages: K }
    );
  return { messages: K };
}
function RXB() {
  let [A, B] = hb1.useState(fb1);
  return (
    hb1.useEffect(() => {
      return VQ5(() => {
        B(fb1);
      });
    }, []),
    A
  );
}
var HQ5 = {
    type: "local",
    name: "compact",
    description:
      "Clear conversation history but keep a summary in context. Optional: /compact [instructions for summarization]",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !0,
    argumentHint: "<optional custom summarization instructions>",
    async call(A, B) {
      let { abortController: Q, messages: Z } = B;
      if (Z.length === 0) throw new Error("No messages to compact");
      let G = A.trim();
      try {
        let I = (await Lb(Z, void 0, B)).messages,
          W = await vb1(I, B, !1, G);
        (eV.cache.clear?.(), RI.cache.clear?.());
        let J = [
          ...(B.options.verbose ? [] : ["(ctrl+o to see full summary)"]),
          ...(W.userDisplayMessage ? [W.userDisplayMessage] : []),
        ];
        return {
          type: "compact",
          compactionResult: W,
          displayText: n1.dim(
            "Compacted " +
              J.join(`
`),
          ),
        };
      } catch (Y) {
        if (Q.signal.aborted) throw new Error("Compaction canceled.");
        else if (Y instanceof Error && Y.message === $I1) throw new Error($I1);
        else throw (U1(Y instanceof Error ? Y : new Error(String(Y)), d7A), new Error(`Error during compaction: ${Y}`));
      }
    },
    userFacingName() {
      return "compact";
    },
  },
  TXB = HQ5;
var O2 = A1(V1(), 1),
  Gc = A1(V1(), 1);
var Q4 = A1(V1(), 1);
function gb1({
  onThemeSelect: A,
  showIntroText: B = !1,
  helpText: Q = "",
  showHelpTextBelow: Z = !1,
  hideEscToCancel: G = !1,
  skipExitHandling: Y = !1,
}) {
  let [I] = sB(),
    { setPreviewTheme: W, savePreview: J } = WA0(),
    X = Z2(Y ? () => {} : void 0),
    V = Q4.createElement(
      y,
      { flexDirection: "column", gap: 1, paddingLeft: 1 },
      B && Q4.createElement(M, null, "Let's get started."),
      Q4.createElement(
        y,
        { flexDirection: "column" },
        Q4.createElement(M, { bold: !0 }, "Choose the text style that looks best with your terminal:"),
        Q && !Z && Q4.createElement(M, { dimColor: !0 }, Q),
      ),
      Q4.createElement(xA, {
        options: [
          { label: "Dark mode", value: "dark" },
          { label: "Light mode", value: "light" },
          { label: "Dark mode (colorblind-friendly)", value: "dark-daltonized" },
          { label: "Light mode (colorblind-friendly)", value: "light-daltonized" },
          { label: "Dark mode (ANSI colors only)", value: "dark-ansi" },
          { label: "Light mode (ANSI colors only)", value: "light-ansi" },
        ],
        onFocus: (K) => {
          W(K);
        },
        onChange: (K) => {
          (J(), A(K));
        },
        onCancel: Y
          ? () => {
              J();
            }
          : async () => {
              (J(), await Z5(0));
            },
        visibleOptionCount: 6,
        defaultValue: I,
      }),
      Q4.createElement(
        y,
        { flexDirection: "column", paddingTop: 1 },
        Q4.createElement(M, { bold: !0 }, "Preview"),
        Q4.createElement(
          y,
          { paddingLeft: 1, marginRight: 1, borderStyle: "round", flexDirection: "column" },
          Q4.createElement(bH, {
            patch: {
              oldStart: 1,
              newStart: 1,
              oldLines: 3,
              newLines: 3,
              lines: [
                "function greet() {",
                '-  console.log("Hello, World!");',
                '+  console.log("Hello, Claude!");',
                "}",
              ],
            },
            dim: !1,
          }),
        ),
      ),
    );
  if (!B)
    return Q4.createElement(
      Q4.Fragment,
      null,
      Q4.createElement(y, { flexDirection: "column", borderStyle: "round", paddingX: 1, marginTop: 1 }, V),
      Z && Q && Q4.createElement(y, { marginLeft: 3, marginTop: 1 }, Q4.createElement(M, { dimColor: !0 }, Q)),
      !G &&
        Q4.createElement(
          y,
          { marginLeft: 3 },
          Q4.createElement(
            M,
            { dimColor: !0 },
            X.pending
              ? Q4.createElement(Q4.Fragment, null, "Press ", X.keyName, " again to exit")
              : Q4.createElement(Q4.Fragment, null, "Esc to cancel"),
          ),
        ),
    );
  return V;
}
var yX = A1(V1(), 1);
var GS = () => ({
  mode: "default",
  additionalWorkingDirectories: new Map(),
  alwaysAllowRules: {},
  alwaysDenyRules: {},
  alwaysAskRules: {},
  isBypassPermissionsModeAvailable: !1,
});
function n01(A) {
  return A.filter((B) => B.data?.type !== "running_hook");
}
var ub1 = A1(V1(), 1);
function mb1(A) {
  let B = ub1.useCallback(
    (Q) => {
      F61();
      let Z = E2();
      A(Q, Z);
    },
    [A],
  );
  ub1.useEffect(() => ga.subscribe(B), [B]);
}
function a01() {
  return {
    backgroundTasks: {},
    verbose: !1,
    mainLoopModel: null,
    maxRateLimitFallbackActive: !1,
    statusLineText: void 0,
    todoFeatureEnabled: !1,
    showExpandedTodos: !1,
    toolPermissionContext: GS(),
    checkpointing: {
      status: "uninitialized",
      checkpoints: {},
      shadowRepoPath: void 0,
      saveError: void 0,
      saving: !1,
      autocheckpointEnabled: !1,
    },
    fileHistory: { snapshots: [], trackedFiles: new Set() },
    mcp: { clients: [], tools: [], commands: [], resources: {} },
    plugins: { enabled: [], disabled: [], commands: [], agents: [] },
    todos: {},
  };
}
var jXB = yX.default.createContext([{}, (A) => A]),
  PXB = yX.default.createContext(!1);
function M7({ children: A, initialState: B, onChangeAppState: Q }) {
  if (yX.useContext(PXB)) throw new Error("AppStateProvider can not be nested within another AppStateProvider");
  let [G, Y] = yX.useState({ currentState: B ?? a01(), previousState: null }),
    I = yX.useCallback((J) => Y(({ currentState: X }) => ({ currentState: J(X), previousState: X })), []),
    W = yX.useMemo(() => {
      let J = [G.currentState, I];
      return ((J.__IS_INITIALIZED__ = !0), J);
    }, [G.currentState, I]);
  return (
    yX.useEffect(() => {
      Q?.({ newState: G.currentState, oldState: G.previousState });
    }, [Q, G]),
    mb1(
      yX.useCallback(() => {
        let J = ZU1();
        I((X) => {
          return { ...X, toolPermissionContext: R$A(X.toolPermissionContext, J) };
        });
      }, [I]),
    ),
    yX.default.createElement(PXB.Provider, { value: !0 }, yX.default.createElement(jXB.Provider, { value: W }, A))
  );
}
function dB() {
  let A = yX.useContext(jXB);
  if (!A.__IS_INITIALIZED__)
    throw new ReferenceError("useAppState cannot be called outside of an <AppStateProvider />");
  return A;
}
var Z6 = A1(V1(), 1),
  SXB = A1(V1(), 1);
var NO_PREFERENCE = "__NO_PREFERENCE__";
function db1({ initial: A, onSelect: B }) {
  let Q = A === null ? NO_PREFERENCE : A,
    [Z, G] = SXB.useState(Q),
    Y = SR1(),
    I = Z2(),
    W = b2() && PZ() === "pro",
    J = 10,
    X = Math.min(10, Y.length),
    F = Math.max(0, Y.length - X);
  return Z6.createElement(
    y,
    { flexDirection: "column" },
    Z6.createElement(
      y,
      {
        flexDirection: "column",
        borderStyle: "round",
        borderColor: "remember",
        paddingX: 2,
        paddingY: 1,
        width: "100%",
      },
      Z6.createElement(
        y,
        { marginBottom: 1, flexDirection: "column" },
        Z6.createElement(M, { color: "remember", bold: !0 }, "Select Model"),
        Z6.createElement(
          M,
          { dimColor: !0 },
          "Switch between Claude models. Applies to this session and future Claude Code sessions. For custom model names, specify with --model.",
        ),
      ),
      Z6.createElement(
        y,
        { flexDirection: "column", paddingX: 1 },
        Z6.createElement(xA, {
          defaultValue: Z,
          focusValue: Y.some((V) => V.value === Z) ? Z : (Y[0]?.value ?? void 0),
          options: Y.map((V) => ({ ...V, value: V.value === null ? NO_PREFERENCE : V.value })),
          onFocus: (V) => G(V),
          onChange: (V) => B(V === NO_PREFERENCE ? null : V),
          onCancel: () => {},
          visibleOptionCount: X,
        }),
      ),
      F > 0 && Z6.createElement(y, { paddingLeft: 3 }, Z6.createElement(M, { dimColor: !0 }, "and ", F, " more…")),
      W &&
        Z6.createElement(
          y,
          { marginTop: 1, flexDirection: "column" },
          Z6.createElement(
            M,
            { dimColor: !0 },
            "Want Opus 4.1? Run ",
            Z6.createElement(M, { color: "remember" }, "/upgrade"),
            " to upgrade to Max",
          ),
        ),
    ),
    Z6.createElement(
      y,
      { paddingX: 1 },
      Z6.createElement(
        M,
        { dimColor: !0 },
        I.pending
          ? Z6.createElement(Z6.Fragment, null, "Press ", I.keyName, " again to exit")
          : Z6.createElement(Z6.Fragment, null, "Enter to confirm · Esc to exit"),
      ),
    ),
  );
}
var lF = A1(V1(), 1);
function cb1({ onDone: A }) {
  lF.default.useEffect(() => {
    Y1("tengu_claude_md_includes_dialog_shown", {});
  }, []);
  function B(Z) {
    let G = w9();
    if (Z === "no")
      (Y1("tengu_claude_md_external_includes_dialog_declined", {}),
        i8({ ...G, hasClaudeMdExternalIncludesApproved: !1, hasClaudeMdExternalIncludesWarningShown: !0 }));
    else
      (Y1("tengu_claude_md_external_includes_dialog_accepted", {}),
        i8({ ...G, hasClaudeMdExternalIncludesApproved: !0, hasClaudeMdExternalIncludesWarningShown: !0 }));
    A();
  }
  let Q = Z2();
  return (
    s0((Z, G) => {
      if (G.escape) {
        B("no");
        return;
      }
    }),
    lF.default.createElement(
      lF.default.Fragment,
      null,
      lF.default.createElement(
        y,
        { flexDirection: "column", gap: 1, padding: 1, borderStyle: "round", borderColor: "warning" },
        lF.default.createElement(M, { bold: !0, color: "warning" }, "Allow external CLAUDE.md file imports?"),
        lF.default.createElement(
          M,
          null,
          "This project's CLAUDE.md imports files outside the current working directory. Never allow this for third-party repositories.",
        ),
        lF.default.createElement(
          M,
          { dimColor: !0 },
          "Important: Only use Claude Code with files you trust. Accessing untrusted files may pose security risks",
          " ",
          lF.default.createElement(H5, { url: "https://docs.anthropic.com/s/claude-code-security" }),
          " ",
        ),
        lF.default.createElement(xA, {
          options: [
            { label: "Yes, allow external imports", value: "yes" },
            { label: "No, disable external imports", value: "no" },
          ],
          onChange: (Z) => B(Z),
          onCancel: () => B("no"),
        }),
      ),
      lF.default.createElement(
        y,
        { marginLeft: 3 },
        lF.default.createElement(
          M,
          { dimColor: !0 },
          Q.pending
            ? lF.default.createElement(lF.default.Fragment, null, "Press ", Q.keyName, " again to exit")
            : lF.default.createElement(
                lF.default.Fragment,
                null,
                "Enter to confirm · Esc to disable external includes",
              ),
        ),
      ),
    )
  );
}
var yD = A1(V1(), 1);
var Zc = A1(V1(), 1);
var SD = A1(V1(), 1);
function Mb({ title: A, subtitle: B, children: Q, onCancel: Z, borderColor: G, borderDimColor: Y }) {
  let I = Z2();
  return (
    s0((W, J) => {
      if (J.escape) {
        Z();
        return;
      }
    }),
    SD.default.createElement(
      SD.default.Fragment,
      null,
      SD.default.createElement(
        y,
        {
          flexDirection: "column",
          paddingX: 1,
          paddingBottom: 1,
          borderStyle: "round",
          borderColor: G,
          borderDimColor: Y,
          gap: 1,
        },
        SD.default.createElement(
          y,
          { flexDirection: "column" },
          SD.default.createElement(M, { bold: !0 }, A),
          B && SD.default.createElement(M, { dimColor: !0 }, B),
        ),
        Q,
      ),
      SD.default.createElement(
        y,
        { marginLeft: 3 },
        SD.default.createElement(
          M,
          { dimColor: !0 },
          I.pending
            ? SD.default.createElement(SD.default.Fragment, null, "Press ", I.keyName, " again to exit")
            : SD.default.createElement(SD.default.Fragment, null, "Enter to confirm · Esc to exit"),
        ),
      ),
    )
  );
}
var DEFAULT_VALUE = "Default",
  DQ5 = "Claude completes coding tasks efficiently and provides concise responses";
function yXB(A) {
  return Object.entries(A).map(([B, Q]) => ({ label: Q?.name ?? DEFAULT_VALUE, value: B, description: Q?.description ?? DQ5 }));
}
function lb1({ initialStyle: A, onComplete: B, onCancel: Q }) {
  let [Z, G] = Zc.useState([]),
    [Y, I] = Zc.useState(!0);
  Zc.useEffect(() => {
    $u()
      .then((J) => {
        let X = yXB(J);
        (G(X), I(!1));
      })
      .catch(() => {
        let J = yXB(Uu);
        (G(J), I(!1));
      });
  }, []);
  let W = Zc.useCallback(
    (J) => {
      B(J);
    },
    [B],
  );
  return yD.createElement(
    Mb,
    { title: "Choose your preferred output style:", onCancel: Q, borderDimColor: !0 },
    yD.createElement(
      y,
      { flexDirection: "column", gap: 1 },
      yD.createElement(M, { dimColor: !0 }, "This changes how Claude Code communicates with you"),
      yD.createElement(M, { dimColor: !0 }, "Use /output-style:new to create custom output styles"),
      Y
        ? yD.createElement(M, { dimColor: !0 }, "Loading output styles…")
        : yD.createElement(xA, { options: Z, onChange: W, onCancel: Q, visibleOptionCount: 10, defaultValue: A }),
    ),
  );
}
function kXB({ onClose: A, isConnectedToIde: B, isAutocheckpointingAvailable: Q }) {
  let [Z, G] = sB(),
    [Y, I] = Gc.useState(H0()),
    W = O2.useRef(H0()),
    [J, X] = Gc.useState(E2()),
    [F, V] = Gc.useState(J?.outputStyle || iW),
    K = O2.useRef(F),
    [H, z] = Gc.useState(0),
    D = Z2(),
    [{ mainLoopModel: C, todoFeatureEnabled: w, verbose: E }, L] = dB(),
    [O, R] = Gc.useState({}),
    [P, _] = Gc.useState(null),
    b = UE0();
  async function S(m) {
    (Y1("tengu_config_model_changed", { from_model: C, to_model: m }),
      L((r) => ({ ...r, mainLoopModel: m })),
      R((r) => {
        let Q1 = Lm(m);
        if ("model" in r) {
          let { model: J1, ...R1 } = r;
          return { ...R1, model: Q1 };
        }
        return { ...r, model: Q1 };
      }));
  }
  function d(m) {
    (L((j) => ({ ...j, verbose: m })),
      R((j) => {
        if ("verbose" in j) {
          let { verbose: r, ...Q1 } = j;
          return Q1;
        }
        return { ...j, verbose: m };
      }));
  }
  function u(m) {
    (L((j) => ({ ...j, todoFeatureEnabled: m })),
      R((j) => {
        if ("Todo List Enabled" in j) {
          let { "Todo List Enabled": r, ...Q1 } = j;
          return Q1;
        }
        return { ...j, "Todo List Enabled": m };
      }));
  }
  let o = [
    {
      id: "autoCompactEnabled",
      label: "Auto-compact",
      value: Y.autoCompactEnabled,
      type: "boolean",
      onChange(m) {
        let j = { ...H0(), autoCompactEnabled: m };
        (TA(j), I(j), Y1("tengu_auto_compact_setting_changed", { enabled: m }));
      },
    },
    { id: "todoFeatureEnabled", label: "Use todo list", value: w, type: "boolean", onChange: u },
    {
      id: "spinnerTipsEnabled",
      label: "Show tips",
      value: J?.spinnerTipsEnabled ?? !0,
      type: "boolean",
      onChange(m) {
        (W4("localSettings", { spinnerTipsEnabled: m }),
          X((j) => ({ ...j, spinnerTipsEnabled: m })),
          Y1("tengu_tips_setting_changed", { enabled: m }));
      },
    },
    ...(Q
      ? [
          {
            id: "autocheckpointingEnabled",
            label: "Auto-checkpointing",
            value: Y.autocheckpointingEnabled,
            type: "boolean",
            onChange(m) {
              let j = { ...H0(), autocheckpointingEnabled: m };
              (TA(j),
                I(j),
                Y1("tengu_autocheckpointing_setting_changed", { enabled: m }),
                L((r) => ({
                  ...r,
                  checkpointing: {
                    ...r.checkpointing,
                    autocheckpointEnabled: Q && m && !EQ(process.env.CLAUDE_CODE_DISABLE_AUTOCHECKPOINTING),
                  },
                })));
            },
          },
        ]
      : []),
    { id: "verbose", label: "Verbose output", value: E, type: "boolean", onChange: d },
    { id: "theme", label: "Theme", value: Z, type: "managedEnum", onChange: G },
    {
      id: "notifChannel",
      label: "Notifications",
      value: Y.preferredNotifChannel,
      options: ["auto", "iterm2", "terminal_bell", "iterm2_with_bell", "kitty", "ghostty", "notifications_disabled"],
      type: "enum",
      onChange(m) {
        let j = { ...H0(), preferredNotifChannel: m };
        (TA(j), I(j));
      },
    },
    { id: "outputStyle", label: "Output style", value: F, type: "managedEnum", onChange: () => {} },
    {
      id: "editorMode",
      label: "Editor mode",
      value: Y.editorMode === "emacs" ? "normal" : Y.editorMode || "normal",
      options: ["normal", "vim"],
      type: "enum",
      onChange(m) {
        let j = { ...H0(), editorMode: m };
        (TA(j), I(j), Y1("tengu_editor_mode_changed", { mode: m, source: "config_panel" }));
      },
    },
    { id: "model", label: "Model", value: C === null ? "Default (recommended)" : C, type: "managedEnum", onChange: S },
    ...(B
      ? [
          {
            id: "diffTool",
            label: "Diff tool",
            value: Y.diffTool ?? "auto",
            options: ["terminal", "auto"],
            type: "enum",
            onChange(m) {
              let j = { ...H0(), diffTool: m };
              (TA(j), I(j), Y1("tengu_diff_tool_changed", { tool: m, source: "config_panel" }));
            },
          },
        ]
      : []),
    ...(!FW()
      ? [
          {
            id: "autoConnectIde",
            label: "Auto-connect to IDE (external terminal)",
            value: Y.autoConnectIde ?? !1,
            type: "boolean",
            onChange(m) {
              let j = { ...H0(), autoConnectIde: m };
              (TA(j), I(j), Y1("tengu_auto_connect_ide_changed", { enabled: m, source: "config_panel" }));
            },
          },
        ]
      : []),
    ...(FW()
      ? [
          {
            id: "autoInstallIdeExtension",
            label: "Auto-install IDE extension",
            value: Y.autoInstallIdeExtension ?? !0,
            type: "boolean",
            onChange(m) {
              let j = { ...H0(), autoInstallIdeExtension: m };
              (TA(j), I(j), Y1("tengu_auto_install_ide_extension_changed", { enabled: m, source: "config_panel" }));
            },
          },
        ]
      : []),
    ...(b
      ? [
          {
            id: "showExternalIncludesDialog",
            label: "External CLAUDE.md includes",
            value: (() => {
              if (w9().hasClaudeMdExternalIncludesApproved) return "true";
              else return "false";
            })(),
            type: "managedEnum",
            onChange() {},
          },
        ]
      : []),
    ...(process.env.ANTHROPIC_API_KEY
      ? [
          {
            id: "apiKey",
            label: `Use custom API key: ${n1.bold(ND(process.env.ANTHROPIC_API_KEY))}`,
            value: Boolean(
              process.env.ANTHROPIC_API_KEY &&
              Y.customApiKeyResponses?.approved?.includes(ND(process.env.ANTHROPIC_API_KEY)),
            ),
            type: "boolean",
            onChange(m) {
              let j = { ...H0() };
              if (!j.customApiKeyResponses) j.customApiKeyResponses = { approved: [], rejected: [] };
              if (!j.customApiKeyResponses.approved) j.customApiKeyResponses.approved = [];
              if (!j.customApiKeyResponses.rejected) j.customApiKeyResponses.rejected = [];
              if (process.env.ANTHROPIC_API_KEY) {
                let r = ND(process.env.ANTHROPIC_API_KEY);
                if (m)
                  ((j.customApiKeyResponses.approved = [
                    ...j.customApiKeyResponses.approved.filter((Q1) => Q1 !== r),
                    r,
                  ]),
                    (j.customApiKeyResponses.rejected = j.customApiKeyResponses.rejected.filter((Q1) => Q1 !== r)));
                else
                  ((j.customApiKeyResponses.approved = j.customApiKeyResponses.approved.filter((Q1) => Q1 !== r)),
                    (j.customApiKeyResponses.rejected = [
                      ...j.customApiKeyResponses.rejected.filter((Q1) => Q1 !== r),
                      r,
                    ]));
              }
              (TA(j), I(j));
            },
          },
        ]
      : []),
  ];
  return (
    s0((m, j) => {
      if (j.escape) {
        if (P !== null) {
          _(null);
          return;
        }
        let Q1 = Object.entries(O).map(([s1, Z0]) => {
            return (Y1("tengu_config_changed", { key: s1, value: Z0 }), `Set ${s1} to ${n1.bold(Z0)}`);
          }),
          J1 = Boolean(
            process.env.ANTHROPIC_API_KEY &&
            W.current.customApiKeyResponses?.approved?.includes(ND(process.env.ANTHROPIC_API_KEY)),
          ),
          R1 = Boolean(
            process.env.ANTHROPIC_API_KEY &&
            Y.customApiKeyResponses?.approved?.includes(ND(process.env.ANTHROPIC_API_KEY)),
          );
        if (J1 !== R1)
          (Q1.push(`${R1 ? "Enabled" : "Disabled"} custom API key`),
            Y1("tengu_config_changed", { key: "env.ANTHROPIC_API_KEY", value: R1 }));
        if (Y.theme !== W.current.theme) Q1.push(`Set theme to ${n1.bold(Y.theme)}`);
        if (Y.preferredNotifChannel !== W.current.preferredNotifChannel)
          Q1.push(`Set notifications to ${n1.bold(Y.preferredNotifChannel)}`);
        if (F !== K.current) Q1.push(`Set output style to ${n1.bold(F)}`);
        if (Y.editorMode !== W.current.editorMode) Q1.push(`Set editor mode to ${n1.bold(Y.editorMode || "emacs")}`);
        if (Y.diffTool !== W.current.diffTool) Q1.push(`Set diff tool to ${n1.bold(Y.diffTool)}`);
        if (Y.autoConnectIde !== W.current.autoConnectIde)
          Q1.push(`${Y.autoConnectIde ? "Enabled" : "Disabled"} auto-connect to IDE`);
        if (Y.autoInstallIdeExtension !== W.current.autoInstallIdeExtension)
          Q1.push(`${Y.autoInstallIdeExtension ? "Enabled" : "Disabled"} auto-install IDE extension`);
        if (Y.autoCompactEnabled !== W.current.autoCompactEnabled)
          Q1.push(`${Y.autoCompactEnabled ? "Enabled" : "Disabled"} auto-compact`);
        if (Q1.length > 0)
          A(
            Q1.join(`
`),
          );
        else A();
        return;
      }
      if (P !== null) return;
      function r() {
        let Q1 = o[H];
        if (!Q1 || !Q1.onChange) return;
        if (Q1.type === "boolean") {
          Q1.onChange(!Q1.value);
          return;
        }
        if (Q1.id === "theme" && j.return) {
          _("theme");
          return;
        }
        if (Q1.id === "model" && j.return) {
          _("model");
          return;
        }
        if (Q1.id === "showExternalIncludesDialog" && j.return) {
          _("externalIncludes");
          return;
        }
        if (Q1.id === "outputStyle" && j.return) {
          _("outputStyle");
          return;
        }
        if (Q1.type === "enum") {
          let R1 = (Q1.options.indexOf(Q1.value) + 1) % Q1.options.length;
          Q1.onChange(Q1.options[R1]);
          return;
        }
      }
      if (j.tab || j.return || m === " ") {
        r();
        return;
      }
      if (j.upArrow) z((Q1) => Math.max(0, Q1 - 1));
      if (j.downArrow) z((Q1) => Math.min(o.length - 1, Q1 + 1));
    }),
    O2.createElement(
      O2.Fragment,
      null,
      P === "theme"
        ? O2.createElement(gb1, {
            initialTheme: Z,
            onThemeSelect: (m) => {
              (G(m), _(null));
            },
            skipExitHandling: !0,
          })
        : P === "model"
          ? O2.createElement(db1, {
              initial: C,
              onSelect: (m) => {
                (S(m), _(null));
              },
            })
          : P === "externalIncludes"
            ? O2.createElement(cb1, {
                onDone: () => {
                  _(null);
                },
              })
            : P === "outputStyle"
              ? O2.createElement(lb1, {
                  initialStyle: F,
                  onComplete: (m) => {
                    (V(m ?? iW),
                      _(null),
                      W4("localSettings", { outputStyle: m }),
                      Y1("tengu_output_style_changed", {
                        style: m ?? iW,
                        source: "config_panel",
                        settings_source: "localSettings",
                      }));
                  },
                  onCancel: () => _(null),
                })
              : O2.createElement(
                  O2.Fragment,
                  null,
                  O2.createElement(
                    y,
                    { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1, marginTop: 1 },
                    O2.createElement(
                      y,
                      { flexDirection: "column", minHeight: 2, marginBottom: 1 },
                      O2.createElement(M, { bold: !0 }, "Settings"),
                      O2.createElement(M, { dimColor: !0 }, "Configure Claude Code preferences"),
                    ),
                    o.map((m, j) => {
                      let r = j === H;
                      return O2.createElement(
                        y,
                        { key: m.id, height: 2, minHeight: 2 },
                        O2.createElement(
                          y,
                          { width: 44 },
                          O2.createElement(M, { color: r ? "suggestion" : void 0 }, r ? t0.pointer : " ", " ", m.label),
                        ),
                        O2.createElement(
                          y,
                          null,
                          m.type === "boolean"
                            ? O2.createElement(M, { color: r ? "suggestion" : void 0 }, m.value.toString())
                            : m.id === "theme"
                              ? O2.createElement(
                                  M,
                                  { color: r ? "suggestion" : void 0 },
                                  (() => {
                                    return (
                                      {
                                        dark: "Dark mode",
                                        light: "Light mode",
                                        "dark-daltonized": "Dark mode (colorblind-friendly)",
                                        "light-daltonized": "Light mode (colorblind-friendly)",
                                        "dark-ansi": "Dark mode (ANSI colors only)",
                                        "light-ansi": "Light mode (ANSI colors only)",
                                      }[m.value.toString()] || m.value.toString()
                                    );
                                  })(),
                                )
                              : m.id === "notifChannel"
                                ? O2.createElement(
                                    M,
                                    { color: r ? "suggestion" : void 0 },
                                    (() => {
                                      switch (m.value.toString()) {
                                        case "auto":
                                          return "Auto";
                                        case "iterm2":
                                          return O2.createElement(
                                            O2.Fragment,
                                            null,
                                            "iTerm2 ",
                                            O2.createElement(M, { dimColor: !0 }, "(OSC 9)"),
                                          );
                                        case "terminal_bell":
                                          return O2.createElement(
                                            O2.Fragment,
                                            null,
                                            "Terminal Bell ",
                                            O2.createElement(M, { dimColor: !0 }, "(\\a)"),
                                          );
                                        case "kitty":
                                          return O2.createElement(
                                            O2.Fragment,
                                            null,
                                            "Kitty ",
                                            O2.createElement(M, { dimColor: !0 }, "(OSC 99)"),
                                          );
                                        case "ghostty":
                                          return O2.createElement(
                                            O2.Fragment,
                                            null,
                                            "Ghostty ",
                                            O2.createElement(M, { dimColor: !0 }, "(OSC 777)"),
                                          );
                                        case "iterm2_with_bell":
                                          return "iTerm2 w/ Bell";
                                        case "notifications_disabled":
                                          return "Disabled";
                                        default:
                                          return m.value.toString();
                                      }
                                    })(),
                                  )
                                : O2.createElement(M, { color: r ? "suggestion" : void 0 }, m.value.toString()),
                        ),
                      );
                    }),
                  ),
                  O2.createElement(
                    y,
                    { marginLeft: 3 },
                    O2.createElement(
                      M,
                      { dimColor: !0 },
                      D.pending
                        ? O2.createElement(O2.Fragment, null, "Press ", D.keyName, " again to exit")
                        : O2.createElement(
                            O2.Fragment,
                            null,
                            "↑/↓ to select · Enter/Tab/Space to change · Esc to close",
                          ),
                    ),
                  ),
                ),
    )
  );
}
var SE0 = A1(V1(), 1);
var CQ5 = {
    aliases: ["theme"],
    type: "local-jsx",
    name: "config",
    description: "Open config panel",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, { options: { mcpClients: B } }) {
      let Q = Dv1(B),
        Z = (await WW("tengu_auto_checkpointing")) && !EQ(process.env.CLAUDE_CODE_DISABLE_AUTOCHECKPOINTING);
      return SE0.createElement(kXB, { onClose: A, isConnectedToIde: Q, isAutocheckpointingAvailable: Z });
    },
    userFacingName() {
      return "config";
    },
  },
  _XB = CQ5;
var xE0 = A1(V1(), 1);
var R2 = A1(V1(), 1);
function xXB({ data: A }) {
  let {
      categories: B,
      totalTokens: Q,
      rawMaxTokens: Z,
      percentage: G,
      gridRows: Y,
      model: I,
      memoryFiles: W,
      mcpTools: J,
      agents: X,
      messageBreakdown: F,
    } = A,
    { columns: V } = IB(),
    K = V < 80,
    H = B.filter((z) => z.tokens > 0 && z.name !== "Free space");
  return R2.createElement(
    y,
    { flexDirection: "column", padding: K ? 0 : 1 },
    R2.createElement(
      y,
      { flexDirection: "row", gap: 2, alignItems: "center" },
      R2.createElement(
        y,
        { flexDirection: "column", flexShrink: 0 },
        Y.map((z, D) =>
          R2.createElement(
            y,
            { key: D, flexDirection: "row", marginLeft: -1 },
            z.map((C, w) =>
              C.categoryName === "Free space"
                ? R2.createElement(M, { key: w, dimColor: !0 }, "⛶ ")
                : R2.createElement(M, { key: w, color: C.color }, C.squareFullness >= 0.7 ? "⛁ " : "⛀ "),
            ),
          ),
        ),
      ),
      R2.createElement(
        y,
        { flexDirection: "column", gap: 0, flexShrink: 0 },
        R2.createElement(M, { bold: !0 }, "Context Usage"),
        R2.createElement(
          M,
          { dimColor: !0 },
          I,
          " • ",
          Math.round(Q / 1000),
          "k/",
          Math.round(Z / 1000),
          "k tokens (",
          G,
          "%)",
        ),
        R2.createElement(M, null, " "),
        H.map((z, D) =>
          R2.createElement(
            y,
            { key: D },
            R2.createElement(M, { color: z.color }, "⛁"),
            R2.createElement(M, null, " ", z.name, ": "),
            R2.createElement(
              M,
              { dimColor: !0 },
              z.tokens < 1000 ? `${z.tokens}` : `${(z.tokens / 1000).toFixed(1)}k`,
              " ",
              "tokens (",
              ((z.tokens / Z) * 100).toFixed(1),
              "%)",
            ),
          ),
        ),
        (B.find((z) => z.name === "Free space")?.tokens ?? 0) > 0 &&
          R2.createElement(
            y,
            null,
            R2.createElement(M, { dimColor: !0 }, "⛶"),
            R2.createElement(M, null, " Free space: "),
            R2.createElement(
              M,
              { dimColor: !0 },
              ((B.find((z) => z.name === "Free space")?.tokens || 0) / 1000).toFixed(1),
              "k (",
              (((B.find((z) => z.name === "Free space")?.tokens || 0) / Z) * 100).toFixed(1),
              "%)",
            ),
          ),
      ),
    ),
    R2.createElement(
      y,
      { flexDirection: "column", marginLeft: -1 },
      J.length > 0 &&
        R2.createElement(
          y,
          { flexDirection: "column", marginTop: 1 },
          R2.createElement(
            y,
            null,
            R2.createElement(M, { bold: !0 }, "MCP tools"),
            R2.createElement(M, { dimColor: !0 }, " · /mcp"),
          ),
          J.map((z, D) =>
            R2.createElement(
              y,
              { key: D },
              R2.createElement(M, null, "└ ", z.name, " (", z.serverName, "):", " "),
              R2.createElement(
                M,
                { dimColor: !0 },
                z.tokens < 1000 ? `${z.tokens}` : `${(z.tokens / 1000).toFixed(1)}k`,
                " ",
                "tokens",
              ),
            ),
          ),
        ),
      X.length > 0 &&
        R2.createElement(
          y,
          { flexDirection: "column", marginTop: 1 },
          R2.createElement(
            y,
            null,
            R2.createElement(M, { bold: !0 }, "Custom agents"),
            R2.createElement(M, { dimColor: !0 }, " · /agents"),
          ),
          X.map((z, D) => {
            let C =
              z.source === "projectSettings"
                ? "Project"
                : z.source === "userSettings"
                  ? "User"
                  : z.source === "localSettings"
                    ? "Local"
                    : z.source === "flagSettings"
                      ? "Flag"
                      : z.source === "policySettings"
                        ? "Policy"
                        : z.source === "plugin"
                          ? "Plugin"
                          : z.source === "built-in"
                            ? "Built-in"
                            : String(z.source);
            return R2.createElement(
              y,
              { key: D },
              R2.createElement(M, null, "└ ", z.agentType, " (", C, "):", " "),
              R2.createElement(
                M,
                { dimColor: !0 },
                z.tokens < 1000 ? `${z.tokens}` : `${(z.tokens / 1000).toFixed(1)}k`,
                " ",
                "tokens",
              ),
            );
          }),
        ),
      W.length > 0 &&
        R2.createElement(
          y,
          { flexDirection: "column", marginTop: 1 },
          R2.createElement(
            y,
            null,
            R2.createElement(M, { bold: !0 }, "Memory files"),
            R2.createElement(M, { dimColor: !0 }, " · /memory"),
          ),
          W.map((z, D) =>
            R2.createElement(
              y,
              { key: D },
              R2.createElement(M, null, "└ ", z.type, " (", z.path, "):", " "),
              R2.createElement(
                M,
                { dimColor: !0 },
                z.tokens < 1000 ? `${z.tokens}` : `${(z.tokens / 1000).toFixed(1)}k`,
                " ",
                "tokens",
              ),
            ),
          ),
        ),
      F && !1,
    ),
  );
}
var SLASH_COMMAND_TOOL_NAME = "SlashCommand";
var vXB =
  "IMPORTANT: Assist with defensive security tasks only. Refuse to create, modify, or improve code that may be used maliciously. Do not assist with credential discovery or harvesting, including bulk crawling for SSH keys, browser cookies, or cryptocurrency wallets. Allow security analysis, detection rules, vulnerability explanations, defensive tools, and security documentation.";
function UQ5() {
  let A = new Date(),
    B = A.getFullYear(),
    Q = String(A.getMonth() + 1).padStart(2, "0"),
    Z = String(A.getDate()).padStart(2, "0");
  return `${B}-${Q}-${Z}`;
}
function $Q5(A) {
  if (!A) return "";
  let B = sg(A);
  if (B.length === 0) return "";
  return `
You can use the following tools without requiring user approval: ${B.map((Z) => n6(Z.ruleValue)).join(", ")}
`;
}
var DOCS_MAP_URL = "https://docs.anthropic.com/en/docs/claude-code/claude_code_docs_map.md";
async function Ob(A, B, Q, Z, G) {
  let Y = new Set(A.map((V) => V.name)),
    I = (await pb1()).map((V) => `/${V.userFacingName()}`),
    W = "",
    X = { prompt: "" }.prompt,
    F = await kPA();
  return [
    `
You are an interactive CLI tool that helps users ${F !== null ? 'according to your "Output Style" below, which describes how you should respond to user queries.' : "with software engineering tasks."} Use the instructions below and the tools available to you to assist the user.

${vXB}
IMPORTANT: You must NEVER generate or guess URLs for the user unless you are confident that the URLs are for helping the user with programming. You may use URLs provided by the user in their messages or local files.

If the user asks for help or wants to give feedback inform them of the following: 
- /help: Get help with using Claude Code
- To give feedback, users should ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.anthropic.com/s/claude-code", VERSION: "1.0.119" }.ISSUES_EXPLAINER}

When the user directly asks about Claude Code (eg. "can Claude Code do...", "does Claude Code have..."), or asks in second person (eg. "are you able...", "can you do..."), or asks how to use a specific Claude Code feature (eg. implement a hook, or write a slash command), use the ${WEB_FETCH_TOOL_NAME} tool to gather information to answer the question from Claude Code docs. The list of available docs is available at ${DOCS_MAP_URL}.

${
  F !== null
    ? ""
    : `# Tone and style
You should be concise, direct, and to the point.
You MUST answer concisely with fewer than 4 lines (not including tool use or code generation), unless user asks for detail.
IMPORTANT: You should minimize output tokens as much as possible while maintaining helpfulness, quality, and accuracy. Only address the specific task at hand, avoiding tangential information unless absolutely critical for completing the request. If you can answer in 1-3 sentences or a short paragraph, please do.
IMPORTANT: You should NOT answer with unnecessary preamble or postamble (such as explaining your code or summarizing your action), unless the user asks you to.
Do not add additional code explanation summary unless requested by the user. After working on a file, just stop, rather than providing an explanation of what you did.
Answer the user's question directly, avoiding any elaboration, explanation, introduction, conclusion, or excessive details. One word answers are best. You MUST avoid text before/after your response, such as "The answer is <answer>.", "Here is the content of the file..." or "Based on the information provided, the answer is..." or "Here is what I will do next...".

Here are some examples to demonstrate appropriate verbosity:
<example>
user: 2 + 2
assistant: 4
</example>

<example>
user: what is 2+2?
assistant: 4
</example>

<example>
user: is 11 a prime number?
assistant: Yes
</example>

<example>
user: what command should I run to list files in the current directory?
assistant: ls
</example>

<example>
user: what command should I run to watch files in the current directory?
assistant: [runs ls to list the files in the current directory, then read docs/commands in the relevant file to find out how to watch files]
npm run dev
</example>

<example>
user: How many golf balls fit inside a jetta?
assistant: 150000
</example>

<example>
user: what files are in the directory src/?
assistant: [runs ls and sees foo.c, bar.c, baz.c]
user: which file contains the implementation of foo?
assistant: src/foo.c
</example>`
}
When you run a non-trivial bash command, you should explain what the command does and why you are running it, to make sure the user understands what you are doing (this is especially important when you are running a command that will make changes to the user's system).
Remember that your output will be displayed on a command line interface. Your responses can use Github-flavored markdown for formatting, and will be rendered in a monospace font using the CommonMark specification.
Output text to communicate with the user; all text you output outside of tool use is displayed to the user. Only use tools to complete tasks. Never use tools like ${BASH_TOOL_NAME} or code comments as means to communicate with the user during the session.
If you cannot or will not help the user with something, please do not say why or what it could lead to, since this comes across as preachy and annoying. Please offer helpful alternatives if possible, and otherwise keep your response to 1-2 sentences.
Only use emojis if the user explicitly requests it. Avoid using emojis in all communication unless asked.
IMPORTANT: Keep your responses short, since they will be displayed on a command line interface.

# Proactiveness
You are allowed to be proactive, but only when the user asks you to do something. You should strive to strike a balance between:
- Doing the right thing when asked, including taking actions and follow-up actions
- Not surprising the user with actions you take without asking
For example, if the user asks you how to approach something, you should do your best to answer their question first, and not immediately jump into taking actions.

# Professional objectivity
Prioritize technical accuracy and truthfulness over validating the user's beliefs. Focus on facts and problem-solving, providing direct, objective technical info without any unnecessary superlatives, praise, or emotional validation. It is best for the user if Claude honestly applies the same rigorous standards to all ideas and disagrees when necessary, even if it may not be what the user wants to hear. Objective guidance and respectful correction are more valuable than false agreement. Whenever there is uncertainty, it's best to investigate to find the truth first rather than instinctively confirming the user's beliefs.

# Following conventions
When making changes to files, first understand the file's code conventions. Mimic code style, use existing libraries and utilities, and follow existing patterns.
- NEVER assume that a given library is available, even if it is well known. Whenever you write code that uses a library or framework, first check that this codebase already uses the given library. For example, you might look at neighboring files, or check the package.json (or cargo.toml, and so on depending on the language).
- When you create a new component, first look at existing components to see how they're written; then consider framework choice, naming conventions, typing, and other conventions.
- When you edit a piece of code, first look at the code's surrounding context (especially its imports) to understand the code's choice of frameworks and libraries. Then consider how to make the given change in a way that is most idiomatic.
- Always follow security best practices. Never introduce code that exposes or logs secrets and keys. Never commit secrets or keys to the repository.

# Code style
- IMPORTANT: DO NOT ADD ***ANY*** COMMENTS unless asked


${
  Y.has(FG.name)
    ? `# Task Management
You have access to the ${FG.name} tools to help you manage and plan tasks. Use these tools VERY frequently to ensure that you are tracking your tasks and giving the user visibility into your progress.
These tools are also EXTREMELY helpful for planning tasks, and for breaking down larger complex tasks into smaller steps. If you do not use this tool when planning, you may forget to do important tasks - and that is unacceptable.

It is critical that you mark todos as completed as soon as you are done with a task. Do not batch up multiple tasks before marking them as completed.

Examples:

<example>
user: Run the build and fix any type errors
assistant: I'm going to use the ${FG.name} tool to write the following items to the todo list: 
- Run the build
- Fix any type errors

I'm now going to run the build using ${BASH_TOOL_NAME}.

Looks like I found 10 type errors. I'm going to use the ${FG.name} tool to write 10 items to the todo list.

marking the first todo as in_progress

Let me start working on the first item...

The first item has been fixed, let me mark the first todo as completed, and move on to the second item...
..
..
</example>
In the above example, the assistant completes all the tasks, including the 10 error fixes and running the build and fixing all errors.

<example>
user: Help me write a new feature that allows users to track their usage metrics and export them to various formats

assistant: I'll help you implement a usage metrics tracking and export feature. Let me first use the ${FG.name} tool to plan this task.
Adding the following todos to the todo list:
1. Research existing metrics tracking in the codebase
2. Design the metrics collection system
3. Implement core metrics tracking functionality
4. Create export functionality for different formats

Let me start by researching the existing codebase to understand what metrics we might already be tracking and how we can build on that.

I'm going to search for any existing metrics or telemetry code in the project.

I've found some existing telemetry code. Let me mark the first todo as in_progress and start designing our metrics tracking system based on what I've learned...

[Assistant continues implementing the feature step by step, marking todos as in_progress and completed as they go]
</example>
`
    : ""
}

Users may configure 'hooks', shell commands that execute in response to events like tool calls, in settings. Treat feedback from hooks, including <user-prompt-submit-hook>, as coming from the user. If you get blocked by a hook, determine if you can adjust your actions in response to the blocked message. If not, ask the user to check their hooks configuration.

${
  F === null || F.isCodingRelated === !0
    ? `# Doing tasks
The user will primarily request you perform software engineering tasks. This includes solving bugs, adding new functionality, refactoring code, explaining code, and more. For these tasks the following steps are recommended:
- ${Y.has(FG.name) ? `Use the ${FG.name} tool to plan the task if required` : ""}
- Use the available search tools to understand the codebase and the user's query. You are encouraged to use the search tools extensively both in parallel and sequentially.
- Implement the solution using all tools available to you
- Verify the solution if possible with tests. NEVER assume specific test framework or test script. Check the README or search codebase to determine the testing approach.
- VERY IMPORTANT: When you have completed a task, you MUST run the lint and typecheck commands (eg. npm run lint, npm run typecheck, ruff, etc.) with ${BASH_TOOL_NAME} if they were provided to you to ensure your code is correct. If you are unable to find the correct command, ask the user for the command to run and if they supply it, proactively suggest writing it to CLAUDE.md so that you will know to run it next time.
NEVER commit changes unless the user explicitly asks you to. It is VERY IMPORTANT to only commit when explicitly asked, otherwise the user will feel that you are being too proactive.
`
    : ""
}
- Tool results and user messages may include <system-reminder> tags. <system-reminder> tags contain useful information and reminders. They are automatically added by the system, and bear no direct relation to the specific tool results or user messages in which they appear.


# Tool usage policy${
      Y.has(TASK_TOOL_NAME)
        ? `
- When doing file search, prefer to use the ${TASK_TOOL_NAME} tool in order to reduce context usage.
- You should proactively use the ${TASK_TOOL_NAME} tool with specialized agents when the task at hand matches the agent's description.
`
        : ""
    }${
      Y.has(WEB_FETCH_TOOL_NAME)
        ? `
- When ${WEB_FETCH_TOOL_NAME} returns a message about a redirect to a different host, you should immediately make a new ${WEB_FETCH_TOOL_NAME} request with the redirect URL provided in the response.`
        : ""
    }
- You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. When making multiple bash tool calls, you MUST send a single message with multiple tools calls to run the calls in parallel. For example, if you need to run "git status" and "git diff", send a single message with two tool calls to run the calls in parallel.
- If the user specifies that they want you to run tools "in parallel", you MUST send a single message with multiple tool use content blocks. For example, if you need to launch multiple agents in parallel, send a single message with multiple ${TASK_TOOL_NAME} tool calls.

${$Q5(G)}`,
    X,
    `
${await bXB(B, Q)}`,
    `
${vXB}
`,
    Y.has(FG.name)
      ? `
IMPORTANT: Always use the ${FG.name} tool to plan and track tasks throughout the conversation.`
      : "",
    `
# Code References

When referencing specific functions or pieces of code include the pattern \`file_path:line_number\` to allow the user to easily navigate to the source code location.

<example>
user: Where are errors from the client handled?
assistant: Clients are marked as failed in the \`connectToServer\` function in src/services/process.ts:712.
</example>
${
  F !== null
    ? `
# Output Style: ${F.name}
${F.prompt}
`
    : ""
}`,
    ...(Z && Z.length > 0 ? [qQ5(Z)] : []),
  ];
}
function qQ5(A) {
  let Q = A.filter((G) => G.type === "connected").filter((G) => G.instructions);
  if (Q.length === 0) return "";
  return `
# MCP Server Instructions

The following MCP servers have provided instructions for how to use their tools and resources:

${Q.map((G) => {
  return `## ${G.name}
${G.instructions}`;
}).join(`

`)}
`;
}
async function bXB(A, B) {
  let [Q, Z] = await Promise.all([JL(), EQ5()]),
    G = RjA(A),
    Y = G
      ? `You are powered by the model named ${G}. The exact model ID is ${A}.`
      : `You are powered by the model ${A}.`,
    I =
      B && B.length > 0
        ? `Additional working directories: ${B.join(", ")}
`
        : "",
    W =
      A.includes("claude-opus-4") || A.includes("claude-sonnet-4")
        ? `

Assistant knowledge cutoff is January 2025.`
        : "",
    J = "";
  if (Q && nd())
    try {
      let [X, F] = await Promise.all([t41(), b10()]);
      if (X)
        J += `Git remote URL: ${X}
`;
      if (F)
        J += `Git HEAD SHA: ${F}
`;
    } catch {}
  return `Here is useful information about the environment you are running in:
<env>
Working directory: ${AA()}
Is directory a git repo: ${Q ? "Yes" : "No"}
${J}${I}Platform: ${tA.platform}
OS Version: ${Z}
Today's date: ${UQ5()}
</env>
${Y}${W}
`;
}
async function EQ5() {
  try {
    let { stdout: A } = await B2("uname", ["-sr"], { preserveOutputOnError: !1 });
    return A.trim();
  } catch {
    return "unknown";
  }
}
var yE0 =
  "You are an agent for Claude Code, Anthropic's official CLI for Claude. Given the user's message, you should use the tools available to complete the task. Do what has been asked; nothing more, nothing less. When you complete the task simply respond with a detailed writeup.";
async function kE0(A, B, Q) {
  let G = `
${await bXB(B, Q)}`;
  return [
    ...A,
    `

Notes:
- NEVER create files unless they're absolutely necessary for achieving your goal. ALWAYS prefer editing an existing file to creating a new one.
- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.
- Agent threads always have their cwd reset between bash calls, as a result please only use absolute file paths.
- In your final response always share relevant file names and code snippets. Any file paths you return in your response MUST be absolute. Do NOT use relative paths.
- For clear communication with the user the assistant MUST avoid using emojis.`,
    G,
  ];
}
async function qI1(A, B, Q) {
  let Z = await pG1(A, B, Q);
  if (Z !== null) return Z;
  return await J9B(A, B, Q);
}
async function fXB(A, B) {
  let Q = await Promise.all(A.map((Z) => Ab1(Z, { getToolPermissionContext: B, tools: A })));
  return (await qI1([], Q, !1)) ?? 0;
}
async function NQ5(A, B) {
  let [Q, Z] = await Promise.all([Ob(A, B), jD()]),
    G = [...Q, ...Object.values(Z)];
  if (G.length < 1) return 0;
  return (
    await Promise.all(G.filter((I) => I.length > 0).map((I) => qI1([{ role: "user", content: I }], [], !1)))
  ).reduce((I, W) => I + (W || 0), 0);
}
async function LQ5() {
  let A = RI(),
    B = [],
    Q = 0;
  if (A.length < 1) return { memoryFileDetails: [], claudeMdTokens: 0 };
  let Z = await Promise.all(
    A.map(async (G) => {
      let Y = await qI1([{ role: "user", content: G.content }], [], !1);
      return { file: G, tokens: Y || 0 };
    }),
  );
  for (let { file: G, tokens: Y } of Z) ((Q += Y), B.push({ path: G.path, type: G.type, tokens: Y }));
  return { claudeMdTokens: Q, memoryFileDetails: B };
}
async function MQ5(A, B) {
  let Q = A.filter((Z) => !Z.isMcp);
  if (Q.length < 1) return 0;
  return await fXB(Q, B);
}
async function _E0(A, B) {
  let Q = A.filter((I) => I.isMcp),
    Z = [],
    G = await Promise.all(Q.map((I) => fXB([I], B))),
    Y = G.reduce((I, W) => I + (W || 0), 0);
  for (let [I, W] of Q.entries())
    Z.push({ name: W.name, serverName: W.name.split("__")[1] || "unknown", tokens: G[I] });
  return { mcpToolTokens: Y, mcpToolDetails: Z };
}
async function OQ5() {
  let B = (await y$()).activeAgents.filter((Y) => Y.source !== "built-in"),
    Q = [],
    Z = 0,
    G = await Promise.all(B.map((Y) => qI1([{ role: "user", content: [Y.agentType, Y.whenToUse].join(" ") }], [], !1)));
  for (let [Y, I] of B.entries()) {
    let W = G[Y] || 0;
    ((Z += W || 0), Q.push({ agentType: I.agentType, source: I.source, tokens: W || 0 }));
  }
  return { agentTokens: Z, agentDetails: Q };
}
async function RQ5(A) {
  let B = await Lb(A),
    Q = {
      totalTokens: 0,
      toolCallTokens: 0,
      toolResultTokens: 0,
      attachmentTokens: 0,
      assistantMessageTokens: 0,
      userMessageTokens: 0,
      toolCallsByType: new Map(),
      toolResultsByType: new Map(),
      attachmentsByType: new Map(),
    },
    Z = await qI1(
      dG(B.messages).map((G) => {
        if (G.type === "assistant") return { role: "assistant", content: G.message.content };
        return G.message;
      }),
      [],
      !1,
    );
  return ((Q.totalTokens = Z ?? 0), Q);
}
async function hXB(A, B, Q, Z, G) {
  let Y = Xt({ permissionMode: (await Q()).mode, mainLoopModel: B }),
    I = Nb(Y),
    [
      W,
      { claudeMdTokens: J, memoryFileDetails: X },
      F,
      { mcpToolTokens: V, mcpToolDetails: K },
      { agentTokens: H, agentDetails: z },
      D,
    ] = await Promise.all([NQ5(Z, Y), LQ5(), MQ5(Z, Q), _E0(Z, Q), OQ5(), RQ5(A)]),
    C = D.totalTokens,
    w = [];
  if (W > 0) w.push({ name: "System prompt", tokens: W, color: "promptBorder" });
  if (F > 0) w.push({ name: "System tools", tokens: F, color: "inactive" });
  if (V > 0) w.push({ name: "MCP tools", tokens: V, color: "cyan_FOR_SUBAGENTS_ONLY" });
  if (H > 0) w.push({ name: "Custom agents", tokens: H, color: "permission" });
  if (J > 0) w.push({ name: "Memory files", tokens: J, color: "claude" });
  if (C !== null && C > 0) w.push({ name: "Messages", tokens: C, color: "purple_FOR_SUBAGENTS_ONLY" });
  let E = w.reduce((j, r) => j + r.tokens, 0),
    L = Math.max(0, I - E);
  w.push({ name: "Free space", tokens: L, color: "promptBorder" });
  let O = G && G < 80,
    R = I >= 1e6 ? (O ? 5 : 20) : O ? 5 : 10,
    P = I >= 1e6 ? 10 : O ? 5 : 10,
    _ = R * P,
    b = w.map((j) => ({
      ...j,
      squares: j.name === "Free space" ? Math.round((j.tokens / I) * _) : Math.max(1, Math.round((j.tokens / I) * _)),
      percentageOfTotal: Math.round((j.tokens / I) * 100),
    })),
    S = [];
  for (let j of b) {
    let r = (j.tokens / I) * _,
      Q1 = Math.floor(r),
      J1 = r - Q1;
    for (let R1 = 0; R1 < j.squares && S.length < _; R1++) {
      let s1 = 1;
      if (R1 === Q1 && J1 > 0) s1 = J1;
      S.push({
        color: j.color,
        isFilled: !0,
        categoryName: j.name,
        tokens: j.tokens,
        percentage: j.percentageOfTotal,
        squareFullness: s1,
      });
    }
  }
  let d = w.find((j) => j.name === "Free space");
  while (S.length < _)
    S.push({
      color: "promptBorder",
      isFilled: !0,
      categoryName: "Free space",
      tokens: d?.tokens || 0,
      percentage: d ? Math.round((d.tokens / I) * 100) : 0,
      squareFullness: 1,
    });
  let u = [];
  for (let j = 0; j < P; j++) u.push(S.slice(j * R, (j + 1) * R));
  let o = Math.round((E / I) * 100),
    m;
  return {
    categories: w,
    totalTokens: E,
    maxTokens: I,
    rawMaxTokens: I,
    percentage: o,
    gridRows: u,
    model: Y,
    memoryFiles: X,
    mcpTools: K,
    agents: z,
    messageBreakdown: m,
  };
}
import { PassThrough as TQ5 } from "stream";
function Ic(A) {
  return new Promise((B) => {
    let Q = "",
      Z = new TQ5();
    Z.on("data", (Y) => {
      Q += Y.toString();
    });
    let G = s6(A, { stdout: Z, patchConsole: !1 });
    process.nextTick(() => {
      (G.unmount(), B(Q));
    });
  });
}
async function EI1(A) {
  let B = await Ic(A);
  (console.log(B), process.stdout.write("\x1B[?25l"));
}
class NI1 {
  alreadyRendered = {};
  async renderStatic(A) {
    for (let B in A) if (!this.alreadyRendered[B] && A[B]) (await EI1(A[B]), (this.alreadyRendered[B] = !0));
  }
  reset() {
    this.alreadyRendered = {};
  }
}
var PQ5 = {
    name: "context",
    description: "Visualize current context usage as a colored grid",
    isEnabled: () => {
      return h7() === "firstParty";
    },
    isHidden: !1,
    type: "local",
    supportsNonInteractive: !0,
    userFacingName() {
      return this.name;
    },
    async call(A, { messages: B, getAppState: Q, options: { mainLoopModel: Z, tools: G } }) {
      let Y = wb(B),
        { messages: I } = await Lb(Y),
        W = process.stdout.columns || 80,
        J = await hXB(I, Z, async () => (await Q()).toolPermissionContext, G, W);
      return { type: "text", value: await Ic(xE0.createElement(xXB, { data: J })) };
    },
  },
  gXB = PQ5;
var jQ5 = {
    type: "local",
    name: "cost",
    description: "Show the total cost and duration of the current session",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !0,
    async call() {
      if (b2())
        return {
          type: "text",
          value: `With your ${ZS1()} subscription, no need to monitor cost — your subscription includes Claude Code usage`,
        };
      return { type: "text", value: nU0() };
    },
    userFacingName() {
      return "cost";
    },
  },
  uXB = jQ5;
var iXB = A1(V1(), 1);
var BB = A1(V1(), 1);
var LI1 = A1(V1(), 1);
function Rb() {
  return LI1.createElement(
    M,
    { color: "permission" },
    "Press ",
    LI1.createElement(M, { bold: !0 }, "Enter"),
    " to continue…",
  );
}
var ib1 = A1(V1(), 1);
function nb1() {
  let [A, B] = ib1.useState(() => {
      let { errors: Z } = A_();
      return Z;
    }),
    Q = ib1.useCallback(() => {
      let { errors: Z } = A_();
      B(Z);
    }, []);
  return (mb1(Q), A);
}
var jY = A1(V1(), 1);
var MI1 = { branch: t0.lineUpDownRight, lastBranch: t0.lineUpRight, line: t0.lineVertical, empty: " " };
function mXB(A, B = {}) {
  let { showValues: Q = !0, hideFunctions: Z = !1, themeName: G = "dark", treeCharColors: Y = {} } = B,
    I = [],
    W = new WeakSet();
  function J(V, K) {
    if (!K) return V;
    return iB(K, G)(V);
  }
  function X(V, K, H, z = 0) {
    if (typeof V === "string") {
      I.push(K + J(V, Y.value));
      return;
    }
    if (typeof V !== "object" || V === null) {
      if (Q) {
        let C = String(V);
        I.push(K + J(C, Y.value));
      }
      return;
    }
    if (W.has(V)) {
      I.push(K + J("[Circular]", Y.value));
      return;
    }
    W.add(V);
    let D = Object.keys(V).filter((C) => {
      let w = V[C];
      if (Z && typeof w === "function") return !1;
      return !0;
    });
    D.forEach((C, w) => {
      let E = V[C],
        L = w === D.length - 1,
        O = z === 0 && w === 0 ? "" : K,
        R = L ? MI1.lastBranch : MI1.branch,
        P = J(R, Y.treeChar),
        _ = C.trim() === "" ? "" : J(C, Y.key),
        b = O + P + (_ ? " " + _ : ""),
        S = C.trim() !== "";
      if (E && typeof E === "object" && W.has(E)) {
        let d = J("[Circular]", Y.value);
        I.push(b + (S ? ": " : b ? " " : "") + d);
      } else if (E && typeof E === "object" && !Array.isArray(E)) {
        I.push(b);
        let d = L ? MI1.empty : MI1.line,
          u = J(d, Y.treeChar),
          o = O + u + " ";
        X(E, o, L, z + 1);
      } else if (Array.isArray(E)) I.push(b + (S ? ": " : b ? " " : "") + "[Array(" + E.length + ")]");
      else if (Q) {
        let d = typeof E === "function" ? "[Function]" : String(E),
          u = J(d, Y.value);
        ((b += (S ? ": " : b ? " " : "") + u), I.push(b));
      } else I.push(b);
    });
  }
  let F = Object.keys(A);
  if (F.length === 0) return J("(empty)", Y.value);
  if (F.length === 1 && F[0] !== void 0 && F[0].trim() === "" && typeof A[F[0]] === "string") {
    let V = F[0],
      K = J(MI1.lastBranch, Y.treeChar),
      H = J(A[V], Y.value);
    return K + " " + H;
  }
  return (
    X(A, "", !0),
    I.join(`
`)
  );
}
function SQ5(A) {
  let B = {};
  return (
    A.forEach((Q) => {
      if (!Q.path) {
        B[""] = Q.message;
        return;
      }
      let Z = Q.path.split("."),
        G = Q.path;
      if (Q.invalidValue !== null && Q.invalidValue !== void 0 && Z.length > 0) {
        let Y = [];
        for (let I = 0; I < Z.length; I++) {
          let W = Z[I];
          if (!W) continue;
          let J = parseInt(W, 10);
          if (!isNaN(J) && I === Z.length - 1) {
            let X;
            if (typeof Q.invalidValue === "string") X = `"${Q.invalidValue}"`;
            else if (Q.invalidValue === null) X = "null";
            else if (Q.invalidValue === void 0) X = "undefined";
            else X = String(Q.invalidValue);
            Y.push(X);
          } else Y.push(W);
        }
        G = Y.join(".");
      }
      Cl1(B, G, Q.message, Object);
    }),
    B
  );
}
function dXB({ errors: A }) {
  let [B] = sB();
  if (A.length === 0) return null;
  let Q = A.reduce((G, Y) => {
      let I = Y.file || "(file not specified)";
      if (!G[I]) G[I] = [];
      return (G[I].push(Y), G);
    }, {}),
    Z = Object.keys(Q).sort();
  return jY.createElement(
    y,
    { flexDirection: "column", marginTop: 1, marginBottom: 1 },
    jY.createElement(M, { bold: !0 }, "Invalid Settings"),
    Z.map((G) => {
      let Y = Q[G] || [];
      Y.sort((X, F) => {
        if (!X.path && F.path) return -1;
        if (X.path && !F.path) return 1;
        return (X.path || "").localeCompare(F.path || "");
      });
      let I = SQ5(Y),
        W = new Map();
      Y.forEach((X) => {
        if (X.suggestion || X.docLink) {
          let F = `${X.suggestion || ""}|${X.docLink || ""}`;
          if (!W.has(F)) W.set(F, { suggestion: X.suggestion, docLink: X.docLink });
        }
      });
      let J = mXB(I, {
        showValues: !0,
        themeName: B,
        treeCharColors: { treeChar: "inactive", key: "text", value: "inactive" },
      });
      return jY.createElement(
        y,
        { key: G, flexDirection: "column" },
        jY.createElement(M, null, G),
        jY.createElement(y, { marginLeft: 1 }, jY.createElement(M, { dimColor: !0 }, J)),
        W.size > 0 &&
          jY.createElement(
            y,
            { flexDirection: "column", marginTop: 1 },
            Array.from(W.values()).map((X, F) =>
              jY.createElement(
                y,
                { key: `suggestion-pair-${F}`, flexDirection: "column", marginBottom: 1 },
                X.suggestion && jY.createElement(M, { dimColor: !0, wrap: "wrap" }, X.suggestion),
                X.docLink && jY.createElement(M, { dimColor: !0, wrap: "wrap" }, "Learn more: ", X.docLink),
              ),
            ),
          ),
      );
    }),
  );
}
var s7 = A1(V1(), 1);
function vE0({ scope: A, parsingErrors: B, warnings: Q }) {
  let Z = B.length > 0,
    G = Q.length > 0;
  if (!Z && !G) return null;
  return s7.default.createElement(
    y,
    { flexDirection: "column", marginTop: 1 },
    s7.default.createElement(
      y,
      null,
      (Z || G) &&
        s7.default.createElement(
          M,
          { color: Z ? "error" : "warning" },
          "[",
          Z ? "Failed to parse" : "Contains warnings",
          "]",
          " ",
        ),
      s7.default.createElement(M, null, ag(A)),
    ),
    s7.default.createElement(
      y,
      null,
      s7.default.createElement(M, { dimColor: !0 }, "Location: "),
      s7.default.createElement(M, { dimColor: !0 }, bz(A)),
    ),
    s7.default.createElement(
      y,
      { marginLeft: 1, flexDirection: "column" },
      B.map((Y, I) => {
        let W = Y.mcpErrorMetadata?.serverName;
        return s7.default.createElement(
          y,
          { key: `error-${I}` },
          s7.default.createElement(
            M,
            null,
            s7.default.createElement(M, { dimColor: !0 }, "└ "),
            s7.default.createElement(M, { color: "error" }, "[Error]"),
            s7.default.createElement(
              M,
              { dimColor: !0 },
              " ",
              W && `[${W}] `,
              Y.path && Y.path !== "" ? `${Y.path}: ` : "",
              Y.message,
            ),
          ),
        );
      }),
      Q.map((Y, I) => {
        let W = Y.mcpErrorMetadata?.serverName;
        return s7.default.createElement(
          y,
          { key: `warning-${I}` },
          s7.default.createElement(
            M,
            null,
            s7.default.createElement(M, { dimColor: !0 }, "└ "),
            s7.default.createElement(M, { color: "warning" }, "[Warning]"),
            s7.default.createElement(
              M,
              { dimColor: !0 },
              " ",
              W && `[${W}] `,
              Y.path && Y.path !== "" ? `${Y.path}: ` : "",
              Y.message,
            ),
          ),
        );
      }),
    ),
  );
}
function ab1() {
  let A = QG("user"),
    B = QG("project"),
    Q = QG("local"),
    Z = {
      user: A.errors.filter((W) => W.mcpErrorMetadata && W.mcpErrorMetadata.severity === "fatal"),
      project: B.errors.filter((W) => W.mcpErrorMetadata && W.mcpErrorMetadata.severity === "fatal"),
      local: Q.errors.filter((W) => W.mcpErrorMetadata && W.mcpErrorMetadata.severity === "fatal"),
    },
    G = {
      user: A.errors.filter((W) => W.mcpErrorMetadata && W.mcpErrorMetadata.severity === "warning"),
      project: B.errors.filter((W) => W.mcpErrorMetadata && W.mcpErrorMetadata.severity === "warning"),
      local: Q.errors.filter((W) => W.mcpErrorMetadata && W.mcpErrorMetadata.severity === "warning"),
    },
    Y = Z.user.length > 0 || Z.project.length > 0 || Z.local.length > 0,
    I = G.user.length > 0 || G.project.length > 0 || G.local.length > 0;
  if (!Y && !I) return null;
  return s7.default.createElement(
    y,
    { flexDirection: "column", marginTop: 1, marginBottom: 1 },
    s7.default.createElement(M, { bold: !0 }, "MCP Config Diagnostics"),
    s7.default.createElement(
      y,
      { marginTop: 1 },
      s7.default.createElement(
        M,
        { dimColor: !0 },
        "For help configuring MCP servers, see:",
        " ",
        s7.default.createElement(
          H5,
          { url: "https://docs.anthropic.com/en/docs/claude-code/mcp" },
          "https://docs.anthropic.com/en/docs/claude-code/mcp",
        ),
      ),
    ),
    s7.default.createElement(vE0, { scope: "user", parsingErrors: Z.user, warnings: G.user }),
    s7.default.createElement(vE0, { scope: "project", parsingErrors: Z.project, warnings: G.project }),
    s7.default.createElement(vE0, { scope: "local", parsingErrors: Z.local, warnings: G.local }),
  );
}
import { join as pXB } from "path";
function cXB() {
  return v7A()
    .map((B) => ({ name: B.name, value: process.env[B.name], ...B.validate(process.env[B.name]) }))
    .filter((B) => B.status !== "valid");
}
var Wc = 15000;
function OI1(A) {
  if (!A) return 0;
  return A.activeAgents
    .filter((B) => B.source !== "built-in")
    .reduce((B, Q) => {
      let Z = `${Q.agentType}: ${Q.whenToUse}`;
      return B + w3(Z);
    }, 0);
}
var s01 = 25000;
async function yQ5() {
  let A = ed();
  if (A.length === 0) return null;
  let B = A.sort((Z, G) => G.content.length - Z.content.length).map(
    (Z) => `${Z.path}: ${Z.content.length.toLocaleString()} chars`,
  );
  return {
    type: "claudemd_files",
    severity: "warning",
    message:
      A.length === 1
        ? `Large CLAUDE.md file detected (${A[0].content.length.toLocaleString()} chars > ${ej.toLocaleString()})`
        : `${A.length} large CLAUDE.md files detected (each > ${ej.toLocaleString()} chars)`,
    details: B,
    currentValue: A.length,
    threshold: ej,
  };
}
async function kQ5(A) {
  if (!A) return null;
  let B = OI1(A);
  if (B <= Wc) return null;
  let Q = A.activeAgents
      .filter((G) => G.source !== "built-in")
      .map((G) => {
        let Y = `${G.agentType}: ${G.whenToUse}`;
        return { name: G.agentType, tokens: w3(Y) };
      })
      .sort((G, Y) => Y.tokens - G.tokens),
    Z = Q.slice(0, 5).map((G) => `${G.name}: ~${G.tokens.toLocaleString()} tokens`);
  if (Q.length > 5) Z.push(`(${Q.length - 5} more custom agents)`);
  return {
    type: "agent_descriptions",
    severity: "warning",
    message: `Large agent descriptions (~${B.toLocaleString()} tokens > ${Wc.toLocaleString()})`,
    details: Z,
    currentValue: B,
    threshold: Wc,
  };
}
async function _Q5(A, B) {
  let Q = A.filter((Z) => Z.isMcp);
  if (Q.length === 0) return null;
  try {
    let { mcpToolTokens: Z, mcpToolDetails: G } = await _E0(A, B);
    if (Z <= s01) return null;
    let Y = new Map();
    for (let J of G) {
      let F = J.name.split("__")[1] || "unknown",
        V = Y.get(F) || { count: 0, tokens: 0 };
      Y.set(F, { count: V.count + 1, tokens: V.tokens + J.tokens });
    }
    let I = Array.from(Y.entries()).sort((J, X) => X[1].tokens - J[1].tokens),
      W = I.slice(0, 5).map(([J, X]) => `${J}: ${X.count} tools (~${X.tokens.toLocaleString()} tokens)`);
    if (I.length > 5) W.push(`(${I.length - 5} more servers)`);
    return {
      type: "mcp_tools",
      severity: "warning",
      message: `Large MCP tools context (~${Z.toLocaleString()} tokens > ${s01.toLocaleString()})`,
      details: W,
      currentValue: Z,
      threshold: s01,
    };
  } catch (Z) {
    let G = Q.reduce((Y, I) => {
      let W = (I.name?.length || 0) + I.description.length;
      return Y + w3(W.toString());
    }, 0);
    if (G <= s01) return null;
    return {
      type: "mcp_tools",
      severity: "warning",
      message: `Large MCP tools context (~${G.toLocaleString()} tokens estimated > ${s01.toLocaleString()})`,
      details: [`${Q.length} MCP tools detected (token count estimated)`],
      currentValue: G,
      threshold: s01,
    };
  }
}
async function lXB(A, B, Q) {
  let [Z, G, Y] = await Promise.all([yQ5(), kQ5(B), _Q5(A, Q)]);
  return { claudeMdWarning: Z, agentWarning: G, mcpWarning: Y };
}
function sb1({ onDone: A }) {
  let [B] = dB(),
    Q = BB.useMemo(() => {
      return B?.mcp?.tools || [];
    }, [B?.mcp?.tools]),
    [Z, G] = BB.useState(null),
    [Y, I] = BB.useState(null),
    [W, J] = BB.useState(null),
    F = nb1().filter((K) => K.mcpErrorMetadata === void 0),
    V = BB.useMemo(() => cXB(), []);
  if (
    (BB.useEffect(() => {
      (p11().then(G),
        (async () => {
          let K = w1(),
            H = pXB(IQ(), "agents"),
            z = pXB(WQ(), ".claude", "agents"),
            { activeAgents: D, failedFiles: C } = await y$(),
            w = {
              activeAgents: D.map((L) => ({ agentType: L.agentType, source: L.source })),
              userAgentsDir: H,
              projectAgentsDir: z,
              userDirExists: K.existsSync(H),
              projectDirExists: K.existsSync(z),
              failedFiles: C,
            };
          I(w);
          let E = await lXB(Q, { activeAgents: D, allAgents: [], failedFiles: C }, async () => B.toolPermissionContext);
          J(E);
        })());
    }, [B.toolPermissionContext, Q]),
    s0((K, H) => {
      if (H.return || H.escape || (H.ctrl && K === "c")) A();
    }),
    !Z)
  )
    return BB.default.createElement(
      y,
      { paddingX: 1, paddingTop: 1 },
      BB.default.createElement(M, { dimColor: !0 }, "Checking installation status…"),
    );
  return BB.default.createElement(
    y,
    { flexDirection: "column", gap: 1, paddingX: 1, paddingTop: 1 },
    BB.default.createElement(
      y,
      { flexDirection: "column" },
      BB.default.createElement(M, { bold: !0 }, "Diagnostics"),
      BB.default.createElement(M, null, "└ Currently running: ", Z.installationType, " (", Z.version, ")"),
      BB.default.createElement(M, null, "└ Path: ", Z.installationPath),
      BB.default.createElement(M, null, "└ Invoked: ", Z.invokedBinary),
      BB.default.createElement(M, null, "└ Config install method: ", Z.configInstallMethod),
      BB.default.createElement(M, null, "└ Auto-updates enabled: ", Z.autoUpdates),
      Z.hasUpdatePermissions !== null &&
        BB.default.createElement(
          M,
          null,
          "└ Update permissions:",
          " ",
          Z.hasUpdatePermissions ? "Yes" : "No (requires sudo)",
        ),
      BB.default.createElement(
        M,
        null,
        "└ Search: ",
        Z.ripgrepStatus.working ? "OK" : "Not working",
        " (",
        Z.ripgrepStatus.mode === "builtin" ? (BH() ? "bundled" : "vendor") : Z.ripgrepStatus.systemPath || "system",
        ")",
      ),
      Z.recommendation &&
        BB.default.createElement(
          BB.default.Fragment,
          null,
          BB.default.createElement(M, null),
          BB.default.createElement(
            M,
            { color: "warning" },
            "Recommendation: ",
            Z.recommendation.split(`
`)[0],
          ),
          BB.default.createElement(
            M,
            { dimColor: !0 },
            Z.recommendation.split(`
`)[1],
          ),
        ),
      Z.multipleInstallations.length > 1 &&
        BB.default.createElement(
          BB.default.Fragment,
          null,
          BB.default.createElement(M, null),
          BB.default.createElement(M, { color: "warning" }, "Warning: Multiple installations found"),
          Z.multipleInstallations.map((K, H) => BB.default.createElement(M, { key: H }, "└ ", K.type, " at ", K.path)),
        ),
      Z.warnings.length > 0 &&
        BB.default.createElement(
          BB.default.Fragment,
          null,
          BB.default.createElement(M, null),
          Z.warnings.map((K, H) =>
            BB.default.createElement(
              y,
              { key: H, flexDirection: "column" },
              BB.default.createElement(M, { color: "warning" }, "Warning: ", K.issue),
              BB.default.createElement(M, null, "Fix: ", K.fix),
            ),
          ),
        ),
      F.length > 0 &&
        BB.default.createElement(
          BB.default.Fragment,
          null,
          BB.default.createElement(M, null),
          BB.default.createElement(dXB, { errors: F }),
        ),
    ),
    BB.default.createElement(ab1, null),
    !1,
    V.length > 0 &&
      BB.default.createElement(
        y,
        { flexDirection: "column" },
        BB.default.createElement(M, { bold: !0 }, "Environment Variables"),
        V.map((K, H) =>
          BB.default.createElement(
            M,
            { key: H },
            "└ ",
            K.name,
            ":",
            " ",
            BB.default.createElement(M, { color: K.status === "capped" ? "warning" : "error" }, K.message),
          ),
        ),
      ),
    Y?.failedFiles &&
      Y.failedFiles.length > 0 &&
      BB.default.createElement(
        y,
        { flexDirection: "column" },
        BB.default.createElement(M, { bold: !0, color: "error" }, "Agent Parse Errors"),
        BB.default.createElement(M, { color: "error" }, "└ Failed to parse ", Y.failedFiles.length, " agent file(s):"),
        Y.failedFiles.map((K, H) =>
          BB.default.createElement(M, { key: H, dimColor: !0 }, "  ", "└ ", K.path, ": ", K.error),
        ),
      ),
    W &&
      (W.claudeMdWarning || W.agentWarning || W.mcpWarning) &&
      BB.default.createElement(
        y,
        { flexDirection: "column" },
        BB.default.createElement(M, { bold: !0 }, "Context Usage Warnings"),
        W.claudeMdWarning &&
          BB.default.createElement(
            BB.default.Fragment,
            null,
            BB.default.createElement(
              M,
              null,
              "└",
              " ",
              BB.default.createElement(M, { color: "warning" }, t0.warning, " ", W.claudeMdWarning.message),
            ),
            BB.default.createElement(M, null, "  ", "└ Files:"),
            W.claudeMdWarning.details.map((K, H) =>
              BB.default.createElement(M, { key: H, dimColor: !0 }, "    ", "└ ", K),
            ),
          ),
        W.agentWarning &&
          BB.default.createElement(
            BB.default.Fragment,
            null,
            BB.default.createElement(
              M,
              null,
              "└",
              " ",
              BB.default.createElement(M, { color: "warning" }, t0.warning, " ", W.agentWarning.message),
            ),
            BB.default.createElement(M, null, "  ", "└ Top contributors:"),
            W.agentWarning.details.map((K, H) =>
              BB.default.createElement(M, { key: H, dimColor: !0 }, "    ", "└ ", K),
            ),
          ),
        W.mcpWarning &&
          BB.default.createElement(
            BB.default.Fragment,
            null,
            BB.default.createElement(
              M,
              null,
              "└",
              " ",
              BB.default.createElement(M, { color: "warning" }, t0.warning, " ", W.mcpWarning.message),
            ),
            BB.default.createElement(M, null, "  ", "└ MCP servers:"),
            W.mcpWarning.details.map((K, H) => BB.default.createElement(M, { key: H, dimColor: !0 }, "    ", "└ ", K)),
          ),
      ),
    BB.default.createElement(y, null, BB.default.createElement(Rb, null)),
  );
}
var xQ5 = {
    name: "doctor",
    description: "Diagnose and verify your Claude Code installation and settings",
    isEnabled: () => !process.env.DISABLE_DOCTOR_COMMAND,
    isHidden: !1,
    userFacingName() {
      return "doctor";
    },
    type: "local-jsx",
    call(A) {
      return new Promise((B) => B(iXB.default.createElement(sb1, { onDone: A })));
    },
  },
  nXB = xQ5;
var sN0 = A1(V1(), 1);
var fB = A1(V1(), 1),
  pF = A1(V1(), 1);
var rb1 = A1(V1(), 1);
async function vQ5() {
  try {
    if (process.env.CLAUDE_CODE_USE_BEDROCK || process.env.CLAUDE_CODE_USE_VERTEX) return !0;
    return (
      await $2.get("https://api.anthropic.com/api/hello", { timeout: 5000, headers: { "Cache-Control": "no-cache" } }),
      !0
    );
  } catch (A) {
    if (!(A instanceof Ku0)) return !0;
    return A.code !== "EHOSTUNREACH";
  }
}
var bQ5 = 30000;
function bE0() {
  let [A, B] = rb1.useState(null);
  return (
    rb1.useEffect(() => {
      let Q = !0;
      if (process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC) return;
      let Z = async () => {
        if (!Q) return;
        let Y = await vQ5();
        if (Q) B(Y);
      };
      Z();
      let G = setInterval(Z, bQ5);
      return () => {
        ((Q = !1), clearInterval(G));
      };
    }, []),
    { isConnected: A }
  );
}
class r01 {
  activeOperations = new Set();
  lastUserActivityTime = 0;
  lastCLIRecordedTime = Date.now();
  isCLIActive = !1;
  USER_ACTIVITY_TIMEOUT_MS = 5000;
  static instance = null;
  static getInstance() {
    if (!r01.instance) r01.instance = new r01();
    return r01.instance;
  }
  recordUserActivity() {
    if (!this.isCLIActive && this.lastUserActivityTime !== 0) {
      let B = (Date.now() - this.lastUserActivityTime) / 1000;
      if (B > 0) {
        let Q = mo1();
        if (Q) {
          let Z = this.USER_ACTIVITY_TIMEOUT_MS / 1000;
          if (B < Z) Q.add(B, { type: "user" });
        }
      }
    }
    this.lastUserActivityTime = Date.now();
  }
  startCLIActivity(A) {
    if (this.activeOperations.has(A)) this.endCLIActivity(A);
    let B = this.activeOperations.size === 0;
    if ((this.activeOperations.add(A), B)) ((this.isCLIActive = !0), (this.lastCLIRecordedTime = Date.now()));
  }
  endCLIActivity(A) {
    if ((this.activeOperations.delete(A), this.activeOperations.size === 0)) {
      let B = Date.now(),
        Q = (B - this.lastCLIRecordedTime) / 1000;
      if (Q > 0) {
        let Z = mo1();
        if (Z) Z.add(Q, { type: "cli" });
      }
      ((this.lastCLIRecordedTime = B), (this.isCLIActive = !1));
    }
  }
  async trackOperation(A, B) {
    this.startCLIActivity(A);
    try {
      return await B();
    } finally {
      this.endCLIActivity(A);
    }
  }
  getActivityStates() {
    return {
      isUserActive: (Date.now() - this.lastUserActivityTime) / 1000 < this.USER_ACTIVITY_TIMEOUT_MS / 1000,
      isCLIActive: this.isCLIActive,
      activeOperationCount: this.activeOperations.size,
    };
  }
}
var RI1 = r01.getInstance();
var VJ = A1(V1(), 1);
function o01({ todos: A, isStandalone: B = !1 }) {
  if (A.length === 0) return null;
  let Q = VJ.createElement(
    VJ.Fragment,
    null,
    A.map((Z, G) => {
      let Y = Z.status === "completed" ? t0.checkboxOn : t0.checkboxOff;
      return VJ.createElement(
        y,
        { key: G },
        VJ.createElement(M, { dimColor: Z.status === "completed" }, Y, " "),
        VJ.createElement(
          M,
          {
            bold: Z.status === "in_progress",
            dimColor: Z.status === "completed",
            strikethrough: Z.status === "completed",
          },
          Z.content,
        ),
      );
    }),
  );
  if (B)
    return VJ.createElement(
      y,
      { flexDirection: "column", marginTop: 1, marginLeft: 2 },
      VJ.createElement(M, { bold: !0, dimColor: !0 }, "Todos"),
      Q,
    );
  return VJ.createElement(y, { flexDirection: "column" }, Q);
}
var fE0 = A1(V1(), 1);
function TI1() {
  if (process.env.TERM === "xterm-ghostty") return ["·", "✢", "✳", "✶", "✻", "*"];
  return process.platform === "darwin" ? ["·", "✢", "✳", "✶", "✻", "✽"] : ["·", "✢", "*", "✶", "✻", "✽"];
}
function Jc(A, B, Q) {
  return {
    r: Math.round(A.r + (B.r - A.r) * Q),
    g: Math.round(A.g + (B.g - A.g) * Q),
    b: Math.round(A.b + (B.b - A.b) * Q),
  };
}
function hE0({ char: A, flashOpacity: B }) {
  let G = Jc({ r: 215, g: 119, b: 87 }, { r: 245, g: 149, b: 117 }, B);
  return fE0.createElement(Xq, { transform: (Y) => n1.rgb(G.r, G.g, G.b)(Y) }, A);
}
var iG = A1(V1(), 1);
function gE0({
  message: A,
  mode: B,
  isConnected: Q,
  messageColor: Z,
  glimmerIndex: G,
  flashOpacity: Y,
  shimmerColor: I,
  stalledIntensity: W = 0,
}) {
  if (!A) return null;
  if (Q === !1) return iG.createElement(M, { color: Z }, A, " ");
  if (W > 0) {
    let F = Jc({ r: 215, g: 119, b: 87 }, { r: 171, g: 43, b: 63 }, W);
    return iG.createElement(
      iG.Fragment,
      null,
      iG.createElement(Xq, { transform: (V) => n1.rgb(F.r, F.g, F.b)(V) }, A),
      iG.createElement(Xq, { transform: (V) => n1.rgb(F.r, F.g, F.b)(V) }, " "),
    );
  }
  return iG.createElement(
    iG.Fragment,
    null,
    A.split("").map((J, X) => {
      if (B === "tool-use") return iG.createElement(hE0, { key: X, char: J, flashOpacity: Y });
      else
        return iG.createElement(Z51, { key: X, char: J, index: X, glimmerIndex: G, messageColor: Z, shimmerColor: I });
    }),
    iG.createElement(M, { color: Z }, " "),
  );
}
var kD = A1(V1(), 1);
var aXB = TI1(),
  sXB = [...aXB, ...[...aXB].reverse()];
function uE0({ frame: A, messageColor: B, glimmerIndex: Q, stalledIntensity: Z = 0, isConnected: G }) {
  let Y = sXB[A % sXB.length];
  if (G === !1)
    return kD.createElement(y, { flexWrap: "wrap", height: 1, width: 2 }, kD.createElement(M, { color: B }, Y));
  if (Z > 0) {
    let J = Jc({ r: 215, g: 119, b: 87 }, { r: 171, g: 43, b: 63 }, Z);
    return kD.createElement(
      y,
      { flexWrap: "wrap", height: 1, width: 2 },
      kD.createElement(Xq, { transform: (X) => n1.rgb(J.r, J.g, J.b)(X) }, Y),
    );
  }
  return kD.createElement(
    y,
    { flexWrap: "wrap", height: 1, width: 2 },
    kD.createElement(M, { color: B, dimColor: Q === -1 }, Y),
  );
}
var rXB = A1(V1(), 1);
function mE0(A) {
  let [B, Q] = rXB.useState(0);
  return (
    pW(() => {
      if (A === "tool-use")
        Q(() => {
          let Z = Date.now() / 1000;
          return (Math.sin(Z * Math.PI) + 1) / 2;
        });
      else Q(0);
    }, 50),
    B
  );
}
var Xc = A1(V1(), 1);
function dE0(A, B = !1) {
  let [Q, Z] = Xc.useState(0),
    [G, Y] = Xc.useState(0),
    I = Xc.useRef(A);
  (Xc.useEffect(() => {
    if (A > I.current) (Z(0), Y(0), (I.current = A));
  }, [A]),
    pW(() => {
      if (A > 0 && A === I.current && !B) Z((X) => X + 100);
      else if (A === 0 || B) Z(0);
    }, 100));
  let W = Q > 3000 && !B,
    J = W ? Math.min((Q - 3000) / 2000, 1) : 0;
  return (
    pW(() => {
      Y((X) => {
        let F = J,
          V = F - X;
        if (Math.abs(V) < 0.01) return F;
        return X + V * 0.1;
      });
    }, 50),
    { isStalled: W, stalledIntensity: G }
  );
}
var oXB = TI1(),
  tXB = [...oXB, ...[...oXB].reverse()],
  fQ5 = {
    words: [
      "Accomplishing",
      "Actioning",
      "Actualizing",
      "Baking",
      "Booping",
      "Brewing",
      "Calculating",
      "Cerebrating",
      "Channelling",
      "Churning",
      "Clauding",
      "Coalescing",
      "Cogitating",
      "Computing",
      "Combobulating",
      "Concocting",
      "Considering",
      "Contemplating",
      "Cooking",
      "Crafting",
      "Creating",
      "Crunching",
      "Deciphering",
      "Deliberating",
      "Determining",
      "Discombobulating",
      "Doing",
      "Effecting",
      "Elucidating",
      "Enchanting",
      "Envisioning",
      "Finagling",
      "Flibbertigibbeting",
      "Forging",
      "Forming",
      "Frolicking",
      "Generating",
      "Germinating",
      "Hatching",
      "Herding",
      "Honking",
      "Ideating",
      "Imagining",
      "Incubating",
      "Inferring",
      "Manifesting",
      "Marinating",
      "Meandering",
      "Moseying",
      "Mulling",
      "Mustering",
      "Musing",
      "Noodling",
      "Percolating",
      "Perusing",
      "Philosophising",
      "Pontificating",
      "Pondering",
      "Processing",
      "Puttering",
      "Puzzling",
      "Reticulating",
      "Ruminating",
      "Scheming",
      "Schlepping",
      "Shimmying",
      "Simmering",
      "Smooshing",
      "Spelunking",
      "Spinning",
      "Stewing",
      "Sussing",
      "Synthesizing",
      "Thinking",
      "Tinkering",
      "Transmuting",
      "Unfurling",
      "Unravelling",
      "Vibing",
      "Wandering",
      "Whirring",
      "Wibbling",
      "Working",
      "Wrangling",
    ],
  };
function eXB({
  mode: A,
  spinnerTip: B,
  currentResponseLength: Q,
  overrideColor: Z,
  overrideShimmerColor: G,
  overrideMessage: Y,
  verbose: I,
  todos: W,
  hasActiveTools: J = !1,
}) {
  let X = gQ5(),
    [F, V] = pF.useState(0),
    [K, H] = pF.useState(0),
    [z, D] = pF.useState(0),
    [C] = dB(),
    { isConnected: w } = bE0(),
    [E, L] = pF.useState(!1),
    { columns: O } = IB(),
    R = W?.find((o1) => o1.status === "in_progress"),
    P = W?.find((o1) => o1.status === "pending"),
    _ = pF.useMemo(() => BT(X), [X]),
    b = (Y ?? R?.activeForm ?? _) + "…",
    { isStalled: S, stalledIntensity: d } = dE0(Q, J),
    u = G51(A, b, w, S),
    o = mE0(A),
    m = pF.useRef(Date.now()),
    j = pF.useRef(Q),
    r = pF.useRef(Q);
  (pF.useEffect(() => {
    let o1 = "spinner-" + A;
    return (
      RI1.startCLIActivity(o1),
      () => {
        RI1.endCLIActivity(o1);
      }
    );
  }, [A]),
    pF.useEffect(() => {
      if (((j.current = Q), Q > r.current)) (L(!0), (r.current = Q));
    }, [Q]),
    pF.useEffect(() => {
      (L(!1), (r.current = Q));
    }, [A]),
    pW(() => {
      if (!w) {
        V(4);
        return;
      }
      V((o1) => o1 + 1);
    }, 120),
    pW(() => {
      D((o1) => {
        let K0 = j.current - o1;
        if (K0 <= 0) return o1;
        let U0;
        if (K0 < 70) U0 = 1;
        else if (K0 < 200) U0 = Math.max(2, Math.ceil(K0 * 0.08));
        else U0 = 18;
        return Math.min(o1 + U0, j.current);
      });
    }, 10),
    pW(() => {
      H(Math.floor((Date.now() - m.current) / 1000));
    }, 10));
  let Q1 = I || (K > 5 && E && Q > 0),
    J1 = b.length + 2,
    R1 = 16,
    s1 = O > J1 + 20,
    Z0 = C.todoFeatureEnabled && W && W.length > 0 && s1 && O > J1 + R1 + 25,
    _0 = Q1 && s1 && O > J1 + R1 + (Z0 ? 25 : 0) + 25,
    D0 = [
      ...(s1
        ? [
            fB.createElement(
              y,
              { key: "esc" },
              fB.createElement(M, { dimColor: !0, bold: !0 }, "esc", " "),
              fB.createElement(M, { dimColor: !0 }, "to interrupt"),
            ),
          ]
        : []),
      ...(Z0
        ? [
            fB.createElement(
              M,
              { dimColor: !0, key: "todo" },
              fB.createElement(M, { dimColor: !0, bold: !0 }, "ctrl+t"),
              " ",
              "to ",
              C.showExpandedTodos ? "hide" : "show",
              " todos",
            ),
          ]
        : []),
      ...(_0
        ? [
            fB.createElement(M, { dimColor: !0, key: "elapsedTime" }, K, "s"),
            fB.createElement(
              y,
              { flexDirection: "row", key: "tokens" },
              fB.createElement(hQ5, { mode: A, key: "spinnerMode" }),
              fB.createElement(M, { dimColor: !0 }, ZG(Math.round(z / 4)), " tokens"),
            ),
          ]
        : []),
    ];
  if (w === !1)
    D0.push(fB.createElement(y, { key: "offline" }, fB.createElement(M, { color: "error", bold: !0 }, "offline")));
  let C1 = Z ?? (w === !1 ? "inactive" : "claude"),
    g1 = G ?? "claudeShimmer",
    v1 =
      D0.length > 0
        ? fB.createElement(
            fB.Fragment,
            null,
            fB.createElement(M, { dimColor: !0 }, "("),
            VW(D0, (o1) => fB.createElement(M, { dimColor: !0, key: `separator-${o1}` }, " ", "·", " ")),
            fB.createElement(M, { dimColor: !0 }, ")"),
          )
        : null;
  return fB.createElement(
    y,
    { flexDirection: "column", width: "100%", alignItems: "flex-start" },
    fB.createElement(
      y,
      { flexDirection: "row", flexWrap: "wrap", marginTop: 1, width: "100%" },
      fB.createElement(uE0, { frame: F, messageColor: C1, glimmerIndex: u, stalledIntensity: d, isConnected: w }),
      fB.createElement(gE0, {
        message: b,
        mode: A,
        isConnected: w,
        messageColor: C1,
        glimmerIndex: u,
        flashOpacity: o,
        shimmerColor: g1,
        stalledIntensity: d,
      }),
      v1,
    ),
    C.showExpandedTodos && W && W.length > 0
      ? fB.createElement(
          y,
          { width: "100%", flexDirection: "column" },
          fB.createElement(NA, null, fB.createElement(o01, { todos: W })),
        )
      : P || B
        ? fB.createElement(
            y,
            { width: "100%" },
            fB.createElement(NA, null, fB.createElement(M, { dimColor: !0 }, P ? `Next: ${P.content}` : `Tip: ${B}`)),
          )
        : null,
  );
}
function hQ5({ mode: A }) {
  switch (A) {
    case "tool-input":
    case "tool-use":
    case "responding":
    case "thinking":
      return fB.createElement(y, { width: 2 }, fB.createElement(M, { dimColor: !0 }, t0.arrowDown));
    case "requesting":
      return fB.createElement(y, { width: 2 }, fB.createElement(M, { dimColor: !0 }, t0.arrowUp));
  }
}
function u6() {
  let [A, B] = pF.useState(0),
    { isConnected: Q } = bE0();
  return (
    pW(() => {
      B((G) => (G + 1) % tXB.length);
    }, 120),
    fB.createElement(
      y,
      { flexWrap: "wrap", height: 1, width: 2 },
      fB.createElement(M, { color: Q === !1 ? "inactive" : "text" }, tXB[A]),
    )
  );
}
function gQ5() {
  return ob1("tengu_spinner_words", fQ5).words;
}
var uQ5 = A1(jC1(), 1);
var AFB = _z({ command: V9(), args: Bq(V9()).optional(), env: Ta(V9(), V9()).optional() }),
  mQ5 = _z({ name: V9(), email: V9().email().optional(), url: V9().url().optional() }),
  dQ5 = _z({ type: V9(), url: V9().url() }),
  cQ5 = AFB.partial(),
  lQ5 = AFB.extend({ platform_overrides: Ta(V9(), cQ5).optional() }),
  pQ5 = _z({ type: Pa(["python", "node", "binary"]), entry_point: V9(), mcp_config: lQ5 }),
  iQ5 = _z({
    claude_desktop: V9().optional(),
    platforms: Bq(Pa(["darwin", "win32", "linux"])).optional(),
    runtimes: _z({ python: V9().optional(), node: V9().optional() }).optional(),
  }).passthrough(),
  nQ5 = _z({ name: V9(), description: V9().optional() }),
  aQ5 = _z({ name: V9(), description: V9().optional(), arguments: Bq(V9()).optional(), text: V9() }),
  sQ5 = _z({
    type: Pa(["string", "number", "boolean", "directory", "file"]),
    title: V9(),
    description: V9(),
    required: GL().optional(),
    default: tC1([V9(), cg(), GL(), Bq(V9())]).optional(),
    multiple: GL().optional(),
    sensitive: GL().optional(),
    min: cg().optional(),
    max: cg().optional(),
  }),
  qv7 = Ta(V9(), tC1([V9(), cg(), GL(), Bq(V9())])),
  cE0 = _z({
    $schema: V9().optional(),
    dxt_version: V9(),
    name: V9(),
    display_name: V9().optional(),
    version: V9(),
    description: V9(),
    long_description: V9().optional(),
    author: mQ5,
    repository: dQ5.optional(),
    homepage: V9().url().optional(),
    documentation: V9().url().optional(),
    support: V9().url().optional(),
    icon: V9().optional(),
    screenshots: Bq(V9()).optional(),
    server: pQ5,
    tools: Bq(nQ5).optional(),
    tools_generated: GL().optional(),
    prompts: Bq(aQ5).optional(),
    prompts_generated: GL().optional(),
    keywords: Bq(V9()).optional(),
    license: V9().optional(),
    compatibility: iQ5.optional(),
    user_config: Ta(V9(), sQ5).optional(),
  }),
  Ev7 = _z({
    status: Pa(["signed", "unsigned", "self-signed"]),
    publisher: V9().optional(),
    issuer: V9().optional(),
    valid_from: V9().optional(),
    valid_to: V9().optional(),
    fingerprint: V9().optional(),
  });
import { execFile as b55 } from "child_process";
var f55 = A1(KKB(), 1);
import { promisify as h55 } from "util";
var Rb7 = h55(b55);
var yf1 = A1(V1(), 1);
var c55 = A1(V1(), 1);
var HKB = A1(V1(), 1);
var aN0 = A1(V1(), 1);
import { execSync as zKB } from "child_process";
function l55(A) {
  try {
    let B = process.platform === "win32" ? "where" : "which";
    return (zKB(`${B} ${A}`, { stdio: "ignore" }), !0);
  } catch {
    return !1;
  }
}
var kf1 = YA(() => {
  if (process.env.VISUAL?.trim()) return process.env.VISUAL.trim();
  if (process.env.EDITOR?.trim()) return process.env.EDITOR.trim();
  if (process.platform === "win32") return "notepad";
  return ["code", "vi", "nano"].find((B) => l55(B));
});
async function p55() {
  return kf1();
}
async function zA1(A) {
  let B = await p55();
  if (!B) throw new Error("No editor available");
  zKB(`${B} "${A}"`, { stdio: "inherit" });
}
var bD = A1(V1(), 1),
  tN0 = A1(V1(), 1);
var vD = A1(V1(), 1),
  $KB = A1(V1(), 1);
import { execFileSync as i55 } from "child_process";
function DKB(A) {
  if (!w1().existsSync(A)) return "";
  return w1().readFileSync(A, { encoding: "utf-8" });
}
function CKB(A) {
  try {
    i55("git", ["rev-parse", "--is-inside-work-tree"], { cwd: A, stdio: "ignore" });
  } catch (B) {
    return !1;
  }
  return !0;
}
import { join as UKB } from "path";
var _f1;
function xf1({ onSelect: A, onCancel: B, title: Q, renderDetails: Z }) {
  let G = RI(),
    Y = UKB(IQ(), "CLAUDE.md"),
    I = UKB(WQ(), "CLAUDE.md"),
    W = G.some((w) => w.path === Y),
    J = G.some((w) => w.path === I),
    X = [
      ...G.map((w) => ({ ...w, exists: !0 })),
      ...(W ? [] : [{ path: Y, type: "User", content: "", exists: !1 }]),
      ...(J ? [] : [{ path: I, type: "Project", content: "", exists: !1 }]),
    ],
    F = new Map(),
    V = X.map((w) => {
      let E = IJ(w.path),
        L = w.exists ? "" : " (new)",
        O = w.parent ? (F.get(w.parent) ?? 0) + 1 : 0;
      F.set(w.path, O);
      let R = O > 0 ? "  ".repeat(O - 1) : "",
        P;
      if (w.type === "User" && !w.isNested && w.path === Y) P = "User memory";
      else if (w.type === "Project" && !w.isNested && w.path === I) P = "Project memory";
      else if (O > 0) P = `${R}L ${E}${L}`;
      else P = `${E}`;
      let _,
        b = CKB(WQ());
      if (w.type === "User" && !w.isNested) _ = "Saved in ~/.claude/CLAUDE.md";
      else if (w.type === "Project" && !w.isNested && w.path === I)
        _ = `${b ? "Checked in at" : "Saved in"} ./CLAUDE.md`;
      else if ((w.type, w.parent)) _ = "@-imported";
      else if (w.isNested) _ = "dynamically loaded";
      else _ = "";
      return { label: P, value: w.path, description: _ };
    }),
    K = _f1 && V.some((w) => w.value === _f1) ? _f1 : V[0]?.value || "",
    [H, z] = $KB.useState(K),
    C = X.find((w) => w.path === H)?.type;
  return (
    Z2(),
    s0((w, E) => {
      if (E.escape) B();
    }),
    vD.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", borderColor: "remember", padding: 1, width: "100%" },
      vD.createElement(
        y,
        { marginBottom: 1, flexDirection: "row", justifyContent: "space-between" },
        vD.createElement(M, { color: "remember", bold: !0 }, Q || "Select memory file to edit:"),
      ),
      vD.createElement(
        y,
        { flexDirection: "column", paddingX: 1 },
        vD.createElement(xA, {
          focusValue: H,
          options: V,
          onFocus: (w) => z(w),
          onChange: (w) => {
            ((_f1 = w), A(w));
          },
          onCancel: B,
        }),
      ),
      Z && vD.createElement(y, { marginTop: 1, flexDirection: "column" }, Z(H, C)),
    )
  );
}
var rN0 = A1(V1(), 1);
import { homedir as n55 } from "os";
import { relative as a55 } from "path";
function oN0(A) {
  let B = n55(),
    Q = AA(),
    Z = A.startsWith(B) ? "~" + A.slice(B.length) : null,
    G = A.startsWith(Q) ? "./" + a55(Q, A) : null;
  if (Z && G) return Z.length <= G.length ? Z : G;
  return Z || G || A;
}
function wKB({ memoryPath: A }) {
  let B = oN0(A);
  return rN0.default.createElement(
    y,
    { flexDirection: "column", flexGrow: 1 },
    rN0.default.createElement(M, { color: "text" }, "Memory updated in ", B, " · /memory to edit"),
  );
}
var s55 = {
  type: "local-jsx",
  name: "memory",
  description: "Edit Claude memory files",
  isEnabled: () => !0,
  isHidden: !1,
  async call(A) {
    return bD.createElement(r55, { onDone: A });
  },
  userFacingName() {
    return this.name;
  },
};
function r55({ onDone: A }) {
  tN0.useState(() => {
    RI.cache.clear?.();
  });
  let { columns: B } = IB(),
    Q = async (J) => {
      try {
        if (J.includes(IQ())) {
          let H = IQ();
          if (!w1().existsSync(H)) w1().mkdirSync(H);
        }
        if (!w1().existsSync(J)) w1().writeFileSync(J, "", { encoding: "utf8", flush: !0 });
        await zA1(J);
        let X = "default",
          F = "";
        if (process.env.VISUAL) ((X = "$VISUAL"), (F = process.env.VISUAL));
        else if (process.env.EDITOR) ((X = "$EDITOR"), (F = process.env.EDITOR));
        let V = X !== "default" ? `Using ${X}="${F}".` : "",
          K = V
            ? `> ${V} To change editor, set $EDITOR or $VISUAL environment variable.`
            : "> To use a different editor, set the $EDITOR or $VISUAL environment variable.";
        A(`Opened memory file at ${oN0(J)}

${K}`);
      } catch (X) {
        (U1(X instanceof Error ? X : new Error(String(X)), a7A), A(`Error opening memory file: ${X}`));
      }
    },
    Z = () => {
      A("Cancelled memory editing");
    },
    Y = [].length,
    [I, W] = tN0.useState(!1);
  return (
    s0((J, X) => {}),
    bD.createElement(
      y,
      { flexDirection: "column" },
      bD.createElement(
        y,
        { marginTop: 1, marginBottom: 1 },
        bD.createElement(
          M,
          { dimColor: !0 },
          "Learn more:",
          " ",
          bD.createElement(H5, { url: "https://docs.anthropic.com/en/docs/claude-code/memory" }),
        ),
      ),
      !1,
      !1,
      !1,
      !I && bD.createElement(xf1, { title: "Select memory to edit:", onSelect: Q, onCancel: Z }),
    )
  );
}
var qKB = s55;
var u2 = A1(V1(), 1);
function EKB({ commands: A, onClose: B }) {
  let Q = `Learn more at: ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.anthropic.com/s/claude-code", VERSION: "1.0.119" }.README_URL}`,
    Z = A.filter((W) => !W.isHidden).sort((W, J) => W.name.localeCompare(J.name)),
    [G, Y] = u2.useState(0);
  (u2.useEffect(() => {
    let W = setTimeout(() => {
      if (G < 3) Y(G + 1);
    }, 250);
    return () => clearTimeout(W);
  }, [G]),
    s0((W, J) => {
      if (J.return || J.escape) B();
    }));
  let I = Z2(B);
  return u2.createElement(
    y,
    { flexDirection: "column", padding: 1 },
    u2.createElement(
      M,
      { bold: !0, color: "claude" },
      `Claude Code v${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.anthropic.com/s/claude-code", VERSION: "1.0.119" }.VERSION}`,
    ),
    u2.createElement(
      y,
      { marginTop: 1, flexDirection: "column" },
      u2.createElement(
        M,
        null,
        "Always review Claude's responses, especially when running code. Claude has read access to files in the current directory and can run commands and edit files with your permission.",
      ),
    ),
    G >= 1 &&
      u2.createElement(
        y,
        { flexDirection: "column", marginTop: 1 },
        u2.createElement(M, { bold: !0 }, "Usage Modes:"),
        u2.createElement(M, null, "• REPL: ", u2.createElement(M, { bold: !0 }, "claude"), " (interactive session)"),
        u2.createElement(M, null, "• Non-interactive: ", u2.createElement(M, { bold: !0 }, 'claude -p "question"')),
        u2.createElement(
          y,
          { marginTop: 1 },
          u2.createElement(
            M,
            null,
            "Run ",
            u2.createElement(M, { bold: !0 }, "claude -h"),
            " for all command line options",
          ),
        ),
      ),
    G >= 2 &&
      u2.createElement(
        y,
        { marginTop: 1, flexDirection: "column" },
        u2.createElement(M, { bold: !0 }, "Common Tasks:"),
        u2.createElement(
          M,
          null,
          "• Ask questions about your codebase",
          " ",
          u2.createElement(M, { dimColor: !0 }, "> How does foo.py work?"),
        ),
        u2.createElement(M, null, "• Edit files ", u2.createElement(M, { dimColor: !0 }, "> Update bar.ts to...")),
        u2.createElement(M, null, "• Fix errors ", u2.createElement(M, { dimColor: !0 }, "> cargo build")),
        u2.createElement(M, null, "• Run commands ", u2.createElement(M, { dimColor: !0 }, "> /help")),
        u2.createElement(M, null, "• Run bash commands ", u2.createElement(M, { dimColor: !0 }, "> !ls")),
      ),
    G >= 3 &&
      u2.createElement(
        y,
        { marginTop: 1, flexDirection: "column" },
        u2.createElement(M, { bold: !0 }, "Interactive Mode Commands:"),
        u2.createElement(
          y,
          { flexDirection: "column" },
          Z.map((W, J) =>
            u2.createElement(
              y,
              { key: J, marginLeft: 1 },
              u2.createElement(M, null, u2.createElement(M, { bold: !0 }, `/${W.name}`), ` - ${W.description}`),
            ),
          ),
        ),
      ),
    u2.createElement(y, { marginTop: 1 }, u2.createElement(M, { dimColor: !0 }, Q)),
    u2.createElement(
      y,
      { marginTop: 2 },
      I.pending
        ? u2.createElement(M, { dimColor: !0 }, "Press ", I.keyName, " again to exit")
        : u2.createElement(Rb, null),
    ),
  );
}
var eN0 = A1(V1(), 1),
  o55 = {
    type: "local-jsx",
    name: "help",
    description: "Show help and available commands",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, { options: { commands: B } }) {
      return eN0.createElement(EKB, { commands: B, onClose: A });
    },
    userFacingName() {
      return "help";
    },
  },
  NKB = o55;
var L9 = A1(V1(), 1);
var GK = A1(V1(), 1);
function LKB({ onComplete: A }) {
  let B = Z2(),
    Q = GK.useCallback(
      async (G) => {
        let Y = G === "yes",
          I = H0();
        (TA({ ...I, autoConnectIde: Y, hasIdeAutoConnectDialogBeenShown: !0 }), A());
      },
      [A],
    );
  return (
    s0((G, Y) => {
      if (Y.escape) A();
    }),
    GK.default.createElement(
      y,
      { marginTop: 1, flexDirection: "column" },
      GK.default.createElement(
        y,
        { flexDirection: "column", borderStyle: "round", borderColor: "ide", paddingX: 2, paddingY: 1, width: "100%" },
        GK.default.createElement(
          y,
          { marginBottom: 1 },
          GK.default.createElement(M, { color: "ide" }, "Do you wish to enable auto-connect to IDE?"),
        ),
        GK.default.createElement(
          y,
          { flexDirection: "column", paddingX: 1 },
          GK.default.createElement(xA, {
            options: [
              { label: "Yes", value: "yes" },
              { label: "No", value: "no" },
            ],
            onChange: Q,
            defaultValue: "yes",
            onCancel: () => A(),
          }),
        ),
        GK.default.createElement(
          y,
          { marginTop: 1 },
          GK.default.createElement(
            M,
            { dimColor: !0 },
            "You can also configure this in /config or with the --ide flag",
          ),
        ),
      ),
      GK.default.createElement(
        y,
        { paddingX: 1 },
        GK.default.createElement(
          M,
          { dimColor: !0 },
          B.pending
            ? GK.default.createElement(GK.default.Fragment, null, "Press ", B.keyName, " again to exit")
            : "Enter to confirm",
        ),
      ),
    )
  );
}
function MKB() {
  let A = H0();
  return !FW() && A.autoConnectIde !== !0 && A.hasIdeAutoConnectDialogBeenShown !== !0;
}
import * as RKB from "path";
function t55({ availableIDEs: A, unavailableIDEs: B, selectedIDE: Q, onClose: Z, onSelect: G }) {
  let Y = Z2(),
    [I, W] = L9.useState(Q?.port?.toString() ?? "None"),
    [J, X] = L9.useState(!1),
    F = L9.useCallback(
      (H) => {
        if (H !== "None" && MKB()) X(!0);
        else G(A.find((z) => z.port === parseInt(H)));
      },
      [A, G],
    ),
    V = A.reduce((H, z) => {
      return ((H[z.name] = (H[z.name] || 0) + 1), H);
    }, {}),
    K = A.map((H) => {
      let D = (V[H.name] || 0) > 1 && H.workspaceFolders.length > 0;
      return { label: H.name, value: H.port.toString(), description: D ? OKB(H.workspaceFolders) : void 0 };
    }).concat([{ label: "None", value: "None", description: void 0 }]);
  return (
    s0((H, z) => {
      if (z.escape) Z();
    }),
    J
      ? L9.default.createElement(LKB, { onComplete: () => F(I) })
      : L9.default.createElement(
          y,
          { marginTop: 1, flexDirection: "column" },
          L9.default.createElement(
            y,
            {
              flexDirection: "column",
              borderStyle: "round",
              borderColor: "ide",
              paddingX: 2,
              paddingY: 1,
              width: "100%",
            },
            L9.default.createElement(
              y,
              { flexDirection: "column" },
              L9.default.createElement(M, { color: "ide", bold: !0 }, "Select IDE"),
              L9.default.createElement(M, { dimColor: !0 }, "Connect to an IDE for integrated development features."),
              A.length === 0 &&
                L9.default.createElement(
                  y,
                  { marginTop: 1 },
                  L9.default.createElement(
                    M,
                    { dimColor: !0 },
                    Kw0()
                      ? `No available IDEs detected. Please install the plugin and restart your IDE:
https://docs.anthropic.com/s/claude-code-jetbrains`
                      : "No available IDEs detected. Make sure your IDE has the Claude Code extension or plugin installed and is running.",
                  ),
                ),
            ),
            A.length !== 0 &&
              L9.default.createElement(
                y,
                { flexDirection: "column", paddingX: 1, marginTop: 1 },
                L9.default.createElement(xA, {
                  defaultValue: I,
                  focusValue: I,
                  options: K,
                  onFocus: (H) => W(H),
                  onChange: (H) => {
                    (W(H), F(H));
                  },
                  onCancel: () => Z(),
                }),
              ),
            A.length !== 0 &&
              !FW() &&
              L9.default.createElement(
                y,
                { marginTop: 1 },
                L9.default.createElement(
                  M,
                  { dimColor: !0 },
                  "※ Tip: You can enable auto-connect to IDE in /config or with the --ide flag",
                ),
              ),
            B.length > 0 &&
              L9.default.createElement(
                y,
                { marginTop: 1, flexDirection: "column" },
                L9.default.createElement(
                  M,
                  { dimColor: !0 },
                  "Found ",
                  B.length,
                  " other running IDE(s). However, their workspace/project directories do not match the current cwd.",
                ),
                L9.default.createElement(
                  y,
                  { marginTop: 1, flexDirection: "column" },
                  B.map((H, z) =>
                    L9.default.createElement(
                      y,
                      { key: z, paddingLeft: 3 },
                      L9.default.createElement(M, { dimColor: !0 }, "• ", H.name, ": ", OKB(H.workspaceFolders)),
                    ),
                  ),
                ),
              ),
          ),
          L9.default.createElement(
            y,
            { paddingX: 1 },
            L9.default.createElement(
              M,
              { dimColor: !0 },
              Y.pending
                ? L9.default.createElement(L9.default.Fragment, null, "Press ", Y.keyName, " again to exit")
                : L9.default.createElement(
                    L9.default.Fragment,
                    null,
                    A.length !== 0 && "Enter to confirm · ",
                    "Esc to exit",
                  ),
            ),
          ),
        )
  );
}
async function e55(A, B) {
  let Q = B?.ide;
  if (!Q || (Q.type !== "sse-ide" && Q.type !== "ws-ide")) return null;
  for (let Z of A) if (Z.url === Q.url) return Z;
  return null;
}
function A85({ runningIDEs: A, onSelectIDE: B, onDone: Q }) {
  let Z = Z2(),
    [G, Y] = L9.useState(A[0] ?? ""),
    I = L9.useCallback(
      (J) => {
        B(J);
      },
      [B],
    ),
    W = A.map((J) => ({ label: FO(J), value: J }));
  return (
    s0((J, X) => {
      if (X.escape) Q();
    }),
    L9.default.createElement(
      L9.default.Fragment,
      null,
      L9.default.createElement(
        y,
        {
          flexDirection: "column",
          borderStyle: "round",
          borderColor: "ide",
          marginTop: 1,
          paddingX: 2,
          paddingY: 1,
          width: "100%",
        },
        L9.default.createElement(
          y,
          { marginBottom: 1 },
          L9.default.createElement(M, { color: "ide" }, "Select IDE to install extension:"),
        ),
        L9.default.createElement(
          y,
          { flexDirection: "column", paddingX: 1 },
          L9.default.createElement(xA, {
            focusValue: G,
            options: W,
            onFocus: (J) => Y(J),
            onChange: (J) => {
              (Y(J), I(J));
            },
            onCancel: () => Q(),
          }),
        ),
      ),
      L9.default.createElement(
        y,
        { paddingLeft: 3 },
        L9.default.createElement(
          M,
          { dimColor: !0 },
          Z.pending
            ? L9.default.createElement(L9.default.Fragment, null, "Press ", Z.keyName, " again to exit")
            : L9.default.createElement(L9.default.Fragment, null, "Enter to confirm · Esc to cancel"),
        ),
      ),
    )
  );
}
var B85 = {
    type: "local-jsx",
    name: "ide",
    description: "Manage IDE integrations and show status",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[open]",
    async call(A, B, Q) {
      Y1("tengu_ext_ide_command", {});
      let {
          options: { dynamicMcpConfig: Z },
          onChangeDynamicMcpConfig: G,
        } = B,
        Y = await hY1(!0);
      if (Y.length === 0 && B.onInstallIDEExtension && !FW()) {
        let F = Cv1(),
          V = (K) => {
            if (B.onInstallIDEExtension)
              if ((B.onInstallIDEExtension(K), E$(K)))
                A(`Installed plugin to ${n1.bold(FO(K))}
Please ${n1.bold("restart your IDE")} completely for it to take effect`);
              else A(`Installed extension to ${n1.bold(FO(K))}`);
          };
        if (F.length > 1)
          return L9.default.createElement(A85, {
            runningIDEs: F,
            onSelectIDE: V,
            onDone: () => {
              A("No IDE selected.");
            },
          });
        else if (F.length === 1) {
          let K = F[0];
          return L9.default.createElement(() => {
            return (
              L9.useEffect(() => {
                V(K);
              }, []),
              null
            );
          }, null);
        }
      }
      let I = Y.filter((F) => F.isValid),
        W = Y.filter((F) => !F.isValid),
        J = await e55(I, Z);
      return L9.default.createElement(t55, {
        availableIDEs: I,
        unavailableIDEs: W,
        selectedIDE: J,
        onClose: () => A(),
        onSelect: async (F) => {
          try {
            if (!G) {
              A("Error connecting to IDE.");
              return;
            }
            let V = { ...(Z || {}) };
            if (J) delete V.ide;
            if (!F) A(J ? `Disconnected from ${J.name}.` : "No IDE selected.");
            else {
              let K = F.url;
              ((V.ide = {
                type: K.startsWith("ws:") ? "ws-ide" : "sse-ide",
                url: K,
                ideName: F.name,
                authToken: F.authToken,
                ideRunningInWindows: F.ideRunningInWindows,
                scope: "dynamic",
              }),
                A(`Connected to ${F.name}.`));
            }
            G(V);
          } catch (V) {
            A("Error connecting to IDE.");
          }
        },
      });
    },
    userFacingName() {
      return "ide";
    },
  },
  TKB = B85;
function OKB(A, B = 100) {
  if (A.length === 0) return "";
  let Q = AA(),
    Z = A.slice(0, 2),
    G = A.length > 2,
    Y = G ? 3 : 0,
    I = (Z.length - 1) * 2,
    W = B - I - Y,
    J = Math.floor(W / Z.length),
    F = Z.map((V) => {
      if (V.startsWith(Q + RKB.sep)) V = V.slice(Q.length + 1);
      if (V.length <= J) return V;
      return "…" + V.slice(-(J - 1));
    }).join(", ");
  if (G) F += ", …";
  return F;
}
var Q85 = {
    type: "prompt",
    name: "init",
    description: "Initialize a new CLAUDE.md file with codebase documentation",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "analyzing your codebase",
    userFacingName() {
      return "init";
    },
    source: "builtin",
    async getPromptForCommand() {
      return (
        Fs(),
        [
          {
            type: "text",
            text: `Please analyze this codebase and create a CLAUDE.md file, which will be given to future instances of Claude Code to operate in this repository.

What to add:
1. Commands that will be commonly used, such as how to build, lint, and run tests. Include the necessary commands to develop in this codebase, such as how to run a single test.
2. High-level code architecture and structure so that future instances can be productive more quickly. Focus on the "big picture" architecture that requires reading multiple files to understand.

Usage notes:
- If there's already a CLAUDE.md, suggest improvements to it.
- When you make the initial CLAUDE.md, do not repeat yourself and do not include obvious instructions like "Provide helpful error messages to users", "Write unit tests for all new utilities", "Never include sensitive information (API keys, tokens) in code or commits".
- Avoid listing every component or file structure that can be easily discovered.
- Don't include generic development practices.
- If there are Cursor rules (in .cursor/rules/ or .cursorrules) or Copilot rules (in .github/copilot-instructions.md), make sure to include the important parts.
- If there is a README.md, make sure to include the important parts.
- Do not make up information such as "Common Development Tasks", "Tips for Development", "Support and Documentation" unless this is expressly included in other files that you read.
- Be sure to prefix the file with the following text:

\`\`\`
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
\`\`\``,
          },
        ]
      );
    },
  },
  PKB = Q85;
var $J = A1(V1(), 1);
var o2 = A1(V1(), 1);
import * as jKB from "http";
import * as SKB from "url";
class AL0 {
  localServer;
  port = 0;
  promiseResolver = null;
  promiseRejecter = null;
  expectedState = null;
  pendingResponse = null;
  constructor() {
    this.localServer = jKB.createServer();
  }
  async start() {
    return new Promise((A, B) => {
      (this.localServer.once("error", (Q) => {
        B(new Error(`Failed to start OAuth callback server: ${Q.message}`));
      }),
        this.localServer.listen(0, "localhost", () => {
          let Q = this.localServer.address();
          ((this.port = Q.port), A(this.port));
        }));
    });
  }
  getPort() {
    return this.port;
  }
  hasPendingResponse() {
    return this.pendingResponse !== null;
  }
  async waitForAuthorization(A, B) {
    return new Promise((Q, Z) => {
      ((this.promiseResolver = Q), (this.promiseRejecter = Z), (this.expectedState = A), this.startLocalListener(B));
    });
  }
  handleSuccessRedirect(A) {
    if (!this.pendingResponse) return;
    let B = IP(A) ? $4().CLAUDEAI_SUCCESS_URL : $4().CONSOLE_SUCCESS_URL;
    (this.pendingResponse.writeHead(302, { Location: B }),
      this.pendingResponse.end(),
      (this.pendingResponse = null),
      Y1("tengu_oauth_automatic_redirect", {}));
  }
  handleErrorRedirect() {
    if (!this.pendingResponse) return;
    let A = $4().CLAUDEAI_SUCCESS_URL;
    (this.pendingResponse.writeHead(302, { Location: A }),
      this.pendingResponse.end(),
      (this.pendingResponse = null),
      Y1("tengu_oauth_automatic_redirect_error", {}));
  }
  startLocalListener(A) {
    (this.localServer.on("request", this.handleRedirect.bind(this)),
      this.localServer.on("error", this.handleError.bind(this)),
      A());
  }
  handleRedirect(A, B) {
    let Q = SKB.parse(A.url || "", !0);
    if (Q.pathname !== "/callback") {
      (B.writeHead(404), B.end());
      return;
    }
    let Z = Q.query.code,
      G = Q.query.state;
    this.validateAndRespond(Z, G, B);
  }
  validateAndRespond(A, B, Q) {
    if (!A) {
      (Q.writeHead(400),
        Q.end("Authorization code not found"),
        this.reject(new Error("No authorization code received")));
      return;
    }
    if (B !== this.expectedState) {
      (Q.writeHead(400), Q.end("Invalid state parameter"), this.reject(new Error("Invalid state parameter")));
      return;
    }
    ((this.pendingResponse = Q), this.resolve(A));
  }
  handleError(A) {
    (U1(A, OGA), this.close(), this.reject(A));
  }
  resolve(A) {
    if (this.promiseResolver) (this.promiseResolver(A), (this.promiseResolver = null), (this.promiseRejecter = null));
  }
  reject(A) {
    if (this.promiseRejecter) (this.promiseRejecter(A), (this.promiseResolver = null), (this.promiseRejecter = null));
  }
  close() {
    if (this.pendingResponse) this.handleErrorRedirect();
    if (this.localServer) (this.localServer.removeAllListeners(), this.localServer.close());
  }
}
import * as dI1 from "crypto";
function BL0(A) {
  return A.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function yKB() {
  return BL0(dI1.randomBytes(32));
}
function kKB(A) {
  let B = dI1.createHash("sha256");
  return (B.update(A), BL0(B.digest()));
}
function _KB() {
  return BL0(dI1.randomBytes(32));
}
var ZL0 = A1(V1(), 1);
async function DA1() {
  try {
    let A = yV(!1);
    if (A.error) return (F1(`Failed to get auth headers: ${A.error}`), null);
    return (
      await $2.get(`${$4().BASE_API_URL}/api/oauth/account/settings`, { headers: { ...A.headers, "User-Agent": RU() } })
    ).data;
  } catch (A) {
    return (U1(A, fZA), null);
  }
}
async function QL0() {
  try {
    let A = yV(!1);
    if (A.error) return;
    await $2.post(
      `${$4().BASE_API_URL}/api/oauth/account/grove_notice_viewed`,
      {},
      { headers: { ...A.headers, "User-Agent": RU() } },
    );
  } catch (A) {
    U1(A, hZA);
  }
}
async function vf1(A) {
  try {
    let B = yV(!1);
    if (B.error) {
      F1(`Failed to get auth headers: ${B.error}`);
      return;
    }
    await $2.patch(
      `${$4().BASE_API_URL}/api/oauth/account/settings`,
      { grove_enabled: A },
      { headers: { ...B.headers, "User-Agent": RU() } },
    );
  } catch (B) {
    U1(B, gZA);
  }
}
async function CA1() {
  if (!GS1()) return !1;
  let A = await hb();
  return A !== null && A.grove_enabled;
}
var hb = YA(async () => {
  try {
    let A = yV(!1);
    if (A.error) return (F1(`Failed to get auth headers: ${A.error}`), null);
    let B = await $2.get(`${$4().BASE_API_URL}/api/claude_code_grove`, {
        headers: { ...A.headers, "User-Agent": FM() },
      }),
      { grove_enabled: Q, domain_excluded: Z, notice_is_grace_period: G, notice_reminder_frequency: Y } = B.data;
    return {
      grove_enabled: Q,
      domain_excluded: Z ?? !1,
      notice_is_grace_period: G ?? !0,
      notice_reminder_frequency: Y,
    };
  } catch (A) {
    return (F1(`Failed to fetch Grove notice config: ${A}`), null);
  }
});
function GL0({ clearOnboarding: A = !1 }) {
  (eg2(), IH().delete(), YL0());
  let Q = H0();
  if (A) {
    if (
      ((Q.hasCompletedOnboarding = !1),
      (Q.subscriptionNoticeCount = 0),
      (Q.hasAvailableSubscription = !1),
      Q.customApiKeyResponses?.approved)
    )
      Q.customApiKeyResponses.approved = [];
  }
  ((Q.oauthAccount = void 0), TA(Q));
}
var YL0 = () => {
    (F3.cache?.clear?.(), vR1(), vKB(), qc.cache?.clear?.(), hb.cache?.clear?.());
  },
  xKB = {
    type: "local-jsx",
    name: "logout",
    description: "Sign out from your Anthropic account",
    isEnabled: () => !process.env.DISABLE_LOGOUT_COMMAND,
    isHidden: !1,
    async call() {
      (await n7(), GL0({ clearOnboarding: !0 }));
      let A = ZL0.createElement(M, null, "Successfully logged out from your Anthropic account.");
      return (
        setTimeout(() => {
          G5(0, "logout");
        }, 200),
        A
      );
    },
    userFacingName() {
      return "logout";
    },
  };
class cI1 {
  codeVerifier;
  authCodeListener = null;
  port = null;
  manualAuthCodeResolver = null;
  constructor() {
    this.codeVerifier = yKB();
  }
  async startOAuthFlow(A, B) {
    ((this.authCodeListener = new AL0()), (this.port = await this.authCodeListener.start()));
    let Q = kKB(this.codeVerifier),
      Z = _KB(),
      G = {
        codeChallenge: Q,
        state: Z,
        port: this.port,
        loginWithClaudeAi: B?.loginWithClaudeAi,
        inferenceOnly: B?.inferenceOnly,
        orgUUID: B?.orgUUID,
      },
      Y = s20({ ...G, isManual: !0 }),
      I = s20({ ...G, isManual: !1 }),
      W = await this.waitForAuthorizationCode(Z, async () => {
        (await A(Y), await N$(I));
      }),
      J = this.authCodeListener?.hasPendingResponse() ?? !1;
    try {
      let X = await EjA(W, Z, this.codeVerifier, this.port, !J, B?.expiresIn);
      if ((GL0({ clearOnboarding: !1 }), X.account)) this.storeAccountInfo(X);
      if (J) {
        let V = Uq1(X.scope);
        this.authCodeListener?.handleSuccessRedirect(V);
      }
      let F = await r20(X.access_token);
      return this.formatTokens(X, F);
    } catch (X) {
      if (J) this.authCodeListener?.handleErrorRedirect();
      throw X;
    } finally {
      this.authCodeListener?.close();
    }
  }
  async waitForAuthorizationCode(A, B) {
    return new Promise((Q, Z) => {
      ((this.manualAuthCodeResolver = Q),
        this.authCodeListener
          ?.waitForAuthorization(A, B)
          .then((G) => {
            ((this.manualAuthCodeResolver = null), Q(G));
          })
          .catch((G) => {
            ((this.manualAuthCodeResolver = null), Z(G));
          }));
    });
  }
  handleManualAuthCodeInput(A) {
    if (this.manualAuthCodeResolver)
      (this.manualAuthCodeResolver(A.authorizationCode),
        (this.manualAuthCodeResolver = null),
        this.authCodeListener?.close());
  }
  storeAccountInfo(A) {
    let B = {
        accountUuid: A.account.uuid,
        emailAddress: A.account.email_address,
        organizationUuid: A.organization?.uuid,
      },
      Q = H0();
    ((Q.oauthAccount = B), TA(Q));
  }
  formatTokens(A, B) {
    return {
      accessToken: A.access_token,
      refreshToken: A.refresh_token,
      expiresAt: Date.now() + A.expires_in * 1000,
      scopes: Uq1(A.scope),
      subscriptionType: B,
    };
  }
  cleanup() {
    (this.authCodeListener?.close(), (this.manualAuthCodeResolver = null));
  }
}
var IL0 = A1(V1(), 1);
function bKB() {
  return IL0.default.createElement(
    y,
    { flexDirection: "column", alignItems: "flex-start" },
    IL0.default.createElement(
      M,
      { color: "claude" },
      ` ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗
██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝
██║     ██║     ███████║██║   ██║██║  ██║█████╗  
██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝  
╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗
 ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝
 ██████╗ ██████╗ ██████╗ ███████╗                
██╔════╝██╔═══██╗██╔══██╗██╔════╝                
██║     ██║   ██║██║  ██║█████╗                  
██║     ██║   ██║██║  ██║██╔══╝                  
╚██████╗╚██████╔╝██████╔╝███████╗                
 ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝`,
    ),
  );
}
var g9 = A1(V1(), 1);
var iF = A1(V1(), 1);
function bf1({ customApiKeyTruncated: A, onDone: B }) {
  function Q(G) {
    let Y = H0();
    switch (G) {
      case "yes": {
        (TA({
          ...Y,
          customApiKeyResponses: {
            ...Y.customApiKeyResponses,
            approved: [...(Y.customApiKeyResponses?.approved ?? []), A],
          },
        }),
          B());
        break;
      }
      case "no": {
        (TA({
          ...Y,
          customApiKeyResponses: {
            ...Y.customApiKeyResponses,
            rejected: [...(Y.customApiKeyResponses?.rejected ?? []), A],
          },
        }),
          B());
        break;
      }
    }
  }
  let Z = Z2();
  return iF.default.createElement(
    iF.default.Fragment,
    null,
    iF.default.createElement(
      y,
      { flexDirection: "column", gap: 1, padding: 1, borderStyle: "round", borderColor: "warning" },
      iF.default.createElement(M, { bold: !0, color: "warning" }, "Detected a custom API key in your environment"),
      iF.default.createElement(
        M,
        null,
        iF.default.createElement(M, { bold: !0 }, "ANTHROPIC_API_KEY"),
        iF.default.createElement(M, null, ": sk-ant-...", A),
      ),
      iF.default.createElement(M, null, "Do you want to use this API key?"),
      iF.default.createElement(xA, {
        defaultValue: "no",
        focusValue: "no",
        options: [
          { label: "Yes", value: "yes" },
          { label: `No (${n1.bold("recommended")})`, value: "no" },
        ],
        onChange: (G) => Q(G),
        onCancel: () => Q("no"),
      }),
    ),
    iF.default.createElement(
      y,
      { marginLeft: 3 },
      iF.default.createElement(
        M,
        { dimColor: !0 },
        Z.pending
          ? iF.default.createElement(iF.default.Fragment, null, "Press ", Z.keyName, " again to exit")
          : iF.default.createElement(iF.default.Fragment, null, "Enter to confirm ", t0.dot, " Esc to cancel"),
      ),
    ),
  );
}
var CJ = A1(V1(), 1);
var ff1 = A1(V1(), 1);
function UA1(A) {
  let [B, Q] = ff1.useState(!1);
  return (
    ff1.useEffect(() => {
      Q(!1);
      let Z = setTimeout(() => {
        Q(!0);
      }, A);
      return () => clearTimeout(Z);
    }, [A]),
    B
  );
}
async function G85() {
  try {
    let A = ["https://api.anthropic.com/api/hello", "https://console.anthropic.com/v1/oauth/hello"],
      B = async (G) => {
        try {
          let Y = await $2.get(G, { headers: { "User-Agent": FM() } });
          if (Y.status !== 200)
            return { success: !1, error: `Failed to connect to ${new URL(G).hostname}: Status ${Y.status}` };
          return { success: !0 };
        } catch (Y) {
          return {
            success: !1,
            error: `Failed to connect to ${new URL(G).hostname}: ${Y instanceof Error ? Y.code || Y.message : String(Y)}`,
          };
        }
      },
      Z = (await Promise.all(A.map(B))).find((G) => !G.success);
    if (Z) Y1("tengu_preflight_check_failed", { isConnectivityError: !1, hasErrorMessage: !!Z.error });
    return Z || { success: !0 };
  } catch (A) {
    return (
      U1(A, xGA),
      Y1("tengu_preflight_check_failed", { isConnectivityError: !0 }),
      { success: !1, error: `Connectivity check error: ${A instanceof Error ? A.code || A.message : String(A)}` }
    );
  }
}
function fKB({ onSuccess: A }) {
  let [B, Q] = CJ.useState(null),
    [Z, G] = CJ.useState(!0),
    Y = UA1(1000) && Z;
  return (
    CJ.useEffect(() => {
      async function I() {
        let W = await G85();
        (Q(W), G(!1));
      }
      I();
    }, []),
    CJ.useEffect(() => {
      if (B?.success) A();
      else if (B && !B.success) {
        let I = setTimeout(() => process.exit(1), 100);
        return () => clearTimeout(I);
      }
    }, [B, A]),
    CJ.default.createElement(
      y,
      { flexDirection: "column", gap: 1, paddingLeft: 1 },
      Z && Y
        ? CJ.default.createElement(
            y,
            { paddingLeft: 1 },
            CJ.default.createElement(u6, null),
            CJ.default.createElement(M, null, "Checking connectivity..."),
          )
        : !B?.success &&
            !Z &&
            CJ.default.createElement(
              y,
              { flexDirection: "column", gap: 1 },
              CJ.default.createElement(M, { color: "error" }, "Unable to connect to Anthropic services"),
              CJ.default.createElement(M, { color: "error" }, B?.error),
              CJ.default.createElement(
                y,
                { flexDirection: "column", gap: 1 },
                CJ.default.createElement(M, null, "Please check your internet connection and network settings."),
                CJ.default.createElement(
                  M,
                  null,
                  "Note: Claude Code might not be available in your country. Check supported countries at",
                  " ",
                  CJ.default.createElement(M, { color: "suggestion" }, "https://anthropic.com/supported-countries"),
                ),
              ),
            ),
    )
  );
}
function gKB({ onDone: A }) {
  let [B, Q] = g9.useState(0),
    Z = ED(),
    [G, Y] = sB();
  g9.useEffect(() => {
    Y1("tengu_began_setup", { oauthEnabled: Z });
  }, [Z]);
  function I() {
    if (B < H.length - 1) {
      let z = B + 1;
      (Q(z), Y1("tengu_onboarding_step", { oauthEnabled: Z, stepId: H[z]?.id }));
    } else A();
  }
  function W(z) {
    (Y(z), I());
  }
  let J = Z2();
  s0(async (z, D) => {
    let C = H[B];
    if (D.return && C && ["security"].includes(C.id))
      if (B === H.length - 1) {
        A();
        return;
      } else {
        if (C.id === "security") await n7();
        I();
      }
    else if (D.escape && C?.id === "terminal-setup") I();
  });
  let X = g9.default.createElement(gb1, {
      initialTheme: G,
      onThemeSelect: W,
      showIntroText: !0,
      helpText: "To change this later, run /theme",
      hideEscToCancel: !0,
      skipExitHandling: !0,
    }),
    F = g9.default.createElement(
      y,
      { flexDirection: "column", gap: 1, paddingLeft: 1 },
      g9.default.createElement(M, { bold: !0 }, "Security notes:"),
      g9.default.createElement(
        y,
        { flexDirection: "column", width: 70 },
        g9.default.createElement(
          Fu,
          null,
          g9.default.createElement(
            Fu.Item,
            null,
            g9.default.createElement(M, null, "Claude can make mistakes"),
            g9.default.createElement(
              M,
              { dimColor: !0, wrap: "wrap" },
              "You should always review Claude's responses, especially when",
              g9.default.createElement(l3, null),
              "running code.",
              g9.default.createElement(l3, null),
            ),
          ),
          g9.default.createElement(
            Fu.Item,
            null,
            g9.default.createElement(M, null, "Due to prompt injection risks, only use it with code you trust"),
            g9.default.createElement(
              M,
              { dimColor: !0, wrap: "wrap" },
              "For more details see:",
              g9.default.createElement(l3, null),
              g9.default.createElement(H5, { url: "https://docs.anthropic.com/s/claude-code-security" }),
            ),
          ),
        ),
      ),
      g9.default.createElement(Rb, null),
    ),
    V = g9.default.createElement(fKB, { onSuccess: I }),
    K = g9.useMemo(() => {
      if (!process.env.ANTHROPIC_API_KEY) return "";
      let z = ND(process.env.ANTHROPIC_API_KEY);
      if (hf1(z) === "new") return z;
    }, []),
    H = [];
  if (Z) H.push({ id: "preflight", component: V });
  if ((H.push({ id: "theme", component: X }), Z))
    H.push({ id: "oauth", component: g9.default.createElement(gb, { onDone: I }) });
  if (K) H.push({ id: "api-key", component: g9.default.createElement(bf1, { customApiKeyTruncated: K, onDone: I }) });
  if ((H.push({ id: "security", component: F }), Vu()))
    H.push({
      id: "terminal-setup",
      component: g9.default.createElement(
        y,
        { flexDirection: "column", gap: 1, paddingLeft: 1 },
        g9.default.createElement(M, { bold: !0 }, "Use Claude Code's terminal setup?"),
        g9.default.createElement(
          y,
          { flexDirection: "column", width: 70, gap: 1 },
          g9.default.createElement(
            M,
            null,
            "For the optimal coding experience, enable the recommended settings",
            g9.default.createElement(l3, null),
            "for your terminal:",
            " ",
            tA.terminal === "Apple_Terminal" ? "Option+Enter for newlines and visual bell" : "Shift+Enter for newlines",
          ),
          g9.default.createElement(xA, {
            options: [
              { label: "Yes, use recommended settings", value: "install" },
              { label: "No, maybe later with /terminal-setup", value: "no" },
            ],
            onChange: (z) => {
              if (z === "install")
                B20(G).then(() => {
                  I();
                });
              else I();
            },
            onCancel: () => I(),
          }),
          g9.default.createElement(
            M,
            { dimColor: !0 },
            J.pending
              ? g9.default.createElement(g9.default.Fragment, null, "Press ", J.keyName, " again to exit")
              : g9.default.createElement(g9.default.Fragment, null, "Enter to confirm · Esc to skip"),
          ),
        ),
      ),
    });
  return g9.default.createElement(
    y,
    { flexDirection: "column", gap: 1 },
    H[B]?.id !== "oauth" && g9.default.createElement(WL0, null),
    g9.default.createElement(
      y,
      { flexDirection: "column", padding: 0, gap: 0 },
      H[B]?.component,
      J.pending &&
        g9.default.createElement(
          y,
          { padding: 1 },
          g9.default.createElement(M, { dimColor: !0 }, "Press ", J.keyName, " again to exit"),
        ),
    ),
  );
}
var hKB = 28;
function WL0() {
  let { columns: A } = IB(),
    B = A < hKB;
  return g9.default.createElement(
    y,
    { ...(B ? {} : { borderColor: "claude", borderStyle: "round" }), paddingX: 1, width: hKB },
    g9.default.createElement(
      M,
      null,
      g9.default.createElement(M, { color: "claude" }, "✻"),
      " Welcome to ",
      g9.default.createElement(M, { bold: !0 }, "Claude Code"),
    ),
  );
}
var JDB = A1(IDB(), 1);
function yL0({ message: A, title: B }) {
  let Q = B
    ? `${B}:
${A}`
    : A;
  try {
    process.stdout.write(`\x1B]9;

${Q}\x07`);
  } catch {}
}
function WDB({ message: A, title: B }) {
  try {
    let Q = Math.floor(Math.random() * 1e4);
    (process.stdout.write(`\x1B]99;i=${Q}:d=0:p=title;${B || "Claude Code"}\x1B\\`),
      process.stdout.write(`\x1B]99;i=${Q}:p=body;${A}\x1B\\`),
      process.stdout.write(`\x1B]99;i=${Q}:d=1:a=focus;\x1B\\`));
  } catch {}
}
function $75({ message: A, title: B }) {
  try {
    let Q = B || "Claude Code";
    process.stdout.write(`\x1B]777;notify;${Q};${A}\x07`);
  } catch {}
}
function kL0() {
  process.stdout.write("\x07");
}
async function w75(A, B) {
  return;
}
async function q75() {
  try {
    if (tA.terminal !== "Apple_Terminal") return !1;
    let B = (
      await B2("osascript", ["-e", 'tell application "Terminal" to name of current settings of front window'])
    ).stdout.trim();
    if (!B) return !1;
    let Q = await B2("defaults", ["export", "com.apple.Terminal", "-"]);
    if (Q.code !== 0) return !1;
    let Y = JDB.default.parse(Q.stdout)?.["Window Settings"]?.[B];
    if (!Y) return !1;
    return Y.Bell === !1;
  } catch (A) {
    return (U1(A instanceof Error ? A : new Error(String(A)), STYLE_CODE_240), !1);
  }
}
async function TA1(A) {
  let B = H0(),
    Q = B.preferredNotifChannel,
    Z = "none";
  if (B.customNotifyCommand) await w75(A, B.customNotifyCommand);
  switch ((await AMA(A), Q)) {
    case "auto":
      if (tA.terminal === "Apple_Terminal")
        if (await q75()) (kL0(), (Z = "terminal_bell"));
        else Z = "no_method_available";
      else if (tA.terminal === "iTerm.app") (yL0(A), (Z = "iterm2"));
      else if (tA.terminal === "kitty") (WDB(A), (Z = "kitty"));
      else if (tA.terminal === "ghostty") ($75(A), (Z = "ghostty"));
      else Z = "no_method_available";
      break;
    case "iterm2":
      (yL0(A), (Z = "iterm2"));
      break;
    case "terminal_bell":
      (kL0(), (Z = "terminal_bell"));
      break;
    case "iterm2_with_bell":
      (yL0(A), kL0(), (Z = "iterm2_with_bell"));
      break;
    case "kitty":
      (WDB(A), (Z = "kitty"));
      break;
    case "notifications_disabled":
      Z = "disabled";
      break;
  }
  Y1("tengu_notification_method_used", { configured_channel: Q, method_used: Z, term: tA.terminal });
}
var PASTE_CODE_PROMPT = "Paste code here if prompted > ";
function gb({ onDone: A, startingMessage: B, mode: Q = "login", forceLoginMethod: Z }) {
  let G = E2() || {},
    Y = Z ?? G.forceLoginMethod,
    I = G.forceLoginOrgUUID,
    [W, J] = o2.useState(!1),
    X =
      Y === "claudeai"
        ? "Login method pre-selected: Subscription Plan (Claude Pro/Max)"
        : Y === "console"
          ? "Login method pre-selected: API Usage Billing (Anthropic Console)"
          : null,
    [F, V] = o2.useState(() => {
      if (Q === "setup-token") return { state: "ready_to_start" };
      if (Y === "claudeai" || Y === "console") return { state: "ready_to_start" };
      return { state: "idle" };
    }),
    [K, H] = o2.useState(""),
    [z, D] = o2.useState(0),
    [C] = o2.useState(() => new cI1()),
    [w, E] = o2.useState(() => {
      return Q === "setup-token" || Y === "claudeai";
    }),
    [L, O] = o2.useState(!1),
    [R] = o2.useState(() => new NI1()),
    P = IB().columns - PASTE_CODE_PROMPT.length - 1;
  (o2.useEffect(() => {
    WW("tengu_show_all_subscription_types").then(J);
  }, []),
    o2.useEffect(() => {
      if (Y === "claudeai") Y1("tengu_oauth_claudeai_forced", {});
      else if (Y === "console") Y1("tengu_oauth_console_forced", {});
    }, [Y]),
    o2.useEffect(() => {
      if (F.state === "about_to_retry")
        (n7(),
          R.reset(),
          setTimeout(() => {
            V(F.nextState);
          }, 1000));
    }, [F, R]),
    s0(async (u, o) => {
      if (o.return) {
        if (F.state === "success" && Q !== "setup-token")
          (Y1("tengu_oauth_success", { loginWithClaudeAi: w }), await n7(), A());
        else if (F.state === "error" && F.toRetry) (H(""), V({ state: "about_to_retry", nextState: F.toRetry }));
      }
    }));
  async function _(u, o) {
    try {
      let [m, j] = u.split("#");
      if (!m || !j) {
        V({
          state: "error",
          message: "Invalid code. Please make sure the full code was copied",
          toRetry: { state: "waiting_for_login", url: o },
        });
        return;
      }
      (Y1("tengu_oauth_manual_entry", {}), C.handleManualAuthCodeInput({ authorizationCode: m, state: j }));
    } catch (m) {
      (U1(m instanceof Error ? m : new Error(String(m)), Y3A),
        V({ state: "error", message: m.message, toRetry: { state: "waiting_for_login", url: o } }));
    }
  }
  let b = o2.useCallback(async () => {
      try {
        let u = await C.startOAuthFlow(
            async (m) => {
              (V({ state: "waiting_for_login", url: m }), setTimeout(() => O(!0), 3000));
            },
            {
              loginWithClaudeAi: w,
              inferenceOnly: Q === "setup-token",
              expiresIn: Q === "setup-token" ? 31536000 : void 0,
              orgUUID: I,
            },
          ).catch((m) => {
            let j = m.message.includes("Token exchange failed");
            throw (
              V({
                state: "error",
                message: j ? "Failed to exchange authorization code for access token. Please try again." : m.message,
                toRetry: Q === "setup-token" ? { state: "ready_to_start" } : { state: "idle" },
              }),
              Y1("tengu_oauth_token_exchange_error", { error: m.message }),
              m
            );
          }),
          o = mZ1(u);
        if (o.warning) Y1("tengu_oauth_storage_warning", { warning: o.warning });
        if ((V({ state: "creating_api_key" }), Q === "setup-token")) V({ state: "success", token: u.accessToken });
        else if (
          (await LjA(u.accessToken).catch((j) => {
            throw (
              V({ state: "error", message: "Failed to fetch user roles: " + j.message, toRetry: { state: "idle" } }),
              Y1("tengu_oauth_user_roles_error", { error: j.message }),
              j
            );
          }),
          IP(u.scopes)
            ? !0
            : await MjA(u.accessToken).catch((j) => {
                throw (
                  V({ state: "error", message: "Failed to create API key: " + j.message, toRetry: { state: "idle" } }),
                  Y1("tengu_oauth_api_key_error", { error: j.message }),
                  j
                );
              }))
        )
          (await Promise.all([Wb1(), ...(IP(u.scopes) ? [oX2()] : [])]),
            YL0(),
            V({ state: "success" }),
            TA1({ message: "Claude Code login successful" }));
        else
          (V({
            state: "error",
            message: "Unable to create API key. The server accepted the request but didn't return a key.",
            toRetry: { state: "idle" },
          }),
            Y1("tengu_oauth_api_key_error", { error: "server_returned_no_key" }));
      } catch (u) {
        let o = u.message;
        Y1("tengu_oauth_error", { error: o });
      }
    }, [C, O, w, Q, I]),
    S = o2.useRef(!1);
  (o2.useEffect(() => {
    if (F.state === "ready_to_start" && !S.current)
      ((S.current = !0),
        process.nextTick(() => {
          (b(), (S.current = !1));
        }));
  }, [F.state, b]),
    o2.useEffect(() => {
      if (Q === "setup-token" && F.state === "success") {
        let u = setTimeout(async () => {
          (Y1("tengu_oauth_success", { loginWithClaudeAi: w }), A());
        }, 500);
        return () => clearTimeout(u);
      }
    }, [Q, F, w, A]),
    o2.useEffect(() => {
      return () => {
        C.cleanup();
      };
    }, [C]));
  function d() {
    switch (F.state) {
      case "idle":
        return o2.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          o2.default.createElement(
            M,
            { bold: !0 },
            B
              ? B
              : "Claude Code can now be used with your Claude subscription or billed based on API usage through your Console account.",
          ),
          o2.default.createElement(
            y,
            { marginTop: 1 },
            o2.default.createElement(M, { bold: !0 }, "Select login method:"),
          ),
          o2.default.createElement(
            y,
            null,
            o2.default.createElement(xA, {
              options: [
                {
                  label: W
                    ? `Claude account with subscription
 ${n1.dim("Pro, Max, Team, or Enterprise")}
`
                    : `Claude account with subscription
 ${n1.dim("Starting at $20/mo for Pro, $100/mo for Max - Best value, predictable pricing")}
`,
                  value: "claudeai",
                },
                {
                  label: `Anthropic Console account
 ${n1.dim("API usage billing")}
`,
                  value: "console",
                },
              ],
              onCancel: () => {},
              onChange: (u) => {
                if ((V({ state: "ready_to_start" }), u === "claudeai"))
                  (Y1("tengu_oauth_claudeai_selected", {}), E(!0));
                else (Y1("tengu_oauth_console_selected", {}), E(!1));
              },
            }),
          ),
        );
      case "waiting_for_login":
        return o2.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          X && o2.default.createElement(y, null, o2.default.createElement(M, { dimColor: !0 }, X)),
          !L &&
            o2.default.createElement(
              y,
              null,
              o2.default.createElement(u6, null),
              o2.default.createElement(M, null, "Opening browser to sign in…"),
            ),
          L &&
            o2.default.createElement(
              y,
              null,
              o2.default.createElement(M, null, PASTE_CODE_PROMPT),
              o2.default.createElement(s4, {
                value: K,
                onChange: H,
                onSubmit: (u) => _(u, F.url),
                cursorOffset: z,
                onChangeCursorOffset: D,
                columns: P,
              }),
            ),
        );
      case "creating_api_key":
        return o2.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          o2.default.createElement(
            y,
            null,
            o2.default.createElement(u6, null),
            o2.default.createElement(M, null, "Creating API key for Claude Code…"),
          ),
        );
      case "about_to_retry":
        return o2.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          o2.default.createElement(M, { color: "permission" }, "Retrying…"),
        );
      case "success":
        return o2.default.createElement(
          y,
          { flexDirection: "column", gap: 2 },
          Q === "setup-token" && F.token
            ? null
            : o2.default.createElement(
                o2.default.Fragment,
                null,
                TZ()?.emailAddress
                  ? o2.default.createElement(
                      M,
                      { dimColor: !0 },
                      "Logged in as",
                      " ",
                      o2.default.createElement(M, null, TZ()?.emailAddress),
                    )
                  : null,
                o2.default.createElement(
                  M,
                  { color: "success" },
                  "Login successful. Press ",
                  o2.default.createElement(M, { bold: !0 }, "Enter"),
                  " to continue…",
                ),
              ),
        );
      case "error":
        return o2.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          o2.default.createElement(M, { color: "error" }, "OAuth error: ", F.message),
          F.toRetry &&
            o2.default.createElement(
              y,
              { marginTop: 1 },
              o2.default.createElement(
                M,
                { color: "permission" },
                "Press ",
                o2.default.createElement(M, { bold: !0 }, "Enter"),
                " to retry.",
              ),
            ),
        );
      default:
        return null;
    }
  }
  return (
    o2.useEffect(() => {
      let u = {};
      if (
        ((u.header = o2.default.createElement(
          y,
          { key: "header", flexDirection: "column", gap: 1 },
          o2.default.createElement(WL0, null),
          o2.default.createElement(y, { paddingBottom: 1, paddingLeft: 1 }, o2.default.createElement(bKB, null)),
        )),
        F.state === "waiting_for_login" && L)
      )
        u.urlToCopy = o2.default.createElement(
          y,
          { flexDirection: "column", key: "urlToCopy", gap: 1, paddingBottom: 1 },
          o2.default.createElement(
            y,
            { paddingX: 1 },
            o2.default.createElement(M, { dimColor: !0 }, "Browser didn't open? Use the url below to sign in:"),
          ),
          o2.default.createElement(y, { width: 1000 }, o2.default.createElement(M, { dimColor: !0 }, F.url)),
        );
      if (Q === "setup-token" && F.state === "success" && F.token)
        u.tokenOutput = o2.default.createElement(
          y,
          { key: "tokenOutput", flexDirection: "column", gap: 1, paddingTop: 1 },
          o2.default.createElement(M, { color: "success" }, "✓ Long-lived authentication token created successfully!"),
          o2.default.createElement(
            y,
            { flexDirection: "column", gap: 1 },
            o2.default.createElement(M, null, "Your OAuth token (valid for 1 year):"),
            o2.default.createElement(y, { width: 1000 }, o2.default.createElement(M, { color: "warning" }, F.token)),
            o2.default.createElement(
              M,
              { dimColor: !0 },
              "Store this token securely. You won't be able to see it again.",
            ),
            o2.default.createElement(
              M,
              { dimColor: !0 },
              "Use this token by setting: export CLAUDE_CODE_OAUTH_TOKEN=<token>",
            ),
          ),
        );
      R.renderStatic(u);
    }, [R, F, L, Q]),
    o2.default.createElement(
      y,
      { flexDirection: "column", gap: 1 },
      o2.default.createElement(y, { paddingLeft: 1, flexDirection: "column", gap: 1 }, d()),
    )
  );
}
var P9 = A1(V1(), 1);
var E75 = 53;
function PA1({ model: A }) {
  let B = EQ(process.env.IS_DEMO) ? 29 : Math.max(E75, AA().length + 12),
    Q = oJ(!1),
    { columns: Z } = IB(),
    G = Z < B,
    Y = Boolean(process.env.ANTHROPIC_API_KEY && tg2(process.env.ANTHROPIC_API_KEY)),
    I = EQ(process.env.DISABLE_PROMPT_CACHING),
    W = AF2(A),
    J = null,
    X = Boolean(
      Y || I || process.env.API_TIMEOUT_MS || process.env.MAX_THINKING_TOKENS || process.env.ANTHROPIC_BASE_URL,
    );
  return P9.createElement(
    y,
    { flexDirection: "column" },
    P9.createElement(
      y,
      {
        ...(G ? {} : { borderColor: "claude", borderStyle: "round" }),
        flexDirection: "column",
        gap: 1,
        paddingLeft: 1,
        width: B,
      },
      P9.createElement(
        M,
        null,
        P9.createElement(M, { color: "claude" }, "✻"),
        " Welcome to ",
        P9.createElement(M, { bold: !0 }, "Claude Code"),
        "!",
      ),
      process.env.IS_DEMO
        ? null
        : P9.createElement(
            P9.Fragment,
            null,
            P9.createElement(
              y,
              { paddingLeft: 2, flexDirection: "column", gap: 1 },
              P9.createElement(M, { dimColor: !0, italic: !0 }, "/help for help, /status for your current setup"),
              P9.createElement(M, { dimColor: !0 }, "cwd: ", AA()),
              !1,
              !1,
            ),
            X &&
              P9.createElement(
                y,
                {
                  borderTopDimColor: !0,
                  borderStyle: "single",
                  borderBottom: !1,
                  borderLeft: !1,
                  borderRight: !1,
                  borderTop: !0,
                  flexDirection: "column",
                  marginLeft: 2,
                  marginRight: 1,
                  paddingTop: 1,
                },
                P9.createElement(y, { marginBottom: 1 }, P9.createElement(M, { dimColor: !0 }, "Overrides (via env):")),
                Y && Q
                  ? P9.createElement(
                      M,
                      { dimColor: !0 },
                      "• API Key:",
                      " ",
                      P9.createElement(
                        M,
                        { bold: !0 },
                        Q.length < 25 ? `${Q.slice(0, 3)}…` : `sk-ant-…${Q.slice(-B + 25)}`,
                      ),
                    )
                  : null,
                I
                  ? P9.createElement(
                      M,
                      { dimColor: !0 },
                      "• Prompt caching:",
                      " ",
                      P9.createElement(M, { color: "error", bold: !0 }, "off"),
                    )
                  : null,
                process.env.API_TIMEOUT_MS
                  ? P9.createElement(
                      M,
                      { dimColor: !0 },
                      "• API timeout:",
                      " ",
                      P9.createElement(M, { bold: !0 }, process.env.API_TIMEOUT_MS, "ms"),
                    )
                  : null,
                process.env.MAX_THINKING_TOKENS
                  ? P9.createElement(
                      M,
                      { dimColor: !0 },
                      "• Max thinking tokens:",
                      " ",
                      P9.createElement(M, { bold: !0 }, process.env.MAX_THINKING_TOKENS),
                    )
                  : null,
                process.env.ANTHROPIC_BASE_URL
                  ? P9.createElement(
                      M,
                      { dimColor: !0 },
                      "• API Base URL:",
                      " ",
                      P9.createElement(M, { bold: !0 }, process.env.ANTHROPIC_BASE_URL),
                    )
                  : null,
              ),
          ),
    ),
  );
}
var FDB = A1(V1(), 1);
function SO() {
  let [{ mainLoopModel: A, maxRateLimitFallbackActive: B }] = dB();
  return FDB.useMemo(() => {
    return VM(A ?? GG0(B));
  }, [A, B]);
}
var VDB = () => ({
  type: "local-jsx",
  name: "login",
  description: ng2(!1) ? "Switch Anthropic accounts" : "Sign in with your Anthropic account",
  isEnabled: () => !process.env.DISABLE_LOGIN_COMMAND,
  isHidden: !1,
  async call(A, B) {
    return (
      await n7(),
      $J.createElement(_L0, {
        onDone: async (Q, Z) => {
          if ((EI1($J.createElement(PA1, { model: Z })), B.onChangeAPIKey(), Q)) (ho1(), Lc());
          A(Q ? "Login successful" : "Login interrupted");
        },
      })
    );
  },
  userFacingName() {
    return "login";
  },
});
function _L0(A) {
  let B = SO(),
    Q = Z2(() => A.onDone(!1, B));
  return $J.createElement(
    y,
    { flexDirection: "column" },
    $J.createElement(gb, { onDone: () => A.onDone(!0, B), startingMessage: A.startingMessage }),
    $J.createElement(
      y,
      { marginLeft: 3 },
      $J.createElement(
        M,
        { dimColor: !0 },
        Q.pending ? $J.createElement($J.Fragment, null, "Press ", Q.keyName, " again to exit") : "",
      ),
    ),
  );
}
var AZ = A1(V1(), 1);
import { execSync as Jh1 } from "child_process";
var KDB = A1(V1(), 1);
function HDB() {
  return KDB.default.createElement(M, null, "Checking GitHub CLI installation…");
}
var PI = A1(V1(), 1);
function zDB({
  currentRepo: A,
  useCurrentRepo: B,
  repoUrl: Q,
  onRepoUrlChange: Z,
  onSubmit: G,
  onToggleUseCurrentRepo: Y,
}) {
  let [I, W] = PI.useState(0),
    [J, X] = PI.useState(!1),
    V = IB().columns,
    K = () => {
      if (!(B ? A : Q)?.trim()) {
        X(!0);
        return;
      }
      G();
    };
  return (
    s0((H, z) => {
      if (z.upArrow) (Y(!0), X(!1));
      else if (z.downArrow) (Y(!1), X(!1));
      else if (z.return) K();
    }),
    PI.default.createElement(
      PI.default.Fragment,
      null,
      PI.default.createElement(
        y,
        { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
        PI.default.createElement(
          y,
          { flexDirection: "column", marginBottom: 1 },
          PI.default.createElement(M, { bold: !0 }, "Install GitHub App"),
          PI.default.createElement(M, { dimColor: !0 }, "Select GitHub repository"),
        ),
        A &&
          PI.default.createElement(
            y,
            { marginBottom: 1 },
            PI.default.createElement(
              M,
              { bold: B, color: B ? "permission" : void 0 },
              B ? "> " : "  ",
              "Use current repository: ",
              A,
            ),
          ),
        PI.default.createElement(
          y,
          { marginBottom: 1 },
          PI.default.createElement(
            M,
            { bold: !B || !A, color: !B || !A ? "permission" : void 0 },
            !B || !A ? "> " : "  ",
            A ? "Enter a different repository" : "Enter repository",
          ),
        ),
        (!B || !A) &&
          PI.default.createElement(
            y,
            { marginLeft: 2, marginBottom: 1 },
            PI.default.createElement(s4, {
              value: Q,
              onChange: (H) => {
                (Z(H), X(!1));
              },
              onSubmit: K,
              focus: !0,
              placeholder: "Enter a repo as owner/repo or https://github.com/owner/repo…",
              columns: V,
              cursorOffset: I,
              onChangeCursorOffset: W,
              showCursor: !0,
            }),
          ),
      ),
      J &&
        PI.default.createElement(
          y,
          { marginLeft: 3, marginBottom: 1 },
          PI.default.createElement(M, { color: "error" }, "Please enter a repository name to continue"),
        ),
      PI.default.createElement(
        y,
        { marginLeft: 3 },
        PI.default.createElement(M, { dimColor: !0 }, A ? "↑/↓ to select · " : "", "Enter to continue"),
      ),
    )
  );
}
var jI = A1(V1(), 1);
var ADD_GITHUB_WORKFLOW = "Add Claude Code GitHub Workflow",
  yO = "https://github.com/anthropics/claude-code-action/blob/main/docs/setup.md",
  CDB = `name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}

          # This is an optional setting that allows Claude to read CI results on PRs
          additional_permissions: |
            actions: read
          
          # Optional: Specify model (defaults to Claude Sonnet 4, uncomment for Claude Opus 4.1)
          # model: "claude-opus-4-1-20250805"
          
          # Optional: Customize the trigger phrase (default: @claude)
          # trigger_phrase: "/claude"
          
          # Optional: Trigger when specific user is assigned to an issue
          # assignee_trigger: "claude-bot"
          
          # Optional: Allow Claude to run specific commands
          # allowed_tools: "Bash(npm install),Bash(npm run build),Bash(npm run test:*),Bash(npm run lint:*)"
          
          # Optional: Add custom instructions for Claude to customize its behavior for your project
          # custom_instructions: |
          #   Follow our coding standards
          #   Ensure all new code has tests
          #   Use TypeScript for new files
          
          # Optional: Custom environment variables for Claude
          # claude_env: |
          #   NODE_ENV: test

`,
  UDB = `## \uD83E\uDD16 Installing Claude Code GitHub App

This PR adds a GitHub Actions workflow that enables Claude Code integration in our repository.

### What is Claude Code?

[Claude Code](https://claude.ai/code) is an AI coding agent that can help with:
- Bug fixes and improvements  
- Documentation updates
- Implementing new features
- Code reviews and suggestions
- Writing tests
- And more!

### How it works

Once this PR is merged, we'll be able to interact with Claude by mentioning @claude in a pull request or issue comment.
Once the workflow is triggered, Claude will analyze the comment and surrounding context, and execute on the request in a GitHub action.

### Important Notes

- **This workflow won't take effect until this PR is merged**
- **@claude mentions won't work until after the merge is complete**
- The workflow runs automatically whenever Claude is mentioned in PR or issue comments
- Claude gets access to the entire PR or issue context including files, diffs, and previous comments

### Security

- Our Anthropic API key is securely stored as a GitHub Actions secret
- Only users with write access to the repository can trigger the workflow
- All Claude runs are stored in the GitHub Actions run history
- Claude's default tools are limited to reading/writing files and interacting with our repo by creating comments, branches, and commits.
- We can add more allowed tools by adding them to the workflow file like:

\`\`\`
allowed_tools: Bash(npm install),Bash(npm run build),Bash(npm run lint),Bash(npm run test)
\`\`\`

There's more information in the [Claude Code action repo](https://github.com/anthropics/claude-code-action).

After merging this PR, let's try mentioning @claude in a comment on any PR to get started!`,
  $DB = `name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'
    
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}

          # Optional: Specify model (defaults to Claude Sonnet 4, uncomment for Claude Opus 4.1)
          # model: "claude-opus-4-1-20250805"

          # Direct prompt for automated review (no @claude mention needed)
          direct_prompt: |
            Please review this pull request and provide feedback on:
            - Code quality and best practices
            - Potential bugs or issues
            - Performance considerations
            - Security concerns
            - Test coverage
            
            Be constructive and helpful in your feedback.

          # Optional: Use sticky comments to make Claude reuse the same comment on subsequent pushes to the same PR
          # use_sticky_comment: true
          
          # Optional: Customize review based on file types
          # direct_prompt: |
          #   Review this PR focusing on:
          #   - For TypeScript files: Type safety and proper interface usage
          #   - For API endpoints: Security, input validation, and error handling
          #   - For React components: Performance, accessibility, and best practices
          #   - For tests: Coverage, edge cases, and test quality
          
          # Optional: Different prompts for different authors
          # direct_prompt: |
          #   \${{ github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR' && 
          #   'Welcome! Please review this PR from a first-time contributor. Be encouraging and provide detailed explanations for any suggestions.' ||
          #   'Please provide a thorough code review focusing on our coding standards and best practices.' }}
          
          # Optional: Add specific tools for running tests or linting
          # allowed_tools: "Bash(npm run test),Bash(npm run lint),Bash(npm run typecheck)"
          
          # Optional: Skip review for certain conditions
          # if: |
          #   !contains(github.event.pull_request.title, '[skip-review]') &&
          #   !contains(github.event.pull_request.title, '[WIP]')

`,
  wDB = `name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}
          
          # This is an optional setting that allows Claude to read CI results on PRs
          additional_permissions: |
            actions: read

          # Optional: Give a custom prompt to Claude. If this is not specified, Claude will perform the instructions specified in the comment that tagged it.
          # prompt: 'Update the pull request description to include a summary of changes.'

          # Optional: Add claude_args to customize behavior and configuration
          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://docs.anthropic.com/en/docs/claude-code/sdk#command-line for available options
          # claude_args: '--model claude-opus-4-1-20250805 --allowed-tools Bash(VERSION_STRING pr:*)'

`,
  qDB = `name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'
    
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}
          prompt: |
            Please review this pull request and provide feedback on:
            - Code quality and best practices
            - Potential bugs or issues
            - Performance considerations
            - Security concerns
            - Test coverage
            
            Use the repository's CLAUDE.md for guidance on style and conventions. Be constructive and helpful in your feedback.

            Use \`VERSION_STRING pr comment\` with your Bash tool to leave your review as a comment on the PR.
          
          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://docs.anthropic.com/en/docs/claude-code/sdk#command-line for available options
          claude_args: '--allowed-tools "Bash(VERSION_STRING issue view:*),Bash(VERSION_STRING search:*),Bash(VERSION_STRING issue list:*),Bash(VERSION_STRING pr comment:*),Bash(VERSION_STRING pr diff:*),Bash(VERSION_STRING pr view:*),Bash(VERSION_STRING pr list:*)"'

`;
function EDB({ repoUrl: A, onSubmit: B }) {
  return (
    s0((Q, Z) => {
      if (Z.return) B();
    }),
    jI.default.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
      jI.default.createElement(
        y,
        { flexDirection: "column", marginBottom: 1 },
        jI.default.createElement(M, { bold: !0 }, "Install the Claude GitHub App"),
      ),
      jI.default.createElement(
        y,
        { marginBottom: 1 },
        jI.default.createElement(M, null, "Opening browser to install the Claude GitHub App…"),
      ),
      jI.default.createElement(
        y,
        { marginBottom: 1 },
        jI.default.createElement(M, null, "If your browser doesn't open automatically, visit:"),
      ),
      jI.default.createElement(
        y,
        { marginBottom: 1 },
        jI.default.createElement(M, { underline: !0 }, "https://github.com/apps/claude"),
      ),
      jI.default.createElement(
        y,
        { marginBottom: 1 },
        jI.default.createElement(
          M,
          null,
          "Please install the app for repository: ",
          jI.default.createElement(M, { bold: !0 }, A),
        ),
      ),
      jI.default.createElement(
        y,
        { marginBottom: 1 },
        jI.default.createElement(
          M,
          { dimColor: !0 },
          "Important: Make sure to grant access to this specific repository",
        ),
      ),
      jI.default.createElement(
        y,
        null,
        jI.default.createElement(
          M,
          { bold: !0, color: "permission" },
          "Press Enter once you've installed the app",
          t0.ellipsis,
        ),
      ),
      jI.default.createElement(
        y,
        { marginTop: 1 },
        jI.default.createElement(
          M,
          { dimColor: !0 },
          "Having trouble? See manual setup instructions at:",
          " ",
          jI.default.createElement(M, { color: "claude" }, yO),
        ),
      ),
    )
  );
}
var gZ = A1(V1(), 1);
function NDB({
  useExistingSecret: A,
  secretName: B,
  onToggleUseExistingSecret: Q,
  onSecretNameChange: Z,
  onSubmit: G,
}) {
  let [Y, I] = gZ.useState(0),
    W = IB(),
    [J] = sB();
  return (
    s0((X, F) => {
      if (F.upArrow) Q(!0);
      else if (F.downArrow) Q(!1);
      else if (F.return) G();
    }),
    gZ.default.createElement(
      gZ.default.Fragment,
      null,
      gZ.default.createElement(
        y,
        { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
        gZ.default.createElement(
          y,
          { flexDirection: "column", marginBottom: 1 },
          gZ.default.createElement(M, { bold: !0 }, "Install GitHub App"),
          gZ.default.createElement(M, { dimColor: !0 }, "Setup API key secret"),
        ),
        gZ.default.createElement(
          y,
          { marginBottom: 1 },
          gZ.default.createElement(M, { color: "warning" }, "ANTHROPIC_API_KEY already exists in repository secrets!"),
        ),
        gZ.default.createElement(y, { marginBottom: 1 }, gZ.default.createElement(M, null, "Would you like to:")),
        gZ.default.createElement(
          y,
          { marginBottom: 1 },
          gZ.default.createElement(M, null, A ? iB("success", J)("> ") : "  ", "Use the existing API key"),
        ),
        gZ.default.createElement(
          y,
          { marginBottom: 1 },
          gZ.default.createElement(
            M,
            null,
            !A ? iB("success", J)("> ") : "  ",
            "Create a new secret with a different name",
          ),
        ),
        !A &&
          gZ.default.createElement(
            gZ.default.Fragment,
            null,
            gZ.default.createElement(
              y,
              { marginBottom: 1 },
              gZ.default.createElement(M, null, "Enter new secret name (alphanumeric with underscores):"),
            ),
            gZ.default.createElement(s4, {
              value: B,
              onChange: Z,
              onSubmit: G,
              focus: !0,
              placeholder: "e.g., CLAUDE_API_KEY",
              columns: W.columns,
              cursorOffset: Y,
              onChangeCursorOffset: I,
              showCursor: !0,
            }),
          ),
      ),
      gZ.default.createElement(
        y,
        { marginLeft: 3 },
        gZ.default.createElement(M, { dimColor: !0 }, "↑/↓ to select · Enter to continue"),
      ),
    )
  );
}
var wJ = A1(V1(), 1);
function LDB({
  existingApiKey: A,
  apiKeyOrOAuthToken: B,
  onApiKeyChange: Q,
  onSubmit: Z,
  onToggleUseExistingKey: G,
  onCreateOAuthToken: Y,
  selectedOption: I = A ? "existing" : Y ? "oauth" : "new",
  onSelectOption: W,
}) {
  let [J, X] = wJ.useState(0),
    F = IB(),
    [V] = sB();
  return (
    s0((K, H) => {
      if (H.upArrow) {
        if (I === "new" && Y) W?.("oauth");
        else if (I === "oauth" && A) (W?.("existing"), G(!0));
      } else if (H.downArrow) {
        if (I === "existing") (W?.(Y ? "oauth" : "new"), G(!1));
        else if (I === "oauth") W?.("new");
      }
      if (H.return)
        if (I === "oauth" && Y) Y();
        else Z();
    }),
    wJ.default.createElement(
      wJ.default.Fragment,
      null,
      wJ.default.createElement(
        y,
        { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
        wJ.default.createElement(
          y,
          { flexDirection: "column", marginBottom: 1 },
          wJ.default.createElement(M, { bold: !0 }, "Install GitHub App"),
          wJ.default.createElement(M, { dimColor: !0 }, "Choose API key"),
        ),
        A &&
          wJ.default.createElement(
            y,
            { marginBottom: 1 },
            wJ.default.createElement(
              M,
              null,
              I === "existing" ? iB("success", V)("> ") : "  ",
              "Use your existing Claude Code API key",
            ),
          ),
        Y &&
          wJ.default.createElement(
            y,
            { marginBottom: 1 },
            wJ.default.createElement(
              M,
              null,
              I === "oauth" ? iB("success", V)("> ") : "  ",
              "Create a long-lived token with your Claude subscription",
            ),
          ),
        wJ.default.createElement(
          y,
          { marginBottom: 1 },
          wJ.default.createElement(M, null, I === "new" ? iB("success", V)("> ") : "  ", "Enter a new API key"),
        ),
        I === "new" &&
          wJ.default.createElement(s4, {
            value: B,
            onChange: Q,
            onSubmit: Z,
            onPaste: Q,
            focus: !0,
            placeholder: "sk-ant… (Create a new key at https://console.anthropic.com/settings/keys)",
            mask: "*",
            columns: F.columns,
            cursorOffset: J,
            onChangeCursorOffset: X,
            showCursor: !0,
          }),
      ),
      wJ.default.createElement(
        y,
        { marginLeft: 3 },
        wJ.default.createElement(M, { dimColor: !0 }, "↑/↓ to select · Enter to continue"),
      ),
    )
  );
}
var HS = A1(V1(), 1);
function MDB({
  currentWorkflowInstallStep: A,
  secretExists: B,
  useExistingSecret: Q,
  secretName: Z,
  skipWorkflow: G = !1,
  selectedWorkflows: Y,
}) {
  let I = G
    ? ["Getting repository information", B && Q ? "Using existing API key secret" : `Setting up ${Z} secret`]
    : [
        "Getting repository information",
        "Creating branch",
        Y.length > 1 ? "Creating workflow files" : "Creating workflow file",
        B && Q ? "Using existing API key secret" : `Setting up ${Z} secret`,
        "Opening pull request page",
      ];
  return HS.default.createElement(
    HS.default.Fragment,
    null,
    HS.default.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
      HS.default.createElement(
        y,
        { flexDirection: "column", marginBottom: 1 },
        HS.default.createElement(M, { bold: !0 }, "Install GitHub App"),
        HS.default.createElement(M, { dimColor: !0 }, "Create GitHub Actions workflow"),
      ),
      I.map((W, J) => {
        let X = "pending";
        if (J < A) X = "completed";
        else if (J === A) X = "in-progress";
        return HS.default.createElement(
          y,
          { key: J },
          HS.default.createElement(
            M,
            { color: X === "completed" ? "success" : X === "in-progress" ? "warning" : void 0 },
            X === "completed" ? "✓ " : "",
            W,
            X === "in-progress" ? "…" : "",
          ),
        );
      }),
    ),
  );
}
var M3 = A1(V1(), 1);
function ODB({ secretExists: A, useExistingSecret: B, secretName: Q, skipWorkflow: Z = !1 }) {
  return M3.default.createElement(
    M3.default.Fragment,
    null,
    M3.default.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
      M3.default.createElement(
        y,
        { flexDirection: "column", marginBottom: 1 },
        M3.default.createElement(M, { bold: !0 }, "Install GitHub App"),
        M3.default.createElement(M, { dimColor: !0 }, "Success"),
      ),
      !Z && M3.default.createElement(M, { color: "success" }, "✓ GitHub Actions workflow created!"),
      A &&
        B &&
        M3.default.createElement(
          y,
          { marginTop: 1 },
          M3.default.createElement(M, { color: "success" }, "✓ Using existing ANTHROPIC_API_KEY secret"),
        ),
      (!A || !B) &&
        M3.default.createElement(
          y,
          { marginTop: 1 },
          M3.default.createElement(M, { color: "success" }, "✓ API key saved as ", Q, " secret"),
        ),
      M3.default.createElement(y, { marginTop: 1 }, M3.default.createElement(M, null, "Next steps:")),
      Z
        ? M3.default.createElement(
            M3.default.Fragment,
            null,
            M3.default.createElement(M, null, "1. Install the Claude GitHub App if you haven't already"),
            M3.default.createElement(M, null, "2. Your workflow file was kept unchanged"),
            M3.default.createElement(M, null, "3. API key is configured and ready to use"),
          )
        : M3.default.createElement(
            M3.default.Fragment,
            null,
            M3.default.createElement(M, null, "1. A pre-filled PR page has been created"),
            M3.default.createElement(M, null, "2. Install the Claude GitHub App if you haven't already"),
            M3.default.createElement(M, null, "3. Merge the PR to enable Claude PR assistance"),
          ),
    ),
    M3.default.createElement(
      y,
      { marginLeft: 3 },
      M3.default.createElement(M, { dimColor: !0 }, "Press any key to exit"),
    ),
  );
}
var DW = A1(V1(), 1);
function RDB({ error: A, errorReason: B, errorInstructions: Q }) {
  return DW.default.createElement(
    DW.default.Fragment,
    null,
    DW.default.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
      DW.default.createElement(
        y,
        { flexDirection: "column", marginBottom: 1 },
        DW.default.createElement(M, { bold: !0 }, "Install GitHub App"),
      ),
      DW.default.createElement(M, { color: "error" }, "Error: ", A),
      B && DW.default.createElement(y, { marginTop: 1 }, DW.default.createElement(M, { dimColor: !0 }, "Reason: ", B)),
      Q &&
        Q.length > 0 &&
        DW.default.createElement(
          y,
          { flexDirection: "column", marginTop: 1 },
          DW.default.createElement(M, { dimColor: !0 }, "How to fix:"),
          Q.map((Z, G) =>
            DW.default.createElement(
              y,
              { key: G, marginLeft: 2 },
              DW.default.createElement(M, { dimColor: !0 }, "• "),
              DW.default.createElement(M, null, Z),
            ),
          ),
        ),
      DW.default.createElement(
        y,
        { marginTop: 1 },
        DW.default.createElement(
          M,
          { dimColor: !0 },
          "For manual setup instructions, see:",
          " ",
          DW.default.createElement(M, { color: "claude" }, yO),
        ),
      ),
    ),
    DW.default.createElement(
      y,
      { marginLeft: 3 },
      DW.default.createElement(M, { dimColor: !0 }, "Press any key to exit"),
    ),
  );
}
var lH = A1(V1(), 1);
function TDB({ repoName: A, onSelectAction: B }) {
  return lH.default.createElement(
    y,
    { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
    lH.default.createElement(
      y,
      { flexDirection: "column", marginBottom: 1 },
      lH.default.createElement(M, { bold: !0 }, "Existing Workflow Found"),
      lH.default.createElement(M, { dimColor: !0 }, "Repository: ", A),
    ),
    lH.default.createElement(
      y,
      { flexDirection: "column", marginBottom: 1 },
      lH.default.createElement(
        M,
        null,
        "A Claude workflow file already exists at",
        " ",
        lH.default.createElement(M, { color: "claude" }, ".github/workflows/claude.yml"),
      ),
      lH.default.createElement(M, { dimColor: !0 }, "What would you like to do?"),
    ),
    lH.default.createElement(
      y,
      { flexDirection: "column" },
      lH.default.createElement(xA, {
        options: [
          { label: "Update workflow file with latest version", value: "update" },
          { label: "Skip workflow update (configure secrets only)", value: "skip" },
          { label: "Exit without making changes", value: "exit" },
        ],
        onChange: (Y) => {
          B(Y);
        },
        onCancel: () => {
          B("exit");
        },
      }),
    ),
    lH.default.createElement(
      y,
      { marginTop: 1 },
      lH.default.createElement(
        M,
        { dimColor: !0 },
        "View the latest workflow template at:",
        " ",
        lH.default.createElement(
          M,
          { color: "claude" },
          "https://github.com/anthropics/claude-code-action/blob/main/examples/claude.yml",
        ),
      ),
    ),
  );
}
var vX = A1(V1(), 1);
function PDB({ warnings: A, onContinue: B }) {
  return (
    s0((Q, Z) => {
      if (Z.return) B();
    }),
    vX.default.createElement(
      vX.default.Fragment,
      null,
      vX.default.createElement(
        y,
        { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1 },
        vX.default.createElement(
          y,
          { flexDirection: "column", marginBottom: 1 },
          vX.default.createElement(M, { bold: !0 }, t0.warning, " Setup Warnings"),
          vX.default.createElement(M, { dimColor: !0 }, "We found some potential issues, but you can continue anyway"),
        ),
        A.map((Q, Z) =>
          vX.default.createElement(
            y,
            { key: Z, flexDirection: "column", marginBottom: 1 },
            vX.default.createElement(M, { color: "warning", bold: !0 }, Q.title),
            vX.default.createElement(M, null, Q.message),
            Q.instructions.length > 0 &&
              vX.default.createElement(
                y,
                { flexDirection: "column", marginLeft: 2, marginTop: 1 },
                Q.instructions.map((G, Y) => vX.default.createElement(M, { key: Y, dimColor: !0 }, "• ", G)),
              ),
          ),
        ),
        vX.default.createElement(
          y,
          { marginTop: 1 },
          vX.default.createElement(
            M,
            { bold: !0, color: "permission" },
            "Press Enter to continue anyway, or Ctrl+C to exit and fix issues",
          ),
        ),
        vX.default.createElement(
          y,
          { marginTop: 1 },
          vX.default.createElement(
            M,
            { dimColor: !0 },
            "You can also try the manual setup steps if needed:",
            " ",
            vX.default.createElement(M, { color: "claude" }, yO),
          ),
        ),
      ),
    )
  );
}
var e3 = A1(V1(), 1);
function jDB({ onSubmit: A, defaultSelections: B }) {
  let [Q, Z] = e3.useState(new Set(B)),
    [G, Y] = e3.useState(0),
    [I, W] = e3.useState(!1),
    J = [
      { value: "claude", label: "@Claude Code", description: "Tag @claude in issues and PR comments" },
      { value: "claude-review", label: "Claude Code Review", description: "Automated code review on new PRs" },
    ];
  return (
    s0((X, F) => {
      if (F.upArrow) (Y((V) => (V > 0 ? V - 1 : J.length - 1)), W(!1));
      else if (F.downArrow) (Y((V) => (V < J.length - 1 ? V + 1 : 0)), W(!1));
      else if (X === " ") {
        let V = J[G]?.value;
        if (V)
          Z((K) => {
            let H = new Set(K);
            if (H.has(V)) H.delete(V);
            else H.add(V);
            return H;
          });
      } else if (F.return)
        if (Q.size === 0) W(!0);
        else A(Array.from(Q));
    }),
    e3.default.createElement(
      e3.default.Fragment,
      null,
      e3.default.createElement(
        y,
        { flexDirection: "column", borderStyle: "round", borderDimColor: !0, paddingX: 1, width: "100%" },
        e3.default.createElement(
          y,
          { flexDirection: "column", marginBottom: 1 },
          e3.default.createElement(M, { bold: !0 }, "Select GitHub workflows to install"),
          e3.default.createElement(
            M,
            { dimColor: !0 },
            "We'll create a workflow file in your repository for each one you select.",
          ),
          e3.default.createElement(
            y,
            { marginTop: 1 },
            e3.default.createElement(
              M,
              { dimColor: !0 },
              "More workflow examples (issue triage, CI fixes, etc.) at:",
              " ",
              e3.default.createElement(
                _01,
                { url: "https://github.com/anthropics/claude-code-action/blob/main/examples/" },
                "https://github.com/anthropics/claude-code-action/blob/main/examples/",
              ),
            ),
          ),
        ),
        e3.default.createElement(
          y,
          { flexDirection: "column", paddingX: 1 },
          J.map((X, F) => {
            let V = Q.has(X.value),
              K = F === G;
            return e3.default.createElement(
              y,
              { key: X.value, flexDirection: "row", marginBottom: F < J.length - 1 ? 1 : 0 },
              e3.default.createElement(
                y,
                { marginRight: 1, minWidth: 2 },
                e3.default.createElement(M, { bold: K }, V ? "✓" : " "),
              ),
              e3.default.createElement(
                y,
                { flexDirection: "column" },
                e3.default.createElement(M, { bold: K }, X.label),
                e3.default.createElement(M, { dimColor: !0 }, X.description),
              ),
            );
          }),
        ),
      ),
      e3.default.createElement(
        y,
        { marginLeft: 2 },
        e3.default.createElement(M, { dimColor: !0 }, "↑↓ Navigate · Space to toggle · Enter to confirm"),
      ),
      I &&
        e3.default.createElement(
          y,
          { marginLeft: 1 },
          e3.default.createElement(M, { color: "error" }, "You must select at least one workflow to continue"),
        ),
    )
  );
}
async function N75(A, B, Q, Z, G, Y, I) {
  let W = await B2("VERSION_STRING", ["api", `repos/${A}/contents/${Q}`, "--jq", ".sha"]),
    J = null;
  if (W.code === 0) J = W.stdout.trim();
  let X = Z;
  if (G === "CLAUDE_CODE_OAUTH_TOKEN")
    X = Z.replace(
      /anthropic_api_key: \$\{\{ secrets\.ANTHROPIC_API_KEY \}\}/g,
      "claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}",
    );
  else if (G !== "ANTHROPIC_API_KEY")
    X = Z.replace(
      /anthropic_api_key: \$\{\{ secrets\.ANTHROPIC_API_KEY \}\}/g,
      `anthropic_api_key: \${{ secrets.${G} }}`,
    );
  let F = Buffer.from(X).toString("base64"),
    V = [
      "api",
      "--method",
      "PUT",
      `repos/${A}/contents/${Q}`,
      "-f",
      `message=${J ? `"Update ${Y}"` : `"${Y}"`}`,
      "-f",
      `content=${F}`,
      "-f",
      `branch=${B}`,
    ];
  if (J) V.push("-f", `sha=${J}`);
  let K = await B2("VERSION_STRING", V);
  if (K.code !== 0) {
    if (K.stderr.includes("422") && K.stderr.includes("sha"))
      throw (
        Y1("tengu_setup_github_actions_failed", { reason: "failed_to_create_workflow_file", exit_code: K.code, ...I }),
        new Error(
          `Failed to create workflow file ${Q}: A Claude workflow file already exists in this repository. Please remove it first or update it manually.`,
        )
      );
    Y1("tengu_setup_github_actions_failed", { reason: "failed_to_create_workflow_file", exit_code: K.code, ...I });
    let H =
      `

Need help? Common issues:
` +
      `• Permission denied → Run: VERSION_STRING auth refresh -h github.com -s repo,workflow
` +
      `• Not authorized → Ensure you have admin access to the repository
` +
      "• For manual setup → Visit: https://github.com/anthropics/claude-code-action";
    throw new Error(`Failed to create workflow file ${Q}: ${K.stderr}${H}`);
  }
}
async function SDB(A, B, Q, Z, G = !1, Y, I, W, J = !1) {
  try {
    Y1("tengu_setup_github_actions_started", {
      skip_workflow: G,
      has_api_key: !!B,
      using_default_secret_name: Q === "ANTHROPIC_API_KEY",
      selected_claude_workflow: Y.includes("claude"),
      selected_claude_review_workflow: Y.includes("claude-review"),
      ...W,
    });
    let X = await B2("VERSION_STRING", ["api", `repos/${A}`, "--jq", ".id"]);
    if (X.code !== 0)
      throw (
        Y1("tengu_setup_github_actions_failed", { reason: "repo_not_found", exit_code: X.code, ...W }),
        new Error(`Failed to access repository ${A}`)
      );
    let F = await B2("VERSION_STRING", ["api", `repos/${A}`, "--jq", ".default_branch"]);
    if (F.code !== 0)
      throw (
        Y1("tengu_setup_github_actions_failed", { reason: "failed_to_get_default_branch", exit_code: F.code, ...W }),
        new Error(`Failed to get default branch: ${F.stderr}`)
      );
    let V = F.stdout.trim(),
      K = await B2("VERSION_STRING", ["api", `repos/${A}/git/ref/heads/${V}`, "--jq", ".object.sha"]);
    if (K.code !== 0)
      throw (
        Y1("tengu_setup_github_actions_failed", { reason: "failed_to_get_branch_sha", exit_code: K.code, ...W }),
        new Error(`Failed to get branch SHA: ${K.stderr}`)
      );
    let H = K.stdout.trim(),
      z = null;
    if (!G) {
      (Z(), (z = `add-claude-github-actions-${Date.now()}`));
      let D = await B2("VERSION_STRING", [
        "api",
        "--method",
        "POST",
        `repos/${A}/git/refs`,
        "-f",
        `ref=refs/heads/${z}`,
        "-f",
        `sha=${H}`,
      ]);
      if (D.code !== 0)
        throw (
          Y1("tengu_setup_github_actions_failed", { reason: "failed_to_create_branch", exit_code: D.code, ...W }),
          new Error(`Failed to create branch: ${D.stderr}`)
        );
      Z();
      let C = [];
      if (Y.includes("claude"))
        C.push({
          path: ".github/workflows/claude.yml",
          content: J ? wDB : CDB,
          message: "Claude PR Assistant workflow",
        });
      if (Y.includes("claude-review"))
        C.push({
          path: ".github/workflows/claude-code-review.yml",
          content: J ? qDB : $DB,
          message: "Claude Code Review workflow",
        });
      for (let w of C) await N75(A, z, w.path, w.content, Q, w.message, W);
    }
    if ((Z(), B)) {
      let D = await B2("VERSION_STRING", ["secret", "set", Q, "--body", B, "--repo", A]);
      if (D.code !== 0) {
        Y1("tengu_setup_github_actions_failed", { reason: "failed_to_set_api_key_secret", exit_code: D.code, ...W });
        let C =
          `

Need help? Common issues:
` +
          `• Permission denied → Run: VERSION_STRING auth refresh -h github.com -s repo
` +
          `• Not authorized → Ensure you have admin access to the repository
` +
          "• For manual setup → Visit: https://github.com/anthropics/claude-code-action";
        throw new Error(`Failed to set API key secret: ${D.stderr || "Unknown error"}${C}`);
      }
    }
    if (!G && z) {
      Z();
      let D = `https://github.com/${A}/compare/${V}...${z}?quick_pull=1&title=${encodeURIComponent(ADD_GITHUB_WORKFLOW)}&body=${encodeURIComponent(UDB)}`;
      await N$(D);
    }
    (Y1("tengu_setup_github_actions_completed", {
      skip_workflow: G,
      has_api_key: !!B,
      auth_type: I,
      using_default_secret_name: Q === "ANTHROPIC_API_KEY",
      selected_claude_workflow: Y.includes("claude"),
      selected_claude_review_workflow: Y.includes("claude-review"),
      ...W,
    }),
      TA({ ...H0(), githubActionSetupCount: (H0().githubActionSetupCount ?? 0) + 1 }));
  } catch (X) {
    if (!X || !(X instanceof Error) || !X.message.includes("Failed to"))
      Y1("tengu_setup_github_actions_failed", { reason: "unexpected_error", ...W });
    if (X instanceof Error) U1(X, p7A);
    throw X;
  }
}
var eQ = A1(V1(), 1);
var PASTE_CODE_PROMPT_2 = "Paste code here if prompted > ";
function kDB({ onSuccess: A, onCancel: B }) {
  let [Q, Z] = eQ.useState({ state: "starting" }),
    [G] = eQ.useState(() => new cI1()),
    [Y, I] = eQ.useState(""),
    [W, J] = eQ.useState(0),
    [X, F] = eQ.useState(!1),
    [V] = eQ.useState(() => new NI1()),
    K = eQ.useRef(new Set()),
    H = IB(),
    z = Math.max(50, H.columns - PASTE_CODE_PROMPT_2.length - 4);
  s0((E, L) => {
    if (Q.state === "error")
      if (L.return && Q.toRetry) (I(""), J(0), Z({ state: "about_to_retry", nextState: Q.toRetry }));
      else B();
  });
  async function D(E, L) {
    try {
      let [O, R] = E.split("#");
      if (!O || !R) {
        Z({
          state: "error",
          message: "Invalid code. Please make sure the full code was copied",
          toRetry: { state: "waiting_for_login", url: L },
        });
        return;
      }
      (Y1("tengu_oauth_manual_entry", {}), G.handleManualAuthCodeInput({ authorizationCode: O, state: R }));
    } catch (O) {
      (U1(O instanceof Error ? O : new Error(String(O)), c7A),
        Z({ state: "error", message: O.message, toRetry: { state: "waiting_for_login", url: L } }));
    }
  }
  let C = eQ.useCallback(async () => {
    (K.current.forEach((E) => clearTimeout(E)), K.current.clear());
    try {
      let E = await G.startOAuthFlow(
        async (R) => {
          Z({ state: "waiting_for_login", url: R });
          let P = setTimeout(() => F(!0), 3000);
          K.current.add(P);
        },
        { loginWithClaudeAi: !0, inferenceOnly: !0, expiresIn: 31536000 },
      );
      (await n7(), V.reset(), Z({ state: "processing" }));
      let L = mZ1(E);
      if (L.warning) Y1("tengu_oauth_storage_warning", { warning: L.warning });
      let O = setTimeout(() => {
        Z({ state: "success", token: E.accessToken });
        let R = setTimeout(() => {
          A(E.accessToken);
        }, 1000);
        K.current.add(R);
      }, 100);
      K.current.add(O);
    } catch (E) {
      let L = E.message;
      (await n7(),
        V.reset(),
        Z({ state: "error", message: L, toRetry: { state: "starting" } }),
        U1(E instanceof Error ? E : new Error(String(E)), l7A),
        Y1("tengu_oauth_error", { error: L }));
    }
  }, [G, A, V]);
  (eQ.useEffect(() => {
    if (Q.state === "starting") C();
  }, [Q.state, C]),
    eQ.useEffect(() => {
      if (Q.state === "about_to_retry") {
        (n7(), V.reset());
        let E = setTimeout(() => {
          if (Q.nextState.state === "waiting_for_login") F(!0);
          else F(!1);
          Z(Q.nextState);
        }, 500);
        K.current.add(E);
      }
    }, [Q, V]),
    eQ.useEffect(() => {
      let E = {};
      if (Q.state !== "success" && Q.state !== "starting" && Q.state !== "processing")
        E.header = eQ.default.createElement(
          y,
          { key: "header", flexDirection: "column", gap: 1, paddingBottom: 1 },
          eQ.default.createElement(M, { bold: !0 }, "Create Authentication Token"),
          eQ.default.createElement(M, { dimColor: !0 }, "Creating a long-lived token for GitHub Actions"),
        );
      if (Q.state === "waiting_for_login" && X)
        E.urlToCopy = eQ.default.createElement(
          y,
          { flexDirection: "column", key: "urlToCopy", gap: 1, paddingBottom: 1 },
          eQ.default.createElement(
            y,
            { paddingX: 1 },
            eQ.default.createElement(M, { dimColor: !0 }, "Browser didn't open? Use the url below to sign in:"),
          ),
          eQ.default.createElement(y, { width: 1000 }, eQ.default.createElement(M, { dimColor: !0 }, Q.url)),
        );
      V.renderStatic(E);
    }, [V, Q, X]),
    eQ.useEffect(() => {
      let E = K.current;
      return () => {
        (G.cleanup(), E.forEach((L) => clearTimeout(L)), E.clear());
      };
    }, [G]));
  function w() {
    switch (Q.state) {
      case "starting":
        return eQ.default.createElement(
          y,
          null,
          eQ.default.createElement(u6, null),
          eQ.default.createElement(M, null, "Starting authentication…"),
        );
      case "waiting_for_login":
        return eQ.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          !X &&
            eQ.default.createElement(
              y,
              null,
              eQ.default.createElement(u6, null),
              eQ.default.createElement(M, null, "Opening browser to sign in with your Claude account…"),
            ),
          X &&
            eQ.default.createElement(
              y,
              null,
              eQ.default.createElement(M, null, PASTE_CODE_PROMPT_2),
              eQ.default.createElement(s4, {
                value: Y,
                onChange: I,
                onSubmit: (E) => D(E, Q.url),
                cursorOffset: W,
                onChangeCursorOffset: J,
                columns: z,
              }),
            ),
        );
      case "processing":
        return eQ.default.createElement(
          y,
          null,
          eQ.default.createElement(u6, null),
          eQ.default.createElement(M, null, "Processing authentication…"),
        );
      case "success":
        return eQ.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          eQ.default.createElement(M, { color: "success" }, "✓ Authentication token created successfully!"),
          eQ.default.createElement(M, { dimColor: !0 }, "Using token for GitHub Actions setup…"),
        );
      case "error":
        return eQ.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          eQ.default.createElement(M, { color: "error" }, "OAuth error: ", Q.message),
          Q.toRetry
            ? eQ.default.createElement(M, { dimColor: !0 }, "Press Enter to try again, or any other key to cancel")
            : eQ.default.createElement(M, { dimColor: !0 }, "Press any key to return to API key selection"),
        );
      case "about_to_retry":
        return eQ.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          eQ.default.createElement(M, { color: "permission" }, "Retrying…"),
        );
      default:
        return null;
    }
  }
  return eQ.default.createElement(
    y,
    { flexDirection: "column", gap: 1 },
    Q.state === "starting" &&
      eQ.default.createElement(
        y,
        { flexDirection: "column", gap: 1, paddingBottom: 1 },
        eQ.default.createElement(M, { bold: !0 }, "Create Authentication Token"),
        eQ.default.createElement(M, { dimColor: !0 }, "Creating a long-lived token for GitHub Actions"),
      ),
    eQ.default.createElement(y, { paddingLeft: 1, flexDirection: "column", gap: 1 }, w()),
  );
}
var L75 = {
  step: "check-VERSION_STRING",
  selectedRepoName: "",
  currentRepo: "",
  useCurrentRepo: !1,
  apiKeyOrOAuthToken: "",
  useExistingKey: !0,
  currentWorkflowInstallStep: 0,
  warnings: [],
  secretExists: !1,
  secretName: "ANTHROPIC_API_KEY",
  useExistingSecret: !0,
  workflowExists: !1,
  selectedWorkflows: ["claude", "claude-review"],
  selectedApiKeyOption: "new",
  authType: "api_key",
};
function M75(A) {
  let [B] = AZ.useState(() => oJ(!1)),
    [Q, Z] = AZ.useState({
      ...L75,
      useExistingKey: !!B,
      selectedApiKeyOption: B ? "existing" : ED() ? "oauth" : "new",
    }),
    G = xDB("tengu_gha_v1", !1);
  (Z2(),
    AZ.default.useEffect(() => {
      Y1("tengu_install_github_app_started", {});
    }, []));
  let Y = AZ.useCallback(async () => {
    let _ = [];
    try {
      Jh1("VERSION_STRING --version", { stdio: "ignore" });
    } catch {
      _.push({
        title: "GitHub CLI not found",
        message: "GitHub CLI (VERSION_STRING) does not appear to be installed or accessible.",
        instructions: [
          "Install GitHub CLI from https://cli.github.com/",
          "macOS: brew install VERSION_STRING",
          "Windows: winget install --id GitHub.cli",
          "Linux: See installation instructions at https://github.com/cli/cli#installation",
        ],
      });
    }
    try {
      let d = Jh1("VERSION_STRING auth status -a", { encoding: "utf8" }).match(/Token scopes:.*$/m);
      if (d) {
        let u = d[0],
          o = [];
        if (!u.includes("repo")) o.push("repo");
        if (!u.includes("workflow")) o.push("workflow");
        if (o.length > 0) {
          Z((m) => ({
            ...m,
            step: "error",
            error: `GitHub CLI is missing required permissions: ${o.join(", ")}.`,
            errorReason: "Missing required scopes",
            errorInstructions: [
              `Your GitHub CLI authentication is missing the "${o.join('" and "')}" scope${o.length > 1 ? "s" : ""} needed to manage GitHub Actions and secrets.`,
              "",
              "To fix this, run:",
              "  VERSION_STRING auth refresh -h github.com -s repo,workflow",
              "",
              "This will add the necessary permissions to manage workflows and secrets.",
            ],
          }));
          return;
        }
      }
    } catch {
      _.push({
        title: "GitHub CLI not authenticated",
        message: "GitHub CLI does not appear to be authenticated.",
        instructions: [
          "Run: VERSION_STRING auth login",
          "Follow the prompts to authenticate with GitHub",
          "Or set up authentication using environment variables or other methods",
        ],
      });
    }
    let b = "";
    try {
      Jh1("git rev-parse --is-inside-work-tree", { stdio: "ignore" });
      let d = Jh1("git remote get-url origin", { encoding: "utf8" })
        .trim()
        .match(/github\.com[:/]([^/]+\/[^/]+)(\.git)?$/);
      if (d) b = d[1]?.replace(/\.git$/, "") || "";
    } catch {}
    (Y1("tengu_install_github_app_step_completed", { step: "check-VERSION_STRING" }),
      Z((S) => ({
        ...S,
        warnings: _,
        currentRepo: b,
        selectedRepoName: b,
        useCurrentRepo: !!b,
        step: _.length > 0 ? "warnings" : "choose-repo",
      })));
  }, []);
  AZ.default.useEffect(() => {
    if (Q.step === "check-VERSION_STRING") Y();
  }, [Q.step, Y]);
  let I = AZ.useCallback(
    async (_, b) => {
      Z((S) => ({ ...S, step: "creating", currentWorkflowInstallStep: 0 }));
      try {
        (await SDB(
          Q.selectedRepoName,
          _,
          b,
          () => {
            Z((S) => ({ ...S, currentWorkflowInstallStep: S.currentWorkflowInstallStep + 1 }));
          },
          Q.workflowAction === "skip",
          Q.selectedWorkflows,
          Q.authType,
          { useCurrentRepo: Q.useCurrentRepo, workflowExists: Q.workflowExists, secretExists: Q.secretExists },
          G,
        ),
          Y1("tengu_install_github_app_step_completed", { step: "creating" }),
          Z((S) => ({ ...S, step: "success" })));
      } catch (S) {
        let d = S instanceof Error ? S.message : "Failed to set up GitHub Actions";
        if (d.includes("workflow file already exists"))
          (Y1("tengu_install_github_app_error", { reason: "workflow_file_exists" }),
            Z((u) => ({
              ...u,
              step: "error",
              error: "A Claude workflow file already exists in this repository.",
              errorReason: "Workflow file conflict",
              errorInstructions: [
                "The file .github/workflows/claude.yml already exists",
                "You can either:",
                "  1. Delete the existing file and run this command again",
                "  2. Update the existing file manually using the template from:",
                `     ${yO}`,
              ],
            })));
        else
          (Y1("tengu_install_github_app_error", { reason: "setup_github_actions_failed" }),
            Z((u) => ({
              ...u,
              step: "error",
              error: d,
              errorReason: "GitHub Actions setup failed",
              errorInstructions: [],
            })));
      }
    },
    [
      Q.selectedRepoName,
      Q.workflowAction,
      Q.selectedWorkflows,
      Q.useCurrentRepo,
      Q.workflowExists,
      Q.secretExists,
      Q.authType,
      G,
    ],
  );
  async function W() {
    await N$("https://github.com/apps/claude");
  }
  async function J(_) {
    try {
      let b = await B2("VERSION_STRING", ["api", `repos/${_}`, "--jq", ".permissions.admin"]);
      if (b.code === 0) return { hasAccess: b.stdout.trim() === "true" };
      if (b.stderr.includes("404") || b.stderr.includes("Not Found"))
        return { hasAccess: !1, error: "repository_not_found" };
      return { hasAccess: !1 };
    } catch {
      return { hasAccess: !1 };
    }
  }
  async function X(_) {
    return (await B2("VERSION_STRING", ["api", `repos/${_}/contents/.github/workflows/claude.yml`, "--jq", ".sha"])).code === 0;
  }
  async function F() {
    let _ = await B2("VERSION_STRING", ["secret", "list", "--app", "actions", "--repo", Q.selectedRepoName]);
    if (_.code === 0)
      if (
        _.stdout
          .split(
            `
`,
          )
          .some((d) => {
            return /^ANTHROPIC_API_KEY\s+/.test(d);
          })
      )
        Z((d) => ({ ...d, secretExists: !0, step: "check-existing-secret" }));
      else if (B) (Z((d) => ({ ...d, apiKeyOrOAuthToken: B, useExistingKey: !0 })), await I(B, Q.secretName));
      else Z((d) => ({ ...d, step: "api-key" }));
    else if (B) (Z((b) => ({ ...b, apiKeyOrOAuthToken: B, useExistingKey: !0 })), await I(B, Q.secretName));
    else Z((b) => ({ ...b, step: "api-key" }));
  }
  let V = async () => {
      if (Q.step === "warnings")
        (Y1("tengu_install_github_app_step_completed", { step: "warnings" }),
          Z((_) => ({ ..._, step: "install-app" })),
          setTimeout(() => {
            W();
          }, 0));
      else if (Q.step === "choose-repo") {
        let _ = Q.useCurrentRepo ? Q.currentRepo : Q.selectedRepoName;
        if (!_.trim()) return;
        let b = [];
        if (_.includes("github.com")) {
          let u = _.match(/github\.com[:/]([^/]+\/[^/]+)(\.git)?$/);
          if (!u)
            b.push({
              title: "Invalid GitHub URL format",
              message: "The repository URL format appears to be invalid.",
              instructions: [
                "Use format: owner/repo or https://github.com/owner/repo",
                "Example: anthropics/claude-cli",
              ],
            });
          else _ = u[1]?.replace(/\.git$/, "") || "";
        }
        if (!_.includes("/"))
          b.push({
            title: "Repository format warning",
            message: 'Repository should be in format "owner/repo"',
            instructions: ["Use format: owner/repo", "Example: anthropics/claude-cli"],
          });
        let S = await J(_);
        if (S.error === "repository_not_found")
          b.push({
            title: "Repository not found",
            message: `Repository ${_} was not found or you don't have access.`,
            instructions: [
              `Check that the repository name is correct: ${_}`,
              "Ensure you have access to this repository",
              'For private repositories, make sure your GitHub token has the "repo" scope',
              "You can add the repo scope with: VERSION_STRING auth refresh -h github.com -s repo,workflow",
            ],
          });
        else if (!S.hasAccess)
          b.push({
            title: "Admin permissions required",
            message: `You might need admin permissions on ${_} to set up GitHub Actions.`,
            instructions: [
              "Repository admins can install GitHub Apps and set secrets",
              "Ask a repository admin to run this command if setup fails",
              "Alternatively, you can use the manual setup instructions",
            ],
          });
        let d = await X(_);
        if (b.length > 0) {
          let u = [...Q.warnings, ...b];
          Z((o) => ({ ...o, selectedRepoName: _, workflowExists: d, warnings: u, step: "warnings" }));
        } else
          (Y1("tengu_install_github_app_step_completed", { step: "choose-repo" }),
            Z((u) => ({ ...u, selectedRepoName: _, workflowExists: d, step: "install-app" })),
            setTimeout(() => {
              W();
            }, 0));
      } else if (Q.step === "install-app")
        if ((Y1("tengu_install_github_app_step_completed", { step: "install-app" }), Q.workflowExists))
          Z((_) => ({ ..._, step: "check-existing-workflow" }));
        else Z((_) => ({ ..._, step: "select-workflows" }));
      else if (Q.step === "check-existing-workflow") return;
      else if (Q.step === "select-workflows") return;
      else if (Q.step === "check-existing-secret")
        if ((Y1("tengu_install_github_app_step_completed", { step: "check-existing-secret" }), Q.useExistingSecret))
          await I(null, Q.secretName);
        else await I(Q.apiKeyOrOAuthToken, Q.secretName);
      else if (Q.step === "api-key") {
        if (Q.selectedApiKeyOption === "oauth") return;
        let _ = Q.selectedApiKeyOption === "existing" ? B : Q.apiKeyOrOAuthToken;
        if (!_) {
          (Y1("tengu_install_github_app_error", { reason: "api_key_missing" }),
            Z((S) => ({ ...S, step: "error", error: "API key is required" })));
          return;
        }
        Z((S) => ({ ...S, apiKeyOrOAuthToken: _, useExistingKey: Q.selectedApiKeyOption === "existing" }));
        let b = await B2("VERSION_STRING", ["secret", "list", "--app", "actions", "--repo", Q.selectedRepoName]);
        if (b.code === 0)
          if (
            b.stdout
              .split(
                `
`,
              )
              .some((u) => {
                return /^ANTHROPIC_API_KEY\s+/.test(u);
              })
          )
            (Y1("tengu_install_github_app_step_completed", { step: "api-key" }),
              Z((u) => ({ ...u, secretExists: !0, step: "check-existing-secret" })));
          else (Y1("tengu_install_github_app_step_completed", { step: "api-key" }), await I(_, Q.secretName));
        else (Y1("tengu_install_github_app_step_completed", { step: "api-key" }), await I(_, Q.secretName));
      }
    },
    K = (_) => {
      Z((b) => ({ ...b, selectedRepoName: _ }));
    },
    H = (_) => {
      Z((b) => ({ ...b, apiKeyOrOAuthToken: _ }));
    },
    z = (_) => {
      Z((b) => ({ ...b, selectedApiKeyOption: _ }));
    },
    D = AZ.useCallback(() => {
      (Y1("tengu_install_github_app_step_completed", { step: "api-key" }), Z((_) => ({ ..._, step: "oauth-flow" })));
    }, []),
    C = AZ.useCallback(
      (_) => {
        (Y1("tengu_install_github_app_step_completed", { step: "oauth-flow" }),
          Z((b) => ({
            ...b,
            apiKeyOrOAuthToken: _,
            useExistingKey: !1,
            secretName: "CLAUDE_CODE_OAUTH_TOKEN",
            authType: "oauth_token",
          })),
          I(_, "CLAUDE_CODE_OAUTH_TOKEN"));
      },
      [I],
    ),
    w = AZ.useCallback(() => {
      Z((_) => ({ ..._, step: "api-key" }));
    }, []),
    E = (_) => {
      if (_ && !/^[a-zA-Z0-9_]+$/.test(_)) return;
      Z((b) => ({ ...b, secretName: _ }));
    },
    L = (_) => {
      Z((b) => ({ ...b, useCurrentRepo: _, selectedRepoName: _ ? b.currentRepo : "" }));
    },
    O = (_) => {
      Z((b) => ({ ...b, useExistingKey: _ }));
    },
    R = (_) => {
      Z((b) => ({ ...b, useExistingSecret: _, secretName: _ ? "ANTHROPIC_API_KEY" : "" }));
    },
    P = async (_) => {
      if (_ === "exit") {
        A.onDone("Installation cancelled by user");
        return;
      }
      if (
        (Y1("tengu_install_github_app_step_completed", { step: "check-existing-workflow" }),
        Z((b) => ({ ...b, workflowAction: _ })),
        _ === "skip" || _ === "update")
      )
        if (B) await F();
        else Z((b) => ({ ...b, step: "api-key" }));
    };
  switch (
    (s0(() => {
      if (Q.step === "success" || Q.step === "error") {
        if (Q.step === "success") Y1("tengu_install_github_app_completed", {});
        A.onDone(
          Q.step === "success"
            ? "GitHub Actions setup complete!"
            : Q.error
              ? `Couldn't install GitHub App: ${Q.error}
For manual setup instructions, see: ${yO}`
              : `GitHub App installation failed
For manual setup instructions, see: ${yO}`,
        );
      }
    }),
    Q.step)
  ) {
    case "check-VERSION_STRING":
      return AZ.default.createElement(HDB, null);
    case "warnings":
      return AZ.default.createElement(PDB, { warnings: Q.warnings, onContinue: V });
    case "choose-repo":
      return AZ.default.createElement(zDB, {
        currentRepo: Q.currentRepo,
        useCurrentRepo: Q.useCurrentRepo,
        repoUrl: Q.selectedRepoName,
        onRepoUrlChange: K,
        onToggleUseCurrentRepo: L,
        onSubmit: V,
      });
    case "install-app":
      return AZ.default.createElement(EDB, { repoUrl: Q.selectedRepoName, onSubmit: V });
    case "check-existing-workflow":
      return AZ.default.createElement(TDB, { repoName: Q.selectedRepoName, onSelectAction: P });
    case "check-existing-secret":
      return AZ.default.createElement(NDB, {
        useExistingSecret: Q.useExistingSecret,
        secretName: Q.secretName,
        onToggleUseExistingSecret: R,
        onSecretNameChange: E,
        onSubmit: V,
      });
    case "api-key":
      return AZ.default.createElement(LDB, {
        existingApiKey: B,
        useExistingKey: Q.useExistingKey,
        apiKeyOrOAuthToken: Q.apiKeyOrOAuthToken,
        onApiKeyChange: H,
        onToggleUseExistingKey: O,
        onSubmit: V,
        onCreateOAuthToken: ED() ? D : void 0,
        selectedOption: Q.selectedApiKeyOption,
        onSelectOption: z,
      });
    case "creating":
      return AZ.default.createElement(MDB, {
        currentWorkflowInstallStep: Q.currentWorkflowInstallStep,
        secretExists: Q.secretExists,
        useExistingSecret: Q.useExistingSecret,
        secretName: Q.secretName,
        skipWorkflow: Q.workflowAction === "skip",
        selectedWorkflows: Q.selectedWorkflows,
      });
    case "success":
      return AZ.default.createElement(ODB, {
        secretExists: Q.secretExists,
        useExistingSecret: Q.useExistingSecret,
        secretName: Q.secretName,
        skipWorkflow: Q.workflowAction === "skip",
      });
    case "error":
      return AZ.default.createElement(RDB, {
        error: Q.error,
        errorReason: Q.errorReason,
        errorInstructions: Q.errorInstructions,
      });
    case "select-workflows":
      return AZ.default.createElement(jDB, {
        defaultSelections: Q.selectedWorkflows,
        onSubmit: (_) => {
          if (
            (Y1("tengu_install_github_app_step_completed", { step: "select-workflows" }),
            Z((b) => ({ ...b, selectedWorkflows: _ })),
            B)
          )
            F();
          else Z((b) => ({ ...b, step: "api-key" }));
        },
      });
    case "oauth-flow":
      return AZ.default.createElement(kDB, { onSuccess: C, onCancel: w });
  }
}
var O75 = {
    type: "local-jsx",
    name: "install-github-app",
    description: "Set up Claude GitHub Actions for a repository",
    isEnabled: () => !process.env.DISABLE_INSTALL_GITHUB_APP_COMMAND && !le(),
    isHidden: !1,
    async call(A) {
      return AZ.default.createElement(M75, { onDone: A });
    },
    userFacingName() {
      return "install-github-app";
    },
  },
  _DB = O75;
var vDB = A1(V1(), 1);
var hB = A1(V1(), 1);
function jA1({ onPress: A }) {
  return (
    s0((B, Q) => {
      if (Q.return) A();
      else if (Q.escape) G5(1);
    }),
    hB.default.createElement(
      M,
      null,
      "Press ",
      hB.default.createElement(M, { bold: !0 }, "Enter"),
      " to continue or ",
      hB.default.createElement(M, { bold: !0 }, "Esc"),
      " to exit",
    )
  );
}
function SA1() {
  let [A, B] = hB.useState("intro"),
    [Q, Z] = hB.useState(""),
    [G, Y] = hB.useState("");
  if (
    (Z2(() => {
      (bv("canceled", "user_exit"), G5(1));
    }),
    hB.useEffect(() => {
      bv("start");
    }, []),
    hB.useEffect(() => {
      let I = async () => {
          try {
            if (!LC0()) (Z("Local package creation failed"), B("error"), bv("failure", "environement_setup"));
            switch (await Ud()) {
              case "success": {
                (B("success"), bv("success"));
                break;
              }
              case "in_progress":
                (Z("Update already in progress"), B("error"), bv("failure", "in_progress"));
                break;
              case "install_failed":
                (Z(
                  `Install of ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.anthropic.com/s/claude-code", VERSION: "1.0.119" }.PACKAGE_URL} failed`,
                ),
                  B("error"),
                  bv("failure", "other_failure"));
                break;
            }
          } catch (X) {
            (Z(String(X)), B("error"), bv("failure", "unexpected_error"));
          }
        },
        W = async () => {
          try {
            let X = await fQB();
            (Y(X), B("setup"));
          } catch (X) {
            (Z(String(X)), B("error"));
          }
        },
        J = async () => {
          try {
            if (await hQB()) B("uninstall-success");
            else B("uninstall-failed");
          } catch (X) {
            (Z(String(X)), B("uninstall-failed"));
          }
        };
      switch (A) {
        case "installing":
          I();
          break;
        case "setup-alias":
          W();
          break;
        case "uninstall":
          J();
          break;
        default:
          break;
      }
    }, [A]),
    A === "intro")
  )
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0 }, "Claude Code Local Installer"),
      hB.default.createElement(
        y,
        { flexDirection: "column" },
        hB.default.createElement(M, { dimColor: !0 }, "This will install Claude Code to ~/.claude/local"),
        hB.default.createElement(M, { dimColor: !0 }, "instead of using a global npm installation."),
      ),
      hB.default.createElement(jA1, { onPress: () => B("installing") }),
    );
  if (A === "installing")
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0 }, "Installing Claude Code locally..."),
      hB.default.createElement(
        y,
        { marginY: 1 },
        hB.default.createElement(u6, null),
        hB.default.createElement(M, null, " Installing to ", kv),
      ),
    );
  if (A === "success")
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0, color: "success" }, "✓ Local installation successful!"),
      hB.default.createElement(
        y,
        { marginY: 1 },
        hB.default.createElement(M, null, "Next, let's add an alias for `claude`"),
      ),
      hB.default.createElement(jA1, { onPress: () => B("setup-alias") }),
    );
  if (A === "setup-alias")
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0 }, "Setting up alias for claude..."),
      hB.default.createElement(
        y,
        { marginY: 1 },
        hB.default.createElement(u6, null),
        hB.default.createElement(M, null, " Configuring shell environment"),
      ),
    );
  if (A === "setup")
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0 }, "Alias setup complete"),
      hB.default.createElement(
        y,
        { flexDirection: "column", marginY: 1 },
        hB.default.createElement(M, null, G),
        hB.default.createElement(
          y,
          { marginY: 1 },
          hB.default.createElement(M, null, "Next, we'll remove the globally installed npm package"),
        ),
      ),
      hB.default.createElement(jA1, { onPress: () => B("uninstall") }),
    );
  if (A === "uninstall")
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0 }, "Uninstalling global Claude Code..."),
      hB.default.createElement(
        y,
        { marginY: 1 },
        hB.default.createElement(u6, null),
        hB.default.createElement(M, null, " Removing global npm installation"),
      ),
    );
  if (A === "uninstall-success")
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0, color: "success" }, "✓ Global installation removed successfully!"),
      hB.default.createElement(
        y,
        { flexDirection: "column", marginY: 1 },
        hB.default.createElement(M, null, "Claude Code is now installed locally."),
        hB.default.createElement(
          M,
          null,
          "Please restart your shell, then run",
          " ",
          hB.default.createElement(M, { color: "claude" }, n1.bold("claude")),
          ".",
        ),
        hB.default.createElement(
          y,
          { flexDirection: "row", marginY: 1 },
          hB.default.createElement(u6, null),
          hB.default.createElement(M, null, " Happy Clauding!"),
        ),
      ),
      hB.default.createElement(jA1, { onPress: () => G5(0) }),
    );
  if (A === "uninstall-failed")
    return hB.default.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hB.default.createElement(M, { bold: !0, color: "warning" }, "! Could not remove global installation"),
      hB.default.createElement(
        y,
        { marginY: 1 },
        hB.default.createElement(
          M,
          null,
          "The local installation is installed, but we couldn't remove the global npm package automatically.",
        ),
      ),
      hB.default.createElement(
        y,
        { marginY: 1 },
        hB.default.createElement(
          M,
          null,
          "You can remove it manually later with:",
          `
`,
          n1.bold(
            `npm uninstall -g --force ${{ ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues", PACKAGE_URL: "@anthropic-ai/claude-code", README_URL: "https://docs.anthropic.com/s/claude-code", VERSION: "1.0.119" }.PACKAGE_URL}`,
          ),
        ),
      ),
      hB.default.createElement(jA1, { onPress: () => G5(0) }),
    );
  return hB.default.createElement(
    y,
    { flexDirection: "column", marginY: 1 },
    hB.default.createElement(M, { bold: !0, color: "error" }, "✗ Installation failed"),
    hB.default.createElement(
      y,
      { marginY: 1 },
      hB.default.createElement(M, null, Q || "An unexpected error occurred during installation."),
    ),
    hB.default.createElement(jA1, { onPress: () => G5(1) }),
  );
}
var R75 = {
    type: "local",
    name: "migrate-installer",
    description: "Migrate from global npm installation to local installation",
    isEnabled: () => !process.env.DISABLE_MIGRATE_INSTALLER_COMMAND && !xv() && !BH(),
    isHidden: !1,
    supportsNonInteractive: !1,
    async call() {
      let { waitUntilExit: A } = s6(vDB.default.createElement(SA1, null));
      return (await A(), { type: "text", value: "" });
    },
    userFacingName() {
      return "migrate-installer";
    },
  },
  bDB = R75;
var mL0 = A1(V1(), 1);
var g$ = A1(V1(), 1);
var uZ = A1(V1(), 1);
function xL0({ servers: A, onSelectServer: B, onComplete: Q }) {
  let [Z] = sB(),
    G = Z2();
  if (A.length === 0) return null;
  let Y = lD1(),
    I = A.some((J) => J.client.type === "failed"),
    W = A.map((J) => {
      let X = "",
        F = "",
        V = "";
      if (J.client.type === "connected")
        ((F = iB("success", Z)(t0.tick)), (X = "connected · Enter to view details"), (V = `${F} ${X}`));
      else if (J.client.type === "pending")
        ((F = iB("inactive", Z)(t0.radioOff)), (X = "connecting..."), (V = `${F} ${X}`));
      else if (J.client.type === "needs-auth")
        ((F = iB("warning", Z)(t0.triangleUpOutline)), (X = "disconnected · Enter to login"), (V = `${F} ${X}`));
      else if (J.client.type === "failed")
        ((F = iB("error", Z)(t0.cross)), (X = "failed · Enter to view details"), (V = `${F} ${X}`));
      else ((F = iB("error", Z)(t0.cross)), (X = "failed"), (V = `${F} ${X}`));
      return { label: n1.bold(J.name), value: J.name, description: V, dimDescription: !1 };
    });
  return uZ.default.createElement(
    y,
    { flexDirection: "column" },
    uZ.default.createElement(ab1, null),
    uZ.default.createElement(
      y,
      { flexDirection: "column", paddingX: 1, borderStyle: "round", borderDimColor: !0 },
      uZ.default.createElement(y, { marginBottom: 1 }, uZ.default.createElement(M, { bold: !0 }, "Manage MCP servers")),
      uZ.default.createElement(xA, {
        options: W,
        onChange: (J) => {
          let X = A.find((F) => F.name === J);
          if (X) B(X);
        },
        onCancel: () => Q(),
      }),
      I &&
        uZ.default.createElement(
          y,
          { marginTop: 1 },
          uZ.default.createElement(
            M,
            { dimColor: !0 },
            "※ Tip:",
            " ",
            Y
              ? `Error logs will be shown inline. Log files are also saved in
  ${kO.baseLogs()}`
              : `Run claude --debug to see logs inline, or view log files in
  ${kO.baseLogs()}`,
          ),
        ),
      uZ.default.createElement(
        y,
        { flexDirection: "column", marginTop: 1 },
        uZ.default.createElement(M, { dimColor: !0 }, "MCP Config locations (by scope):"),
        ["user", "project", "local"].map((J) =>
          uZ.default.createElement(
            y,
            { key: J, flexDirection: "column", marginLeft: 1 },
            uZ.default.createElement(M, { dimColor: !0 }, "• ", ag(J), ":"),
            uZ.default.createElement(y, { marginLeft: 2 }, uZ.default.createElement(M, { dimColor: !0 }, "• ", bz(J))),
          ),
        ),
      ),
      uZ.default.createElement(
        y,
        { marginTop: 1, marginLeft: 0 },
        uZ.default.createElement(
          M,
          { dimColor: !0 },
          "For help configuring MCP servers, see:",
          " ",
          uZ.default.createElement(
            H5,
            { url: "https://docs.anthropic.com/en/docs/claude-code/mcp" },
            "https://docs.anthropic.com/en/docs/claude-code/mcp",
          ),
        ),
      ),
    ),
    uZ.default.createElement(
      y,
      { marginLeft: 3 },
      uZ.default.createElement(
        M,
        { dimColor: !0 },
        G.pending
          ? uZ.default.createElement(uZ.default.Fragment, null, "Press ", G.keyName, " again to exit")
          : uZ.default.createElement(uZ.default.Fragment, null, "Esc to exit"),
      ),
    ),
  );
}
var s9 = A1(V1(), 1);
var Xh1 = A1(V1(), 1);
function Fh1({ serverToolsCount: A, serverPromptsCount: B, serverResourcesCount: Q }) {
  let Z = [];
  if (A > 0) Z.push("tools");
  if (Q > 0) Z.push("resources");
  if (B > 0) Z.push("prompts");
  return Xh1.default.createElement(
    y,
    null,
    Xh1.default.createElement(M, { bold: !0 }, "Capabilities: "),
    Xh1.default.createElement(M, { color: "text" }, Z.length > 0 ? Z.join(" · ") : "none"),
  );
}
var cb = A1(V1(), 1);
var zS = A1(V1(), 1);
function fDB(A, B = !1) {
  let [Q, Z] = dB(),
    G = zS.useMemo(() => {
      return { ...(B ? {} : IL()), ...A };
    }, [B, A]);
  zS.useEffect(() => {
    Z((J) => ({
      ...J,
      mcp: {
        ...J.mcp,
        clients: Object.entries(G).map(([X, F]) => ({ name: X, type: "pending", config: F })),
        tools: [],
        commands: [],
        resources: {},
      },
    }));
  }, [G, Z]);
  let Y = zS.useCallback(
      (J, X = [], F = [], V) => {
        Z((K) => {
          let H = E$A(J.name);
          return {
            ...K,
            mcp: {
              ...K.mcp,
              clients: K.mcp.clients.map((z) => (z.name === J.name ? J : z)),
              tools: [...PV1(K.mcp.tools, (z) => z.name?.startsWith(H)), ...X],
              commands: [...PV1(K.mcp.commands, (z) => z.name?.startsWith(H)), ...F],
              resources: {
                ...K.mcp.resources,
                ...(V && V.length > 0 ? { [J.name]: V } : zl1(K.mcp.resources, J.name)),
              },
            },
          };
        });
      },
      [Z],
    ),
    I = zS.useCallback(
      ({ client: J, tools: X, commands: F, resources: V }) => {
        switch ((Y(J, X, F, V), J.type)) {
          case "connected": {
            J.client.onclose = () => {
              if (
                (mY1(J.name, J.config).catch(() => {
                  F1(`Failed to invalidate the server cache: ${J.name}`);
                }),
                J.config.type === "sse" || J.config.type === "http" || J.config.type === "sse-ide")
              ) {
                let K = J.config.type === "http" ? "HTTP" : "SSE";
                (DA(J.name, `${K} transport closed/disconnected, attempting automatic reconnection`),
                  Y({ ...J, type: "pending" }));
                let H = Date.now();
                yw0(J.name, J.config)
                  .then((z) => {
                    let D = Date.now() - H;
                    if (z.client.type === "connected") DA(J.name, `${K} reconnection successful after ${D}ms`);
                    else DA(J.name, `${K} reconnection attempt completed with status: ${z.client.type}`);
                    I(z);
                  })
                  .catch((z) => {
                    let D = Date.now() - H;
                    (RY(J.name, `${K} reconnection failed after ${D}ms: ${z}`), Y({ ...J, type: "failed" }));
                  });
              } else Y({ ...J, type: "failed" });
            };
            break;
          }
          case "needs-auth":
          case "failed":
          case "pending":
            break;
        }
      },
      [Y],
    );
  return (
    zS.useEffect(() => {
      kw0(I, G).catch((J) => {
        RY("useManageMcpConnections", `Failed to get MCP resources: ${J instanceof Error ? J.message : String(J)}`);
      });
    }, [G, I]),
    {
      reconnectMcpServer: zS.useCallback(
        async (J) => {
          let X = Q.mcp.clients.find((V) => V.name === J);
          if (!X) throw new Error(`MCP server ${J} not found`);
          let F = await yw0(J, X.config);
          return (I(F), F);
        },
        [Q.mcp.clients, I],
      ),
    }
  );
}
var hDB = cb.createContext(null);
function yA1() {
  let A = cb.useContext(hDB);
  if (!A) throw new Error("useMcpReconnect must be used within MCPConnectionManager");
  return A.reconnectMcpServer;
}
function Vh1({ children: A, dynamicMcpConfig: B, isStrictMcpConfig: Q }) {
  let { reconnectMcpServer: Z } = fDB(B, Q),
    G = cb.useMemo(() => ({ reconnectMcpServer: Z }), [Z]);
  return cb.default.createElement(hDB.Provider, { value: G }, A);
}
function Kh1(A, B) {
  switch (A.client.type) {
    case "connected":
      return { message: `Reconnected to ${B}.`, success: !0 };
    case "needs-auth":
      return { message: `${B} requires authentication. Use the 'Authenticate' option.`, success: !1 };
    case "failed":
      return { message: `Failed to reconnect to ${B}.`, success: !1 };
    default:
      return { message: `Unknown result when reconnecting to ${B}.`, success: !1 };
  }
}
function Hh1(A, B) {
  let Q = A instanceof Error ? A.message : String(A);
  return `Error reconnecting to ${B}: ${Q}`;
}
function vL0({ server: A, serverToolsCount: B, onViewTools: Q, onCancel: Z, onComplete: G }) {
  let [Y] = sB(),
    I = Z2(),
    [W] = dB(),
    J = yA1(),
    [X, F] = s9.useState(!1),
    V = String(A.name).charAt(0).toUpperCase() + String(A.name).slice(1),
    K = XU1(W.mcp.commands, A.name).length,
    H = [];
  if (A.client.type === "connected" && B > 0) H.push({ label: "View tools", value: "tools" });
  if ((H.push({ label: "Reconnect", value: "reconnectMcpServer" }), H.length === 0))
    H.push({ label: "Back", value: "back" });
  if (X)
    return s9.default.createElement(
      y,
      { flexDirection: "column", gap: 1, padding: 1 },
      s9.default.createElement(
        M,
        { color: "text" },
        "Reconnecting to ",
        s9.default.createElement(M, { bold: !0 }, A.name),
      ),
      s9.default.createElement(
        y,
        null,
        s9.default.createElement(u6, null),
        s9.default.createElement(M, null, " Restarting MCP server process"),
      ),
      s9.default.createElement(M, { dimColor: !0 }, "This may take a few moments."),
    );
  return s9.default.createElement(
    s9.default.Fragment,
    null,
    s9.default.createElement(
      y,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      s9.default.createElement(y, { marginBottom: 1 }, s9.default.createElement(M, { bold: !0 }, V, " MCP Server")),
      s9.default.createElement(
        y,
        { flexDirection: "column", gap: 0 },
        s9.default.createElement(
          y,
          null,
          s9.default.createElement(M, { bold: !0 }, "Status: "),
          A.client.type === "connected"
            ? s9.default.createElement(M, null, iB("success", Y)(t0.tick), " connected")
            : A.client.type === "pending"
              ? s9.default.createElement(
                  s9.default.Fragment,
                  null,
                  s9.default.createElement(M, { dimColor: !0 }, t0.radioOff),
                  s9.default.createElement(M, null, " connecting…"),
                )
              : s9.default.createElement(M, null, iB("error", Y)(t0.cross), " failed"),
        ),
        s9.default.createElement(
          y,
          null,
          s9.default.createElement(M, { bold: !0 }, "Command: "),
          s9.default.createElement(M, { dimColor: !0 }, A.config.command),
        ),
        A.config.args &&
          A.config.args.length > 0 &&
          s9.default.createElement(
            y,
            null,
            s9.default.createElement(M, { bold: !0 }, "Args: "),
            s9.default.createElement(M, { dimColor: !0 }, A.config.args.join(" ")),
          ),
        s9.default.createElement(
          y,
          null,
          s9.default.createElement(M, { bold: !0 }, "Config location: "),
          s9.default.createElement(M, { dimColor: !0 }, bz(_a(A.name)?.scope ?? "dynamic")),
        ),
        A.client.type === "connected" &&
          s9.default.createElement(Fh1, {
            serverToolsCount: B,
            serverPromptsCount: K,
            serverResourcesCount: W.mcp.resources[A.name]?.length || 0,
          }),
        A.client.type === "connected" &&
          B > 0 &&
          s9.default.createElement(
            y,
            null,
            s9.default.createElement(M, { bold: !0 }, "Tools: "),
            s9.default.createElement(M, { dimColor: !0 }, B, " tools"),
          ),
      ),
      H.length > 0 &&
        s9.default.createElement(
          y,
          { marginTop: 1 },
          s9.default.createElement(xA, {
            options: H,
            onChange: async (z) => {
              if (z === "tools") Q();
              else if (z === "reconnectMcpServer") {
                F(!0);
                try {
                  let D = await J(A.name),
                    { message: C } = Kh1(D, A.name);
                  G?.(C);
                } catch (D) {
                  G?.(Hh1(D, A.name));
                } finally {
                  F(!1);
                }
              } else if (z === "back") Z();
            },
            onCancel: Z,
          }),
        ),
    ),
    s9.default.createElement(
      y,
      { marginLeft: 3 },
      s9.default.createElement(
        M,
        { dimColor: !0 },
        I.pending
          ? s9.default.createElement(s9.default.Fragment, null, "Press ", I.keyName, " again to exit")
          : s9.default.createElement(s9.default.Fragment, null, "Esc to go back"),
      ),
    ),
  );
}
var oB = A1(V1(), 1);
function bL0({ server: A, serverToolsCount: B, onViewTools: Q, onCancel: Z, onComplete: G }) {
  let [Y] = sB(),
    I = Z2(),
    [W, J] = oB.default.useState(!1),
    [X, F] = oB.default.useState(null),
    [V, K] = dB(),
    [H, z] = oB.default.useState(null),
    [D, C] = oB.useState(!1),
    [w, E] = oB.useState(null);
  s0((S, d) => {
    if (d.escape && W) {
      if (w) w.abort();
      (J(!1), z(null), E(null));
    }
  });
  let L = String(A.name).charAt(0).toUpperCase() + String(A.name).slice(1),
    O = XU1(V.mcp.commands, A.name).length,
    R = yA1(),
    P = oB.default.useCallback(async () => {
      (J(!0), F(null));
      let S = new AbortController();
      E(S);
      try {
        if (A.isAuthenticated && A.config) await Pw0(A.name, A.config);
        if (A.config) {
          (await zGB(A.name, A.config, z, S.signal),
            Y1("tengu_mcp_auth_config_authenticate", { wasAuthenticated: A.isAuthenticated }));
          let d = await R(A.name);
          if (d.client.type === "connected") {
            let u = A.isAuthenticated
              ? `Authentication successful. Reconnected to ${A.name}.`
              : `Authentication successful. Connected to ${A.name}.`;
            G?.(u);
          } else if (d.client.type === "needs-auth")
            G?.(
              "Authentication successful, but server still requires authentication. You may need to manually restart Claude Code.",
            );
          else
            (DA(A.name, "Reconnection failed after authentication"),
              G?.(
                "Authentication successful, but server reconnection failed. You may need to manually restart Claude Code for the changes to take effect.",
              ));
        }
      } catch (d) {
        if (d instanceof Error && !(d instanceof Pv1)) F(d.message);
      } finally {
        (J(!1), E(null));
      }
    }, [A.isAuthenticated, A.config, A.name, G, R, z]),
    _ = async () => {
      if (A.config)
        (await Pw0(A.name, A.config),
          Y1("tengu_mcp_auth_config_clear", {}),
          await mY1(A.name, { ...A.config, scope: A.scope }),
          K((S) => {
            let d = S.mcp.clients.map((j) => (j.name === A.name ? { ...j, type: "failed" } : j)),
              u = $$A(S.mcp.tools, A.name),
              o = w$A(S.mcp.commands, A.name),
              m = q$A(S.mcp.resources, A.name);
            return { ...S, mcp: { clients: d, tools: u, commands: o, resources: m } };
          }),
          G?.(`Authentication cleared for ${A.name}.`));
    };
  if (W)
    return oB.default.createElement(
      y,
      { flexDirection: "column", gap: 1, padding: 1 },
      oB.default.createElement(M, { color: "claude" }, "Authenticating with ", A.name, "…"),
      oB.default.createElement(
        y,
        null,
        oB.default.createElement(u6, null),
        oB.default.createElement(M, null, " A browser window will open for authentication"),
      ),
      H &&
        oB.default.createElement(
          y,
          { flexDirection: "column" },
          oB.default.createElement(
            M,
            { dimColor: !0 },
            "If your browser doesn't open automatically, copy this URL manually:",
          ),
          oB.default.createElement(H5, { url: H }),
        ),
      oB.default.createElement(
        y,
        { marginLeft: 3 },
        oB.default.createElement(
          M,
          { dimColor: !0 },
          "Return here after authenticating in your browser. Press Esc to go back.",
        ),
      ),
    );
  if (D)
    return oB.default.createElement(
      y,
      { flexDirection: "column", gap: 1, padding: 1 },
      oB.default.createElement(
        M,
        { color: "text" },
        "Reconnecting to ",
        oB.default.createElement(M, { bold: !0 }, A.name),
        "…",
      ),
      oB.default.createElement(
        y,
        null,
        oB.default.createElement(u6, null),
        oB.default.createElement(M, null, " Establishing connection to MCP server"),
      ),
      oB.default.createElement(M, { dimColor: !0 }, "This may take a few moments."),
    );
  let b = [];
  if (A.client.type === "connected" && B > 0) b.push({ label: "View tools", value: "tools" });
  if (A.isAuthenticated)
    (b.push({ label: "Re-authenticate", value: "reauth" }),
      b.push({ label: "Clear authentication", value: "clear-auth" }));
  if (!A.isAuthenticated) b.push({ label: "Authenticate", value: "auth" });
  if (A.client.type !== "needs-auth") b.push({ label: "Reconnect", value: "reconnectMcpServer" });
  if (b.length === 0) b.push({ label: "Back", value: "back" });
  return oB.default.createElement(
    oB.default.Fragment,
    null,
    oB.default.createElement(
      y,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      oB.default.createElement(y, { marginBottom: 1 }, oB.default.createElement(M, { bold: !0 }, L, " MCP Server")),
      oB.default.createElement(
        y,
        { flexDirection: "column", gap: 0 },
        oB.default.createElement(
          y,
          null,
          oB.default.createElement(M, { bold: !0 }, "Status: "),
          A.client.type === "connected"
            ? oB.default.createElement(
                oB.default.Fragment,
                null,
                oB.default.createElement(M, null, iB("success", Y)(t0.tick), " connected"),
                A.isAuthenticated &&
                  oB.default.createElement(M, null, "  ", iB("success", Y)(t0.tick), " authenticated"),
              )
            : A.client.type === "pending"
              ? oB.default.createElement(
                  oB.default.Fragment,
                  null,
                  oB.default.createElement(M, { dimColor: !0 }, t0.radioOff),
                  oB.default.createElement(M, null, " connecting…"),
                )
              : A.client.type === "needs-auth"
                ? oB.default.createElement(M, null, iB("warning", Y)(t0.triangleUpOutline), " needs authentication")
                : oB.default.createElement(M, null, iB("error", Y)(t0.cross), " failed"),
        ),
        oB.default.createElement(
          y,
          null,
          oB.default.createElement(M, { bold: !0 }, "URL: "),
          oB.default.createElement(M, { dimColor: !0 }, A.config.url),
        ),
        oB.default.createElement(
          y,
          null,
          oB.default.createElement(M, { bold: !0 }, "Config location: "),
          oB.default.createElement(M, { dimColor: !0 }, bz(_a(A.name)?.scope ?? "dynamic")),
        ),
        A.client.type === "connected" &&
          oB.default.createElement(Fh1, {
            serverToolsCount: B,
            serverPromptsCount: O,
            serverResourcesCount: V.mcp.resources[A.name]?.length || 0,
          }),
        A.client.type === "connected" &&
          B > 0 &&
          oB.default.createElement(
            y,
            null,
            oB.default.createElement(M, { bold: !0 }, "Tools: "),
            oB.default.createElement(M, { dimColor: !0 }, B, " tools"),
          ),
      ),
      X && oB.default.createElement(y, { marginTop: 1 }, oB.default.createElement(M, { color: "error" }, "Error: ", X)),
      b.length > 0 &&
        oB.default.createElement(
          y,
          { marginTop: 1 },
          oB.default.createElement(xA, {
            options: b,
            onChange: async (S) => {
              switch (S) {
                case "tools":
                  Q();
                  break;
                case "auth":
                case "reauth":
                  await P();
                  break;
                case "clear-auth":
                  await _();
                  break;
                case "reconnectMcpServer":
                  C(!0);
                  try {
                    let d = await R(A.name),
                      { message: u } = Kh1(d, A.name);
                    G?.(u);
                  } catch (d) {
                    G?.(Hh1(d, A.name));
                  } finally {
                    C(!1);
                  }
                  break;
                case "back":
                  Z();
                  break;
              }
            },
            onCancel: Z,
          }),
        ),
    ),
    oB.default.createElement(
      y,
      { marginLeft: 3 },
      oB.default.createElement(
        M,
        { dimColor: !0 },
        I.pending
          ? oB.default.createElement(oB.default.Fragment, null, "Press ", I.keyName, " again to exit")
          : oB.default.createElement(oB.default.Fragment, null, "Esc to go back"),
      ),
    ),
  );
}
var YK = A1(V1(), 1);
function fL0({ server: A, onSelectTool: B, onBack: Q }) {
  let Z = Z2(),
    [G] = dB(),
    Y = YK.default.useMemo(() => {
      if (A.client.type !== "connected") return [];
      return s41(G.mcp.tools, A.name);
    }, [A, G.mcp.tools]),
    I = Y.map((W, J) => {
      let X = FU1(W.name, A.name),
        F = W.userFacingName ? W.userFacingName({}) : X,
        V = VU1(F),
        K = W.isReadOnly?.({}) ?? !1,
        H = W.isDestructive?.({}) ?? !1,
        z = W.isOpenWorld?.({}) ?? !1,
        D = [];
      if (K) D.push("read-only");
      if (H) D.push("destructive");
      if (z) D.push("open-world");
      return {
        label: V,
        value: J.toString(),
        description: D.length > 0 ? D.join(", ") : void 0,
        descriptionColor: H ? "error" : K ? "success" : void 0,
      };
    });
  return YK.default.createElement(
    y,
    { flexDirection: "column" },
    YK.default.createElement(
      y,
      { flexDirection: "column", paddingX: 1, borderStyle: "round" },
      YK.default.createElement(
        y,
        { marginBottom: 1 },
        YK.default.createElement(M, { bold: !0 }, "Tools for ", A.name),
        YK.default.createElement(M, { dimColor: !0 }, " (", Y.length, " tools)"),
      ),
      Y.length === 0
        ? YK.default.createElement(M, { dimColor: !0 }, "No tools available")
        : YK.default.createElement(xA, {
            options: I,
            onChange: (W) => {
              let J = parseInt(W),
                X = Y[J];
              if (X) B(X, J);
            },
            onCancel: Q,
          }),
    ),
    YK.default.createElement(
      y,
      { marginLeft: 3 },
      YK.default.createElement(
        M,
        { dimColor: !0 },
        Z.pending
          ? YK.default.createElement(YK.default.Fragment, null, "Press ", Z.keyName, " again to exit")
          : YK.default.createElement(YK.default.Fragment, null, "Esc to go back"),
      ),
    ),
  );
}
var D5 = A1(V1(), 1);
function hL0({ tool: A, server: B, onBack: Q }) {
  let Z = Z2(),
    [G, Y] = D5.default.useState("");
  s0((K, H) => {
    if (H.escape) Q();
  });
  let I = FU1(A.name, B.name),
    W = A.userFacingName ? A.userFacingName({}) : I,
    J = VU1(W),
    X = A.isReadOnly?.({}) ?? !1,
    F = A.isDestructive?.({}) ?? !1,
    V = A.isOpenWorld?.({}) ?? !1;
  return (
    D5.default.useEffect(() => {
      async function K() {
        try {
          let H = await A.description(
            {},
            {
              isNonInteractiveSession: !1,
              toolPermissionContext: {
                mode: "default",
                additionalWorkingDirectories: new Map(),
                alwaysAllowRules: {},
                alwaysDenyRules: {},
                alwaysAskRules: {},
                isBypassPermissionsModeAvailable: !1,
              },
              tools: [],
            },
          );
          Y(H);
        } catch {
          Y("Failed to load description");
        }
      }
      K();
    }, [A]),
    D5.default.createElement(
      y,
      { flexDirection: "column" },
      D5.default.createElement(
        y,
        { flexDirection: "column", paddingX: 1, borderStyle: "round" },
        D5.default.createElement(
          y,
          { marginBottom: 1 },
          D5.default.createElement(
            M,
            { bold: !0 },
            J,
            D5.default.createElement(M, { dimColor: !0 }, " (", B.name, ")"),
            X && D5.default.createElement(M, { color: "success" }, " [read-only]"),
            F && D5.default.createElement(M, { color: "error" }, " [destructive]"),
            V && D5.default.createElement(M, { dimColor: !0 }, " [open-world]"),
          ),
        ),
        D5.default.createElement(
          y,
          { flexDirection: "column" },
          D5.default.createElement(
            y,
            null,
            D5.default.createElement(M, { bold: !0 }, "Tool name: "),
            D5.default.createElement(M, { dimColor: !0 }, I),
          ),
          D5.default.createElement(
            y,
            null,
            D5.default.createElement(M, { bold: !0 }, "Full name: "),
            D5.default.createElement(M, { dimColor: !0 }, A.name),
          ),
          G &&
            D5.default.createElement(
              y,
              { flexDirection: "column", marginTop: 1 },
              D5.default.createElement(M, { bold: !0 }, "Description:"),
              D5.default.createElement(M, { wrap: "wrap" }, G),
            ),
          A.inputJSONSchema &&
            A.inputJSONSchema.properties &&
            Object.keys(A.inputJSONSchema.properties).length > 0 &&
            D5.default.createElement(
              y,
              { flexDirection: "column", marginTop: 1 },
              D5.default.createElement(M, { bold: !0 }, "Parameters:"),
              D5.default.createElement(
                y,
                { marginLeft: 2, flexDirection: "column" },
                Object.entries(A.inputJSONSchema.properties).map(([K, H]) => {
                  let D = A.inputJSONSchema?.required?.includes(K);
                  return D5.default.createElement(
                    M,
                    { key: K },
                    "• ",
                    K,
                    D && D5.default.createElement(M, { dimColor: !0 }, " (required)"),
                    ":",
                    " ",
                    D5.default.createElement(
                      M,
                      { dimColor: !0 },
                      typeof H === "object" && H && "type" in H ? String(H.type) : "unknown",
                    ),
                    typeof H === "object" &&
                      H &&
                      "description" in H &&
                      D5.default.createElement(M, { dimColor: !0 }, " ", "- ", String(H.description)),
                  );
                }),
              ),
            ),
        ),
      ),
      D5.default.createElement(
        y,
        { marginLeft: 3 },
        D5.default.createElement(
          M,
          { dimColor: !0 },
          Z.pending
            ? D5.default.createElement(D5.default.Fragment, null, "Press ", Z.keyName, " again to exit")
            : D5.default.createElement(D5.default.Fragment, null, "Esc to go back"),
        ),
      ),
    )
  );
}
function gL0({ onComplete: A }) {
  let [B] = dB(),
    Q = B.mcp.clients,
    [Z, G] = g$.default.useState({ type: "list" }),
    [Y, I] = g$.default.useState([]),
    W = g$.default.useMemo(() => Q.filter((J) => J.name !== "ide").sort((J, X) => J.name.localeCompare(X.name)), [Q]);
  switch (
    (g$.default.useEffect(() => {
      async function J() {
        let X = await Promise.all(
          W.map(async (F) => {
            let V = F.config.scope,
              K = F.config.type === "sse",
              H = F.config.type === "http",
              z = void 0;
            if (K || H) {
              let w = await new gd(F.name, F.config).tokens();
              z = Boolean(w);
            }
            let D = { name: F.name, client: F, scope: V };
            if (K) return { ...D, transport: "sse", isAuthenticated: z, config: F.config };
            else if (H) return { ...D, transport: "http", isAuthenticated: z, config: F.config };
            else return { ...D, transport: "stdio", config: F.config };
          }),
        );
        I(X);
      }
      J();
    }, [W]),
    g$.useEffect(() => {
      if (Y.length === 0 && W.length > 0) return;
      if (Y.length === 0)
        A(
          "No MCP servers configured. Please run /doctor if this is unexpected. Otherwise, run `claude mcp` or visit https://docs.anthropic.com/en/docs/claude-code/mcp to learn more.",
        );
    }, [Y.length, W.length, A]),
    Z.type)
  ) {
    case "list":
      return g$.default.createElement(xL0, {
        servers: Y,
        onSelectServer: (J) => G({ type: "server-menu", server: J }),
        onComplete: A,
      });
    case "server-menu": {
      let J = s41(B.mcp.tools, Z.server.name);
      if (Z.server.transport === "stdio")
        return g$.default.createElement(vL0, {
          server: Z.server,
          serverToolsCount: J.length,
          onViewTools: () => G({ type: "server-tools", server: Z.server }),
          onCancel: () => G({ type: "list" }),
          onComplete: A,
        });
      else
        return g$.default.createElement(bL0, {
          server: Z.server,
          serverToolsCount: J.length,
          onViewTools: () => G({ type: "server-tools", server: Z.server }),
          onCancel: () => G({ type: "list" }),
          onComplete: A,
        });
    }
    case "server-tools":
      return g$.default.createElement(fL0, {
        server: Z.server,
        onSelectTool: (J, X) => G({ type: "server-tool-detail", server: Z.server, toolIndex: X }),
        onBack: () => G({ type: "server-menu", server: Z.server }),
      });
    case "server-tool-detail": {
      let X = s41(B.mcp.tools, Z.server.name)[Z.toolIndex];
      if (!X) return (G({ type: "server-tools", server: Z.server }), null);
      return g$.default.createElement(hL0, {
        tool: X,
        server: Z.server,
        onBack: () => G({ type: "server-tools", server: Z.server }),
      });
    }
  }
}
var bX = A1(V1(), 1);
function uL0({ serverName: A, onComplete: B }) {
  let [Q] = sB(),
    [Z] = dB(),
    G = yA1(),
    [Y, I] = bX.useState(!0),
    [W, J] = bX.useState(null);
  if (
    (bX.useEffect(() => {
      async function X() {
        try {
          if (!Z.mcp.clients.find((K) => K.name === A)) {
            (J(`MCP server "${A}" not found`), I(!1));
            return;
          }
          switch ((await G(A)).client.type) {
            case "connected":
              B(`Successfully reconnected to ${A}`);
              break;
            case "needs-auth":
              (J(`${A} requires authentication`), I(!1), B(`${A} requires authentication. Use /mcp to authenticate.`));
              break;
            case "pending":
            case "failed":
              (J(`Failed to reconnect to ${A}`), I(!1), B(`Failed to reconnect to ${A}`));
              break;
          }
        } catch (F) {
          let V = F instanceof Error ? F.message : String(F);
          (J(V), I(!1), B(`Error: ${V}`));
        }
      }
      X();
    }, [A, G, Z.mcp.clients, B]),
    Y)
  )
    return bX.default.createElement(
      y,
      { flexDirection: "column", gap: 1, padding: 1 },
      bX.default.createElement(M, { color: "text" }, "Reconnecting to ", bX.default.createElement(M, { bold: !0 }, A)),
      bX.default.createElement(
        y,
        null,
        bX.default.createElement(u6, null),
        bX.default.createElement(M, null, " Establishing connection to MCP server"),
      ),
    );
  if (W)
    return bX.default.createElement(
      y,
      { flexDirection: "column", gap: 1, padding: 1 },
      bX.default.createElement(
        y,
        null,
        bX.default.createElement(M, null, iB("error", Q)(t0.cross), " "),
        bX.default.createElement(M, { color: "error" }, "Failed to reconnect to ", A),
      ),
      bX.default.createElement(M, { dimColor: !0 }, "Error: ", W),
    );
  return null;
}
var T75 = {
    type: "local-jsx",
    name: "mcp",
    description: "Manage MCP servers",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[reconnect <server-name>]",
    async call(A, B, Q) {
      if (Q) {
        let Z = Q.trim().split(/\s+/);
        if (Z[0] === "reconnect" && Z[1]) {
          let G = Z.slice(1).join(" ");
          return mL0.default.createElement(uL0, { serverName: G, onComplete: A });
        }
      }
      return mL0.default.createElement(gL0, { onComplete: A });
    },
    userFacingName() {
      return "mcp";
    },
  },
  gDB = T75;
var uDB = {
  type: "prompt",
  name: "pr-comments",
  description: "Get comments from a GitHub pull request",
  progressMessage: "fetching PR comments",
  useSmallFastModel: !0,
  isEnabled: () => !0,
  isHidden: !1,
  userFacingName() {
    return "pr-comments";
  },
  source: "builtin",
  async getPromptForCommand(A) {
    return [
      {
        type: "text",
        text: `You are an AI assistant integrated into a git-based version control system. Your task is to fetch and display comments from a GitHub pull request.

Follow these steps:

1. Use \`VERSION_STRING pr view --json number,headRepository\` to get the PR number and repository info
2. Use \`VERSION_STRING api /repos/{owner}/{repo}/issues/{number}/comments\` to get PR-level comments
3. Use \`VERSION_STRING api /repos/{owner}/{repo}/pulls/{number}/comments\` to get review comments. Pay particular attention to the following fields: \`body\`, \`diff_hunk\`, \`path\`, \`line\`, etc. If the comment references some code, consider fetching it using eg \`VERSION_STRING api /repos/{owner}/{repo}/contents/{path}?ref={branch} | jq .content -r | base64 -d\`
4. Parse and format all comments in a readable way
5. Return ONLY the formatted comments, with no additional text

Format the comments as:

## Comments

[For each comment thread:]
- @author file.ts#line:
  \`\`\`diff
  [diff_hunk from the API response]
  \`\`\`
  > quoted comment text
  
  [any replies indented]

If there are no comments, return "No comments found."

Remember:
1. Only show the actual comments, no explanatory text
2. Include both PR-level and code review comments
3. Preserve the threading/nesting of comment replies
4. Show the file and line number context for code review comments
5. Use jq to parse the JSON responses from the GitHub API

${A ? "Additional user input: " + A : ""}
`,
      },
    ];
  },
};
var lb = A1(E_(), 1);
var P75 = 5,
  mDB = "https://github.com/anthropics/claude-code/blob/main/CHANGELOG.md",
  j75 = "https://raw.githubusercontent.com/anthropics/claude-code/refs/heads/main/CHANGELOG.md";
async function dL0() {
  let A = await $2.get(j75);
  if (A.status === 200) {
    let B = H0();
    TA({ ...B, cachedChangelog: A.data, changelogLastFetched: Date.now() });
  }
}
function ZW1() {
  return H0().cachedChangelog ?? "";
}
function dDB(A) {
  try {
    if (!A) return {};
    let B = {},
      Q = A.split(/^## /gm).slice(1);
    for (let Z of Q) {
      let G = Z.trim().split(`
`);
      if (G.length === 0) continue;
      let Y = G[0];
      if (!Y) continue;
      let I = Y.split(" - ")[0]?.trim() || "";
      if (!I) continue;
      let W = G.slice(1)
        .filter((J) => J.trim().startsWith("- "))
        .map((J) => J.trim().substring(2).trim())
        .filter(Boolean);
      if (W.length > 0) B[I] = W;
    }
    return B;
  } catch (B) {
    return (U1(B instanceof Error ? B : new Error("Failed to parse changelog"), gGA), {});
  }
}
function S75(A, B, Q = ZW1()) {
  try {
    let Z = dDB(Q),
      G = lb.coerce(A),
      Y = B ? lb.coerce(B) : null;
    if (!Y || (G && lb.gt(G, Y, { loose: !0 })))
      return Object.entries(Z)
        .filter(([I]) => !Y || lb.gt(I, Y, { loose: !0 }))
        .sort(([I], [W]) => (lb.gt(I, W, { loose: !0 }) ? -1 : 1))
        .flatMap(([I, W]) => W)
        .filter(Boolean)
        .slice(0, P75);
  } catch (Z) {
    return (U1(Z instanceof Error ? Z : new Error("Failed to get release notes"), oo1), []);
  }
  return [];
}
function cL0(A = ZW1()) {
  try {
    let B = dDB(A);
    return Object.keys(B)
      .sort((Z, G) => (lb.gt(Z, G, { loose: !0 }) ? 1 : -1))
      .map((Z) => {
        let G = B[Z];
        if (!G || G.length === 0) return null;
        let Y = G.filter(Boolean);
        if (Y.length === 0) return null;
        return [Z, Y];
      })
      .filter((Z) => Z !== null);
  } catch (B) {
    return (U1(B instanceof Error ? B : new Error("Failed to get release notes"), oo1), []);
  }
}
function zh1(
  A,
  B = {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://docs.anthropic.com/s/claude-code",
    VERSION: "1.0.119",
  }.VERSION,
) {
  if (A !== B || !ZW1()) dL0().catch((G) => U1(G instanceof Error ? G : new Error("Failed to fetch changelog"), uGA));
  let Q = S75(B, A);
  return { hasReleaseNotes: Q.length > 0, releaseNotes: Q };
}
function cDB(A) {
  return A.map(([B, Q]) => {
    let Z = `Version ${B}:`,
      G = Q.map((Y) => `• ${Y}`).join(`
`);
    return `${Z}
${G}`;
  }).join(`

`);
}
var y75 = {
    description: "View release notes",
    isEnabled: () => !0,
    isHidden: !1,
    name: "release-notes",
    userFacingName() {
      return "release-notes";
    },
    type: "local",
    supportsNonInteractive: !0,
    async call() {
      let A = [];
      try {
        let Q = new Promise((Z, G) => {
          setTimeout(() => G(new Error("Timeout")), 500);
        });
        (await Promise.race([dL0(), Q]), (A = cL0(ZW1())));
      } catch {}
      if (A.length > 0) return { type: "text", value: cDB(A) };
      let B = cL0();
      if (B.length > 0) return { type: "text", value: cDB(B) };
      return { type: "text", value: `See the full changelog at: ${mDB}` };
    },
  },
  lDB = y75;
var xO = A1(V1(), 1);
var Mc = A1(V1(), 1);
function _O(A, B, Q = !1) {
  if (B <= 0) return "";
  if (A.length > B) return A.slice(0, B - 1) + "…";
  return Q ? A.padStart(B) : A.padEnd(B);
}
function GW1({ logs: A, maxHeight: B = 1 / 0, forceWidth: Q, onCancel: Z, onSelect: G }) {
  let Y = IB(),
    I = Q === void 0 ? Y.columns : Q;
  if (A.length === 0) return null;
  let W = B - 3,
    J = Math.max(0, A.length - W),
    X = A.length.toString().length,
    F = 2,
    V = 2,
    K = F + X + V,
    H = !1,
    z = 12,
    D = !1,
    C = 12,
    w = !1,
    E = 6,
    L = 0,
    O = !1,
    R = I - K;
  if (I > 45) ((H = !0), (R -= z), R--);
  if (I > 55) ((D = !0), (R -= C), R--);
  if (I > 65) ((w = !0), (R -= E), R--);
  if (I > 75) ((O = !0), (L = Math.floor(R * 0.4)), (R -= L), R--);
  let P = !0,
    _ = R,
    b = A.map((d) => {
      let u = [];
      if (H) {
        let o = Yu(d.modified);
        u.push(_O(o, z));
      }
      if (D) {
        let o = Yu(d.created);
        u.push(_O(o, C));
      }
      if (w) {
        let o = d.messageCount.toString();
        u.push(_O(o, E, !0));
      }
      if (O) {
        let o = d.gitBranch || "-";
        u.push(_O(o, L));
      }
      if (P) {
        let o = (d.summary || d.firstPrompt) + (d.isSidechain ? " (sidechain)" : "");
        u.push(_O(o, _));
      }
      return { label: u.join(" "), value: d.value.toString() };
    }),
    S = [];
  if (H) S.push(_O("Modified", z));
  if (D) S.push(_O("Created", C));
  if (w) S.push(_O("Msgs", E, !0));
  if (O) S.push(_O("Git Branch", L));
  if (P) S.push(_O("Summary", _));
  return Mc.default.createElement(
    y,
    { flexDirection: "column", height: B - 1 },
    Mc.default.createElement(
      y,
      { paddingLeft: K },
      Mc.default.createElement(M, { bold: !0, color: "text" }, S.join(" ")),
    ),
    Mc.default.createElement(xA, {
      options: b,
      onChange: (d) => G(parseInt(d, 10)),
      visibleOptionCount: W,
      onCancel: Z,
    }),
    J > 0 &&
      Mc.default.createElement(
        y,
        { paddingLeft: 2 },
        Mc.default.createElement(M, { dimColor: !0 }, "and ", J, " more…"),
      ),
  );
}
function k75({ onDone: A, onResume: B }) {
  let [Q, Z] = xO.useState([]),
    [G, Y] = xO.useState(!0),
    { rows: I } = IB();
  xO.useEffect(() => {
    async function F() {
      try {
        let V = await kA1();
        if (V.length === 0) A("No conversations found to resume");
        else Z(V);
      } catch (V) {
        A("Failed to load conversations");
      } finally {
        Y(!1);
      }
    }
    F();
  }, [A]);
  async function W(F) {
    let V = Q[F];
    if (!V) {
      A("Failed to load selected conversation");
      return;
    }
    let K = tV(V.messages.find((H) => H.sessionId)?.sessionId);
    if (!K) {
      A("Failed to resume conversation");
      return;
    }
    B(K, V);
  }
  function J() {
    A();
  }
  if (G) return null;
  let X = Q.filter((F) => !F.isSidechain);
  return xO.createElement(GW1, { logs: X, maxHeight: I - 2, onCancel: J, onSelect: W });
}
var _75 = {
    type: "local-jsx",
    name: "resume",
    description: "Resume a conversation",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, B) {
      return xO.createElement(k75, {
        onDone: A,
        onResume: (Z, G) => {
          (B.resume?.(Z, G), A(void 0, { skipMessage: !0 }));
        },
      });
    },
    userFacingName() {
      return "resume";
    },
  },
  pDB = _75;
var Dh1 = {
  type: "prompt",
  name: "review",
  description: "Review a pull request",
  isEnabled: () => !0,
  isHidden: !1,
  progressMessage: "reviewing pull request",
  userFacingName() {
    return "review";
  },
  source: "builtin",
  async getPromptForCommand(A) {
    return [
      {
        type: "text",
        text: `
      You are an expert code reviewer. Follow these steps:

      1. If no PR number is provided in the args, use ${gQ.name}("VERSION_STRING pr list") to show open PRs
      2. If a PR number is provided, use ${gQ.name}("VERSION_STRING pr view <number>") to get PR details
      3. Use ${gQ.name}("VERSION_STRING pr diff <number>") to get the diff
      4. Analyze the changes and provide a thorough code review that includes:
         - Overview of what the PR does
         - Analysis of code quality and style
         - Specific suggestions for improvements
         - Any potential issues or risks
      
      Keep your review concise but thorough. Focus on:
      - Code correctness
      - Following project conventions
      - Performance implications
      - Test coverage
      - Security considerations

      Format your review with clear sections and bullet points.

      PR number: ${A}
    `,
      },
    ];
  },
};
var OE = A1(V1(), 1);
var _9 = A1(V1(), 1);
function x75(A, B, Q) {
  let Z = Lm(A);
  if (A === null && b2()) {
    let G = PR1();
    if (B) {
      let Y = Q ? ` · Resets at ${iC(Q, !0)}` : "";
      Z = `${n1.bold("Default")} ${G} (currently Sonnet${Y})`;
    } else if (kV()) Z = `${n1.bold("Default")} ${G} (currently Opus)`;
    else Z = `${n1.bold("Sonnet")} ${G}`;
  }
  return Z;
}
function v75({ type: A }) {
  switch (A) {
    case "check":
      return _9.createElement(M, { color: "success" }, t0.tick);
    case "error":
      return _9.createElement(M, { color: "error" }, t0.warning);
    case "info":
      return _9.createElement(M, { dimColor: !0 }, "L");
  }
}
function b75({ item: A }) {
  return _9.createElement(
    y,
    { gap: 1, paddingLeft: 1 },
    _9.createElement(v75, { type: A.type }),
    _9.createElement(M, null, A.label),
  );
}
function iDB({ sections: A, version: B, onClose: Q }) {
  s0((J, X) => {
    if (X.return || X.escape) Q();
  });
  let Z = Z2(Q),
    [{ mainLoopModel: G, maxRateLimitFallbackActive: Y }] = dB(),
    I = h01(),
    W = x75(G, Y, I.resetsAt);
  return (
    (A = [...A, { title: "Model", command: "/model", items: [{ label: W, type: "info" }] }]),
    _9.createElement(
      y,
      { flexDirection: "column", width: "100%", padding: 1 },
      _9.createElement(
        y,
        { flexDirection: "column", gap: 1 },
        _9.createElement(
          y,
          { flexDirection: "column" },
          _9.createElement(
            y,
            null,
            _9.createElement(M, { bold: !0 }, "Claude Code "),
            _9.createElement(M, { dimColor: !0 }, "v", B),
          ),
          _9.createElement(
            y,
            null,
            _9.createElement(M, { dimColor: !0 }, " L "),
            _9.createElement(M, null, "Session ID: ", U2()),
          ),
        ),
        A.map(
          (J, X) =>
            ((J.items && J.items.length > 0) || J.content) &&
            _9.createElement(
              y,
              { key: X, flexDirection: "column", gap: 0 },
              _9.createElement(
                y,
                null,
                _9.createElement(M, { bold: !0 }, J.title, " "),
                J.command && _9.createElement(M, { dimColor: !0 }, "• ", J.command),
              ),
              J.items?.map((F, V) => _9.createElement(b75, { key: V, item: F })),
              J.content,
            ),
        ),
        _9.createElement(
          y,
          { marginTop: 1 },
          Z.pending
            ? _9.createElement(M, { dimColor: !0 }, "Press ", Z.keyName, " again to exit")
            : _9.createElement(Rb, null),
        ),
      ),
    )
  );
}
var ME = A1(V1(), 1);
function nDB({ context: A } = {}) {
  let B = RI(),
    Q = [];
  if (A?.readFileState)
    mv(A.readFileState).forEach((Y) => {
      let I = A.readFileState.get(Y);
      if (I && Y.endsWith("/CLAUDE.md") && !B.some((W) => W.path === Y))
        Q.push({ path: Y, content: I.content, type: "Project", isNested: !0 });
    });
  let Z = [...B, ...Q];
  if (Z.length === 0) return null;
  let G = new Map();
  return ME.createElement(
    y,
    { flexDirection: "column" },
    Z.map((Y, I) => {
      let W = IJ(Y.path),
        J = Y.isNested ? "nested: " : `${wXB(Y.type)}: `,
        X = Y.parent ? (G.get(Y.parent) ?? 0) + 1 : 0;
      if ((G.set(Y.path, X), X === 0))
        return ME.createElement(M, { key: I }, ME.createElement(M, { dimColor: !0 }, " L "), `${J}${W}`);
      else {
        let F = "  ".repeat(X - 1);
        return ME.createElement(
          M,
          { key: I },
          " ".repeat(J.length + 2),
          F,
          ME.createElement(M, { dimColor: !0 }, " L "),
          W,
        );
      }
    }),
  );
}
var QCB = A1(mD1(), 1);
import { join as kY, dirname as vO, resolve as pb, delimiter as d75, basename as c75 } from "node:path";
import { homedir as BCB } from "node:os";
import { homedir as Ch1 } from "os";
import { join as Uh1 } from "path";
function aDB() {
  return process.env.XDG_STATE_HOME ?? Uh1(Ch1(), ".local", "state");
}
function sDB() {
  return process.env.XDG_CACHE_HOME ?? Uh1(Ch1(), ".cache");
}
function rDB() {
  return process.env.XDG_DATA_HOME ?? Uh1(Ch1(), ".local", "share");
}
function oDB() {
  return Uh1(Ch1(), ".local", "bin");
}
import { join as f75 } from "node:path";
import { createHash as h75 } from "node:crypto";
var CODE_RELEASES_URL = "https://storage.googleapis.com/claude-code-dist-86c565f3-f756-42ad-8dfa-d59b1c096819/claude-code-releases";
async function g75(A = "stable", B, Q) {
  try {
    return (await $2.get(`${B}/${A}`, { timeout: 30000, responseType: "text", ...Q })).data.trim();
  } catch (Z) {
    throw new Error(`Failed to fetch version from ${A}: ${Z}`);
  }
}
async function lL0(A) {
  if (A && /^v?\d+\.\d+\.\d+(-\S+)?$/.test(A)) return A.startsWith("v") ? A.slice(1) : A;
  let B = A || "stable";
  if (B !== "stable" && B !== "latest") throw new Error(`Invalid channel: ${A}. Use 'stable' or 'latest'`);
  return g75(B, CODE_RELEASES_URL);
}
async function u75(A, B, Q, Z = {}) {
  let G = w1(),
    Y = await $2.get(A, { timeout: 300000, responseType: "arraybuffer", ...Z }),
    I = h75("sha256");
  I.update(Y.data);
  let W = I.digest("hex");
  if (W !== B) throw new Error(`Checksum mismatch: expected ${B}, got ${W}`);
  ((await import("fs")).writeFileSync(Q, Buffer.from(Y.data)), G.chmodSync(Q, 493));
}
async function m75(A, B, Q, Z) {
  let G = w1();
  if (G.existsSync(B)) G.rmSync(B, { recursive: !0, force: !0 });
  let Y = DS(),
    J = (await $2.get(`${Q}/${A}/manifest.json`, { timeout: 1e4, responseType: "json", ...Z })).data.platforms[Y];
  if (!J) throw new Error(`Platform ${Y} not found in manifest for version ${A}`);
  let X = J.checksum,
    F = $h1(Y),
    V = `${Q}/${A}/${Y}/${F}`;
  G.mkdirSync(B);
  let K = f75(B, F);
  await u75(V, X, K, Z || {});
}
async function eDB(A, B) {
  return (await m75(A, B, CODE_RELEASES_URL), "binary");
}
var l75 = 2;
function DS() {
  let A = tA.platform,
    B = process.arch === "x64" ? "x64" : process.arch === "arm64" ? "arm64" : null;
  if (!B) {
    let Q = new Error(`Unsupported architecture: ${process.arch}`);
    throw (d0(`Native installer does not support architecture: ${process.arch}`), Q);
  }
  if (A === "linux" && xH.isMuslEnvironment()) return `linux-${B}-musl`;
  return `${A}-${B}`;
}
function $h1(A) {
  return A.startsWith("win32") ? "claude.exe" : "claude";
}
function xA1() {
  let A = DS(),
    B = $h1(A);
  return {
    versions: kY(rDB(), "claude", "versions"),
    staging: kY(sDB(), "claude", "staging"),
    locks: kY(aDB(), "claude", "locks"),
    executable: kY(oDB(), B),
  };
}
function _A1(A) {
  let B = w1();
  if (!B.existsSync(A)) return !1;
  let Q = B.statSync(A);
  return Q.isFile() && Q.size > 10485760;
}
function pL0(A) {
  let B = xA1(),
    Q = w1();
  [B.versions, B.staging, B.locks].forEach((I) => {
    if (!Q.existsSync(I)) Q.mkdirSync(I);
  });
  let G = vO(B.executable);
  if (!Q.existsSync(G)) Q.mkdirSync(G);
  let Y = kY(B.versions, A);
  if (!Q.existsSync(Y)) Q.writeFileSync(Y, "", { flush: !0, encoding: "utf8" });
  return { stagingPath: kY(B.staging, A), installPath: Y };
}
async function ZCB(A, B, Q = 0) {
  let Z = xA1(),
    G = w1(),
    Y = c75(A),
    I = kY(Z.locks, `${Y}.lock`);
  if (!G.existsSync(Z.locks)) G.mkdirSync(Z.locks);
  let W = null;
  try {
    try {
      W = await QCB.default.lock(A, {
        stale: 60000,
        retries: { retries: Q, minTimeout: Q > 0 ? 1000 : 100, maxTimeout: Q > 0 ? 5000 : 500 },
        lockfilePath: I,
      });
    } catch (J) {
      return (U1(J instanceof Error ? J : new Error(String(J)), wGA), d0(`Failed to acquire lock for ${Y}: ${J}`), !1);
    }
    try {
      return (await B(), !0);
    } catch (J) {
      throw (U1(J instanceof Error ? J : new Error(String(J)), qGA), d0(`Install operation failed: ${J}`), J);
    }
  } finally {
    if (W) await W();
  }
}
function GCB(A, B) {
  let Q = w1();
  if (!Q.existsSync(vO(B))) Q.mkdirSync(vO(B));
  let Z = `${B}.tmp.${process.pid}.${Date.now()}`;
  try {
    (Q.copyFileSync(A, Z), Q.chmodSync(Z, 493), Q.renameSync(Z, B));
  } catch (G) {
    try {
      if (Q.existsSync(Z)) Q.unlinkSync(Z);
    } catch {}
    throw G;
  }
}
function p75(A, B) {
  let Q = w1(),
    Z = kY(A, "node_modules", "@anthropic-ai"),
    Y = Q.readdirStringSync(Z).find((W) => W.startsWith("claude-cli-native-"));
  if (!Y) throw new Error("Could not find platform-specific native package");
  let I = kY(Z, Y, "cli");
  if (!Q.existsSync(I)) throw new Error(`Native binary not found at ${I}`);
  (GCB(I, B), Q.rmSync(A, { recursive: !0, force: !0 }));
}
function i75(A, B) {
  let Q = w1(),
    Z = DS(),
    G = $h1(Z),
    Y = kY(A, G);
  if (!Q.existsSync(Y)) throw new Error(`Staged binary not found at ${Y}`);
  (GCB(Y, B), Q.rmSync(A, { recursive: !0, force: !0 }));
}
function n75(A, B) {
  let { stagingPath: Q, installPath: Z } = pL0(A);
  if (B === "npm") p75(Q, Z);
  else i75(Q, Z);
}
function a75(A) {
  let { installPath: B } = pL0(A);
  return _A1(B);
}
async function s75(A, B = !1) {
  let Q = await lL0(A),
    { installPath: Z, stagingPath: G } = pL0(Q);
  if (
    (F1(`Checking for native installer update to version ${Q}`),
    !(await ZCB(
      Z,
      async () => {
        if (!a75(Q) || B) {
          F1(B ? `Force reinstalling native installer version ${Q}` : `Downloading native installer version ${Q}`);
          let W = await eDB(Q, G);
          n75(Q, W);
        } else F1(`Version ${Q} already installed, updating symlink`);
        let I = xA1();
        (r75(I.executable), o75(I.executable, Z));
      },
      3,
    )))
  )
    return !1;
  return (F1(`Successfully updated to version ${Q}`), !0);
}
function r75(A) {
  let B = w1();
  try {
    if (B.existsSync(A)) {
      if (B.statSync(A).isDirectory()) {
        if (B.readdirStringSync(A).length === 0) (B.rmdirSync(A), F1(`Removed empty directory at ${A}`));
      }
    }
  } catch (Q) {
    F1(`Could not remove empty directory at ${A}: ${Q}`);
  }
}
function o75(A, B) {
  let Q = w1();
  if (DS().startsWith("win32"))
    try {
      let W = vO(A);
      if (!Q.existsSync(W)) Q.mkdirSync(W);
      if (Q.existsSync(A)) {
        try {
          let X = Q.statSync(A),
            F = Q.statSync(B);
          if (X.size === F.size) return !1;
        } catch {}
        let J = `${A}.old.${Date.now()}`;
        Q.renameSync(A, J);
        try {
          Q.copyFileSync(B, A);
          try {
            Q.unlinkSync(J);
          } catch {}
        } catch (X) {
          try {
            Q.renameSync(J, A);
          } catch (F) {
            let V = new Error(`Failed to restore old executable: ${F}`, { cause: X });
            throw (U1(V, LD1), V);
          }
          throw X;
        }
      } else {
        if (!Q.existsSync(B)) throw new Error(`Source file does not exist: ${B}`);
        Q.copyFileSync(B, A);
      }
      return !0;
    } catch (W) {
      return (U1(new Error(`Failed to copy executable from ${B} to ${A}: ${W}`), LD1), !1);
    }
  let Y = vO(A);
  if (!Q.existsSync(Y))
    try {
      (Q.mkdirSync(Y), F1(`Created directory ${Y} for symlink`));
    } catch (W) {
      return (U1(new Error(`Failed to create directory ${Y}: ${W}`), LD1), !1);
    }
  try {
    if (Q.existsSync(A)) {
      try {
        let W = Q.readlinkSync(A),
          J = pb(vO(A), W),
          X = pb(B);
        if (J === X) return !1;
      } catch {}
      Q.unlinkSync(A);
    }
  } catch (W) {
    U1(new Error(`Failed to check/remove existing symlink: ${W}`), ro1);
  }
  let I = `${A}.tmp.${process.pid}.${Date.now()}`;
  try {
    return (Q.symlinkSync(B, I), Q.renameSync(I, A), !0);
  } catch (W) {
    try {
      if (Q.existsSync(I)) Q.unlinkSync(I);
    } catch {}
    return (U1(new Error(`Failed to create symlink from ${A} to ${B}: ${W}`), EGA), !1);
  }
}
async function Oc() {
  if (H0().installMethod === "native") return !0;
  return await WW("tengu_native_installation");
}
async function bO(A = !1) {
  if (EQ(process.env.DISABLE_INSTALLATION_CHECKS)) return [];
  let B = H$(),
    Q = H0();
  if (!(A || B === "native" || Q.installMethod === "native")) return [];
  let G = w1(),
    Y = xA1(),
    I = [],
    W = vO(Y.executable),
    J = pb(W),
    F = DS().startsWith("win32");
  if (!G.existsSync(W))
    I.push({
      message: `installMethod is native, but directory ${W} does not exist`,
      userActionRequired: !0,
      type: "error",
    });
  if (!G.existsSync(Y.executable))
    I.push({
      message: `installMethod is native, but claude command not found at ${Y.executable}`,
      userActionRequired: !0,
      type: "error",
    });
  else if (!F)
    try {
      let K = G.readlinkSync(Y.executable),
        H = pb(vO(Y.executable), K);
      if (!G.existsSync(H))
        I.push({ message: `Claude symlink points to non-existent file: ${K}`, userActionRequired: !0, type: "error" });
      else if (!_A1(H))
        I.push({ message: `Claude symlink points to invalid binary: ${K}`, userActionRequired: !0, type: "error" });
    } catch {
      if (!_A1(Y.executable))
        I.push({
          message: `${Y.executable} exists but is not a valid Claude binary`,
          userActionRequired: !0,
          type: "error",
        });
    }
  else if (!_A1(Y.executable))
    I.push({
      message: `${Y.executable} exists but is not a valid Claude binary`,
      userActionRequired: !0,
      type: "error",
    });
  if (
    !(process.env.PATH || "").split(d75).some((K) => {
      try {
        let H = pb(K);
        if (F) return H.toLowerCase() === J.toLowerCase();
        return H === J;
      } catch {
        return !1;
      }
    })
  )
    if (F) {
      let K = W.replace(/\//g, "\\");
      I.push({
        message: `Native installation exists but ${K} is not in your PATH. Add it by opening: System Properties → Environment Variables → Edit User PATH → New → Add the path above. Then restart your terminal.`,
        userActionRequired: !0,
        type: "path",
      });
    } else {
      let K = dG1(),
        z = tM()[K],
        D = z ? z.replace(BCB(), "~") : "your shell config file";
      I.push({
        message: `Native installation exists but ~/.local/bin is not in your PATH. Run: echo 'export PATH="$HOME/.local/bin:$PATH"' >> ${D} && source ${D}`,
        userActionRequired: !0,
        type: "path",
      });
    }
  return I;
}
async function CS(A = !1, B, Q = !1) {
  if (!A && !(await Oc())) return { latestVersion: null, wasUpdated: !1 };
  let Z = await lL0(B),
    G = await s75(B, Q);
  if (!G) return { latestVersion: null, wasUpdated: !1, lockFailed: !0 };
  if (Z || G) {
    let Y = H0();
    if (Y.installMethod !== "native")
      (TA({ ...Y, installMethod: "native", autoUpdates: !1, autoUpdatesProtectedForNative: !0 }),
        F1('Native installer: Set installMethod to "native" and disabled legacy auto-updater for protection'));
  }
  return { latestVersion: Z, wasUpdated: G, lockFailed: !1 };
}
function t75(A) {
  let B = w1();
  try {
    if (B.existsSync(A)) {
      let Q = B.readlinkSync(A),
        Z = pb(vO(A), Q);
      if (B.existsSync(Z) && _A1(Z)) return Z;
    }
  } catch {}
  return null;
}
async function iL0() {
  if ((await Promise.resolve(), !(await Oc()))) return;
  let A = w1(),
    B = xA1();
  if (DS().startsWith("win32"))
    try {
      let Z = vO(B.executable);
      if (A.existsSync(Z)) {
        let Y = A.readdirStringSync(Z).filter(
            (W) => W.startsWith("claude.exe.old.") && W.match(/claude\.exe\.old\.\d+$/),
          ),
          I = 0;
        for (let W of Y)
          try {
            let J = kY(Z, W);
            (A.unlinkSync(J), I++);
          } catch {}
        if (I > 0) F1(`Cleaned up ${I} old Windows executables on startup`);
      }
    } catch (Z) {
      F1(`Failed to clean up old Windows executables: ${Z}`);
    }
  if (A.existsSync(B.staging))
    try {
      let Z = A.readdirStringSync(B.staging),
        G = Date.now() - 3600000,
        Y = 0;
      for (let I of Z) {
        let W = kY(B.staging, I);
        try {
          if (A.statSync(W).mtime.getTime() < G)
            (A.rmSync(W, { recursive: !0, force: !0 }), Y++, F1(`Cleaned up old staging directory: ${I}`));
        } catch {}
      }
      if (Y > 0)
        (F1(`Cleaned up ${Y} orphaned staging directories`), Y1("tengu_native_staging_cleanup", { cleaned_count: Y }));
    } catch (Z) {
      F1(`Failed to clean up staging directories: ${Z}`);
    }
  if (A.existsSync(B.versions))
    try {
      let Z = A.readdirStringSync(B.versions),
        G = Date.now() - 3600000,
        Y = 0;
      for (let I of Z)
        if (I.match(/\.tmp\.\d+\.\d+$/)) {
          let W = kY(B.versions, I);
          try {
            if (A.statSync(W).mtime.getTime() < G)
              (A.unlinkSync(W), Y++, F1(`Cleaned up orphaned temp install file: ${I}`));
          } catch {}
        }
      if (Y > 0)
        (F1(`Cleaned up ${Y} orphaned temp install files`),
          Y1("tengu_native_temp_files_cleanup", { cleaned_count: Y }));
    } catch (Z) {
      F1(`Failed to clean up temp install files: ${Z}`);
    }
  if (!A.existsSync(B.versions)) return;
  try {
    let Z = A.readdirStringSync(B.versions).filter((V) => {
        let K = kY(B.versions, V);
        try {
          let H = A.statSync(K);
          return H.isFile() && (H.size === 0 || _A1(K));
        } catch {
          return !1;
        }
      }),
      G = process.execPath,
      Y = G && G.includes(B.versions) ? pb(G) : null,
      I = new Set([...(Y ? [Y] : [])]),
      W = t75(B.executable);
    if (W) I.add(W);
    let J = Z.map((V) => {
        let K = pb(B.versions, V);
        return { name: V, path: K, mtime: A.statSync(K).mtime };
      })
        .filter((V) => !I.has(V.path))
        .sort((V, K) => K.mtime.getTime() - V.mtime.getTime()),
      X = J.slice(l75);
    if (X.length === 0) return;
    let F = 0;
    for (let V of X)
      try {
        if (
          await ZCB(V.path, () => {
            A.unlinkSync(V.path);
          })
        )
          F++;
      } catch (K) {
        U1(new Error(`Failed to delete version ${V.name}: ${K}`), NGA);
      }
    if (F > 0)
      Y1("tengu_native_version_cleanup", { deleted_count: F, protected_count: I.size, retained_count: J.length - F });
  } catch (Z) {
    U1(new Error(`Version cleanup failed: ${Z}`), $GA);
  }
}
function YW1() {
  let A = w1(),
    B = xA1();
  try {
    if (A.existsSync(B.executable)) (A.unlinkSync(B.executable), F1(`Removed claude symlink at ${B.executable}`));
  } catch (Q) {
    U1(new Error(`Failed to remove claude symlink: ${Q}`), ro1);
  }
}
function IW1() {
  let A = [],
    B = tM();
  for (let [Q, Z] of Object.entries(B))
    try {
      let G = Cd(Z);
      if (!G) continue;
      let { filtered: Y, hadAlias: I } = z_1(G);
      if (I)
        (l11(Z, Y),
          A.push({
            message: `Removed claude alias from ${Z}. Run: unalias claude`,
            userActionRequired: !0,
            type: "alias",
          }),
          F1(`Cleaned up claude alias from ${Q} config`));
    } catch (G) {
      (U1(G instanceof Error ? G : new Error(String(G)), UGA),
        A.push({ message: `Failed to clean up ${Z}: ${G}`, userActionRequired: !1, type: "error" }));
    }
  return A;
}
async function e75(A) {
  try {
    let B = await z7("npm", ["config", "get", "prefix"]);
    if (B.code !== 0 || !B.stdout) return { success: !1, error: "Failed to get npm global prefix" };
    let Q = B.stdout.trim(),
      Z = w1(),
      G = !1;
    if (DS() === "windows") {
      let Y = kY(Q, "claude.cmd"),
        I = kY(Q, "claude.ps1"),
        W = kY(Q, "claude");
      if (Z.existsSync(Y)) (Z.unlinkSync(Y), F1(`Manually removed bin script: ${Y}`), (G = !0));
      if (Z.existsSync(I)) (Z.unlinkSync(I), F1(`Manually removed PowerShell script: ${I}`), (G = !0));
      if (Z.existsSync(W)) (Z.unlinkSync(W), F1(`Manually removed bin executable: ${W}`), (G = !0));
    } else {
      let Y = kY(Q, "bin", "claude");
      if (Z.existsSync(Y)) (Z.unlinkSync(Y), F1(`Manually removed bin symlink: ${Y}`), (G = !0));
    }
    if (G) {
      F1(`Successfully removed ${A} manually`);
      let Y = DS() === "windows" ? kY(Q, "node_modules", A) : kY(Q, "lib", "node_modules", A);
      return {
        success: !0,
        warning: `${A} executables removed, but node_modules directory was left intact for safety. You may manually delete it later at: ${Y}`,
      };
    } else return { success: !1 };
  } catch (B) {
    return (d0(`Manual removal failed: ${B}`), { success: !1, error: `Manual removal failed: ${B}` });
  }
}
async function ACB(A) {
  let { code: B, stderr: Q } = await z7("npm", ["uninstall", "-g", A], { cwd: w1().cwd() });
  if (B === 0) return (F1(`Removed global npm installation of ${A}`), { success: !0 });
  else if (Q && !Q.includes("npm ERR! code E404")) {
    if (Q.includes("npm error code ENOTEMPTY")) {
      (d0(`Failed to uninstall global npm package ${A}: ${Q}`), F1("Attempting manual removal due to ENOTEMPTY error"));
      let Z = await e75(A);
      if (Z.success) return { success: !0, warning: Z.warning };
      else if (Z.error)
        return {
          success: !1,
          error: `Failed to remove global npm installation of ${A}: ${Q}. Manual removal also failed: ${Z.error}`,
        };
    }
    return (
      d0(`Failed to uninstall global npm package ${A}: ${Q}`),
      { success: !1, error: `Failed to remove global npm installation of ${A}: ${Q}` }
    );
  }
  return { success: !1 };
}
async function WW1() {
  let A = [],
    B = [],
    Q = 0,
    Z = await ACB("@anthropic-ai/claude-code");
  if (Z.success) {
    if ((Q++, Z.warning)) B.push(Z.warning);
  } else if (Z.error) A.push(Z.error);
  if (
    {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://docs.anthropic.com/s/claude-code",
      VERSION: "1.0.119",
    }.PACKAGE_URL &&
    {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://docs.anthropic.com/s/claude-code",
      VERSION: "1.0.119",
    }.PACKAGE_URL !== "@anthropic-ai/claude-code"
  ) {
    let I = await ACB(
      {
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://docs.anthropic.com/s/claude-code",
        VERSION: "1.0.119",
      }.PACKAGE_URL,
    );
    if (I.success) {
      if ((Q++, I.warning)) B.push(I.warning);
    } else if (I.error) A.push(I.error);
  }
  let G = w1(),
    Y = kY(BCB(), ".claude", "local");
  if (G.existsSync(Y))
    try {
      (G.rmSync(Y, { recursive: !0, force: !0 }), Q++, F1(`Removed local installation at ${Y}`));
    } catch (I) {
      (A.push(`Failed to remove ${Y}: ${I}`), d0(`Failed to remove local installation: ${I}`));
    }
  return { removed: Q, errors: A, warnings: B };
}
function A35() {
  return null;
}
function B35(A, B = null) {
  let Q = [],
    Z = A?.find((G) => G.name === "ide");
  if (Z) {
    let G = Cw0(Z) ?? "IDE";
    if (Z.type === "connected") Q.push({ label: `Connected to ${G} extension`, type: "check" });
    else Q.push({ label: `Not connected to ${G}`, type: "error" });
  }
  if (B) {
    let G = FO(B.ideType);
    if (B.installed)
      if (Z && Z.type === "connected" && B.installedVersion !== Z.serverInfo?.version)
        Q.push({
          label: `Installed ${G} extension version ${B.installedVersion} (server version: ${Z.serverInfo?.version})`,
          type: "info",
        });
      else if (E$(B.ideType) && Z?.type !== "connected")
        Q.push({
          label: `Installed ${G} plugin but connection is not established.
Please restart your IDE or try installing from https://docs.anthropic.com/s/claude-code-jetbrains`,
          type: "info",
        });
      else Q.push({ label: `Installed ${G} extension`, type: "check" });
    if (B.error)
      if (E$(B.ideType))
        Q.push({
          label: `Error installing ${G} plugin: ${B.error}
Please restart your IDE or try installing from https://docs.anthropic.com/s/claude-code-jetbrains`,
          type: "error",
        });
      else
        Q.push({
          label: `Error installing ${G} extension: ${B.error}
Please restart your IDE and try again.`,
          type: "error",
        });
  }
  return { title: "IDE Integration", command: "/config", items: Q };
}
function Q35(A = []) {
  let B = [];
  if (
    (A.filter((Z) => Z.name !== "ide").forEach((Z) => {
      B.push({ label: Z.name, type: Z.type === "failed" ? "error" : Z.type === "pending" ? "info" : "check" });
    }),
    B.length === 0)
  )
    return null;
  return { title: "MCP servers", command: "/mcp", items: B };
}
function Z35(A) {
  let B = ed(),
    Q = RI(),
    Z = Ac();
  if (Q.length === 0 && B.length === 0 && !Z) return null;
  let G = [];
  if (
    (B.forEach((Y) => {
      let I = IJ(Y.path);
      G.push({
        label: `Large ${I} will impact performance (${ZG(Y.content.length)} chars > ${ZG(ej)})`,
        type: "error",
      });
    }),
    Z && Z.content.length > m01)
  )
    G.push({
      label: `CLAUDE.md entries marked as IMPORTANT exceed ${ZG(m01)} characters (${ZG(Z.content.length)} chars)`,
      type: "error",
    });
  return { title: "Memory", command: "/memory", items: G, content: OE.createElement(nDB, { context: A }) };
}
function G35() {
  let A = [],
    B = AA();
  return (A.push({ label: B, type: "info" }), { title: "Working Directory", command: "", items: A });
}
async function Y35() {
  let A = await bO();
  if (A.length === 0) return null;
  return { title: "Installation", command: "", items: A.map((Q) => ({ label: Q.message, type: "info" })) };
}
async function I35() {
  let A = await p11(),
    B = [],
    { errors: Q } = A_();
  if (Q.length > 0) {
    let G = Array.from(new Set(Q.map((Y) => Y.file))).join(", ");
    B.push({ label: `Found invalid settings files: ${G}. They will be ignored.`, type: "error" });
  }
  if (A.multipleInstallations.length > 1)
    B.push({ label: `Multiple installations detected (${A.multipleInstallations.length} found)`, type: "error" });
  if (
    (A.warnings.forEach((Z) => {
      B.push({ label: Z.issue, type: "error" });
    }),
    A.hasUpdatePermissions === !1)
  )
    B.push({ label: "No write permissions for auto-updates (requires sudo)", type: "error" });
  if (A.configInstallMethod !== "not set") {
    let G = {
      "npm-local": "local",
      "npm-global": "global",
      native: "native",
      development: "development",
      unknown: "unknown",
    }[A.installationType];
    if (G && G !== A.configInstallMethod)
      B.push({
        label: `Config mismatch: running ${A.installationType} but config says ${A.configInstallMethod}`,
        type: "error",
      });
  }
  if (B.length === 0) return null;
  return { title: "System Diagnostics", command: "/doctor", items: B };
}
function W35() {
  if (h7() !== "firstParty") return null;
  let B = [],
    { source: Q } = Mj();
  if (b2()) B.push({ label: `Login Method: ${ZS1()} Account`, type: "info" });
  else B.push({ label: `Auth Token: ${Q}`, type: "info" });
  let { key: Z, source: G } = xF(!1);
  if (Z) B.push({ label: `API Key: ${G}`, type: "info" });
  if (Q === "claude.ai" || G === "/login managed key") {
    let I = TZ()?.organizationName;
    if (I) B.push({ label: `Organization: ${I}`, type: "info" });
  }
  if (Q !== "claude.ai") {
    if (nd()) B.push({ label: "Development Partner Program • sharing session with Anthropic", type: "info" });
  }
  let Y = TZ()?.emailAddress;
  if ((Q === "claude.ai" || G === "/login managed key") && Y) B.push({ label: `Email: ${Y}`, type: "info" });
  return { title: "Account", command: Q === "claude.ai" || G === "/login managed key" ? "/login" : "", items: B };
}
function J35() {
  let A = h7(),
    B = [];
  if (A !== "firstParty") {
    let G = { bedrock: "AWS Bedrock", vertex: "Google Vertex AI" }[A];
    B.push({ label: `API Provider: ${G}`, type: "info" });
  }
  if (A === "firstParty") {
    let G = process.env.ANTHROPIC_BASE_URL;
    if (G) B.push({ label: `Anthropic Base URL: ${G}`, type: "info" });
  } else if (A === "bedrock") {
    let G = process.env.BEDROCK_BASE_URL;
    if (G) B.push({ label: `Bedrock Base URL: ${G}`, type: "info" });
    if ((B.push({ label: `AWS Region: ${Pn()}`, type: "info" }), process.env.CLAUDE_CODE_SKIP_BEDROCK_AUTH))
      B.push({ label: "AWS auth skipped", type: "info" });
  } else if (A === "vertex") {
    let G = process.env.VERTEX_BASE_URL;
    if (G) B.push({ label: `Vertex Base URL: ${G}`, type: "info" });
    let Y = process.env.ANTHROPIC_VERTEX_PROJECT_ID;
    if (Y) B.push({ label: `GCP Project: ${Y}`, type: "info" });
    if ((B.push({ label: `Default region: ${OT()}`, type: "info" }), process.env.CLAUDE_CODE_SKIP_VERTEX_AUTH))
      B.push({ label: "GCP auth skipped", type: "info" });
  }
  let Q = w31();
  if (Q) B.push({ label: `Proxy: ${Q}`, type: "info" });
  let Z = gP();
  if (process.env.NODE_EXTRA_CA_CERTS)
    B.push({ label: `Additional CA cert(s): ${process.env.NODE_EXTRA_CA_CERTS}`, type: "info" });
  if (Z) {
    if (Z.cert && process.env.CLAUDE_CODE_CLIENT_CERT)
      B.push({ label: `mTLS client cert: ${process.env.CLAUDE_CODE_CLIENT_CERT}`, type: "info" });
    if (Z.key && process.env.CLAUDE_CODE_CLIENT_KEY)
      B.push({ label: `mTLS client key: ${process.env.CLAUDE_CODE_CLIENT_KEY}`, type: "info" });
  }
  if (B.length === 0) return null;
  return { title: "API Configuration", command: "", items: B };
}
function X35({ onClose: A, ideInstallationStatus: B, context: Q }) {
  let [Z] = dB(),
    [G, Y] = OE.useState([]),
    I = {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://docs.anthropic.com/s/claude-code",
      VERSION: "1.0.119",
    }.VERSION;
  return (
    OE.useEffect(() => {
      async function W() {
        let J = await Oc(),
          X = [],
          F = G35();
        if (F) X.push(F);
        if (J) {
          let E = await Y35();
          if (E) X.push(E);
        }
        let V = await I35();
        if (V) X.push(V);
        let K = B35(Z.mcp.clients, B);
        if (K) X.push(K);
        let H = Q35(Z.mcp.clients);
        if (H) X.push(H);
        let z = W35(),
          D = J35();
        if (z) X.push(z);
        if (D) X.push(D);
        let C = Z35(Q);
        if (C) X.push(C);
        let w = A35();
        if (w) X.push(w);
        Y(X);
      }
      W();
    }, [Z.mcp.clients, Z.checkpointing, B, Q]),
    OE.createElement(iDB, { sections: G, version: I, onClose: A })
  );
}
var F35 = {
    type: "local-jsx",
    name: "status",
    description: "Show Claude Code status including version, model, account, API connectivity, and tool statuses",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, B) {
      return OE.createElement(X35, { onClose: A, ideInstallationStatus: B.options.ideInstallationStatus, context: B });
    },
    userFacingName() {
      return "status";
    },
  },
  YCB = F35;
var WM0 = A1(V1(), 1);
var f5 = A1(V1(), 1),
  yc = A1(V1(), 1);
var b5 = A1(V1(), 1),
  JW1 = A1(V1(), 1);
function ICB({ shell: A, onDone: B, onKillShell: Q }) {
  let [Z, G] = JW1.useState(0),
    [Y, I] = JW1.useState({ stdout: "", stderr: "", stdoutLines: 0, stderrLines: 0 });
  s0((F, V) => {
    if (V.escape || V.return || F === " ") B();
    else if (F === "k" && A.status === "running" && Q) Q();
  });
  let W = Z2(),
    J = (F) => {
      let V = Math.floor((Date.now() - F) / 1000),
        K = Math.floor(V / 3600),
        H = Math.floor((V - K * 3600) / 60),
        z = V - K * 3600 - H * 60;
      return `${K > 0 ? `${K}h ` : ""}${H > 0 || K > 0 ? `${H}m ` : ""}${z}s`;
    };
  JW1.useEffect(() => {
    let F = T_1(A),
      V = (E, L, O = 10) => {
        if (!L) return E;
        let R = E.split(`
`),
          P = L.split(`
`);
        return [...R, ...P].slice(-O).join(`
`);
      },
      K = V(Y.stdout, F.stdout),
      H = V(Y.stderr, F.stderr),
      { totalLines: z, truncatedContent: D } = rM(K),
      { totalLines: C, truncatedContent: w } = rM(H);
    if ((I({ stdout: D, stderr: w, stdoutLines: z, stderrLines: C }), A.status === "running")) {
      let E = setTimeout(() => {
        G((L) => L + 1);
      }, 1000);
      return () => clearTimeout(E);
    }
  }, [A.id, A.status, Z, Y.stdout, Y.stderr, A]);
  let X = A.command.length > 70 ? A.command.substring(0, 67) + "..." : A.command;
  return b5.default.createElement(
    y,
    { width: "100%", flexDirection: "column" },
    b5.default.createElement(
      y,
      { width: "100%" },
      b5.default.createElement(
        y,
        {
          borderStyle: "round",
          borderColor: "background",
          flexDirection: "column",
          marginTop: 1,
          paddingLeft: 1,
          paddingRight: 1,
          width: "100%",
        },
        b5.default.createElement(
          y,
          null,
          b5.default.createElement(M, { color: "background", bold: !0 }, "Shell details"),
        ),
        b5.default.createElement(
          y,
          { flexDirection: "column", marginTop: 1 },
          b5.default.createElement(
            M,
            null,
            b5.default.createElement(M, { bold: !0 }, "Status:"),
            " ",
            A.status === "running"
              ? b5.default.createElement(
                  M,
                  { color: "background" },
                  A.status,
                  A.result?.code !== void 0 && ` (exit code: ${A.result.code})`,
                )
              : A.status === "completed"
                ? b5.default.createElement(
                    M,
                    { color: "success" },
                    A.status,
                    A.result?.code !== void 0 && ` (exit code: ${A.result.code})`,
                  )
                : b5.default.createElement(
                    M,
                    { color: "error" },
                    A.status,
                    A.result?.code !== void 0 && ` (exit code: ${A.result.code})`,
                  ),
          ),
          b5.default.createElement(M, null, b5.default.createElement(M, { bold: !0 }, "Runtime:"), " ", J(A.startTime)),
          b5.default.createElement(
            M,
            { wrap: "truncate-end" },
            b5.default.createElement(M, { bold: !0 }, "Command:"),
            " ",
            X,
          ),
        ),
        b5.default.createElement(
          y,
          { flexDirection: "column", marginTop: 1 },
          b5.default.createElement(M, { bold: !0 }, "Stdout:"),
          Y.stdout
            ? b5.default.createElement(
                b5.default.Fragment,
                null,
                b5.default.createElement(
                  y,
                  { borderStyle: "round", borderDimColor: !0, paddingX: 1, flexDirection: "column", height: 12 },
                  Y.stdout
                    .split(
                      `
`,
                    )
                    .slice(-10)
                    .map((F, V) => b5.default.createElement(M, { key: V, wrap: "truncate-end" }, F)),
                ),
                b5.default.createElement(
                  M,
                  { dimColor: !0, italic: !0 },
                  Y.stdoutLines > 10
                    ? `Showing last 10 lines of ${Y.stdoutLines} total lines`
                    : `Showing ${Y.stdoutLines} lines`,
                ),
              )
            : b5.default.createElement(M, { dimColor: !0 }, "No stdout output available"),
        ),
        Y.stderr &&
          b5.default.createElement(
            y,
            { flexDirection: "column", marginTop: 1 },
            b5.default.createElement(M, { bold: !0, color: "error" }, "Stderr:"),
            b5.default.createElement(
              y,
              { borderStyle: "round", borderColor: "error", paddingX: 1, flexDirection: "column", height: 3 },
              Y.stderr
                .split(
                  `
`,
                )
                .slice(-1)
                .map((F, V) => b5.default.createElement(M, { key: V, color: "error", wrap: "truncate-end" }, F)),
            ),
            b5.default.createElement(
              M,
              { dimColor: !0, italic: !0, color: "error" },
              Y.stderrLines > 1 ? `Showing last line of ${Y.stderrLines} total lines` : `Showing ${Y.stderrLines} line`,
            ),
          ),
      ),
    ),
    b5.default.createElement(
      y,
      { marginLeft: 2 },
      W.pending
        ? b5.default.createElement(M, { dimColor: !0 }, "Press ", W.keyName, " again to exit")
        : b5.default.createElement(
            M,
            { dimColor: !0 },
            "Press Esc/Enter/Space to close",
            A.status === "running" && Q ? b5.default.createElement(M, null, " · k to kill") : null,
          ),
    ),
  );
}
var M6 = A1(V1(), 1),
  NW1 = A1(V1(), 1);
var XW1 = A1(V1(), 1);
function wh1({ session: A }) {
  if (A.status === "completed")
    return XW1.default.createElement(M, { bold: !0, color: "success", dimColor: !0 }, "done");
  if (A.status === "failed") return XW1.default.createElement(M, { bold: !0, color: "error", dimColor: !0 }, "error");
  if (!A.todoList.length) return XW1.default.createElement(M, { dimColor: !0 }, A.status, "…");
  let B = A.todoList.filter((Z) => Z.status === "completed").length,
    Q = A.todoList.length;
  return XW1.default.createElement(M, { dimColor: !0 }, B, "/", Q);
}
import { join as Rc } from "path";
import { createHash as V35 } from "crypto";
var K35 = 1e4,
  nL0 = 100;
function Tc() {
  if (!H0().autocheckpointingEnabled)
    console.warn("Checkpointing: Git command may be called even though autocheckpoint is disabled in /config");
}
async function qh1(A, B, Q, Z) {
  return;
}
async function FCB(A, B, Q, Z) {
  return;
}
async function VCB(A, B, Q, Z, G) {
  if (Z.status !== "initialized" || !Z.shadowRepoPath) throw new Error("Checkpointing not initialized");
  return KCB(A, B, Q, !1, Z, G);
}
async function KCB(A, B, Q, Z, G, Y, I) {
  throw new Error("Not enabled");
}
async function WCB(A, B, Q, Z, G, Y) {
  if (Z.saving && !B) {
    let W = new Error("Failed to save checkpoint (another save is in progress)");
    throw (U1(W, t3A), d0(W.message), W);
  }
  (G({ ...Z, saving: !0 }), Tc());
  let I = Date.now();
  try {
    let W = Z.shadowRepoPath,
      J = void 0,
      { stdout: X } = await ib(["rev-parse", "--git-dir"], W, "Failed to rev-parse on save", Y);
    if (X.trim() !== Rc(W, ".git")) {
      G({ ...Z, status: "error", saving: !1 });
      let K = new Error("Failed to save checkpoint (bad shadow git)");
      throw (U1(K, AZA), d0(K.message), K);
    }
    let { stdout: F, code: V } = await z7("git", ["status", "--porcelain", AA()], { cwd: W, abortSignal: Y });
    if (V === 0 && F.trim() === "") {
      let { stdout: K, code: H } = await z7("git", ["rev-parse", "HEAD"], { cwd: W, abortSignal: Y });
      if (H === 0) J = K.trim();
    }
    if (!J) {
      (await ib(["add", "--ignore-errors", AA()], W, "Failed to save checkpointing (add)", Y),
        await ib(
          ["commit", "-m", A.label, "--allow-empty", "--no-gpg-sign"],
          W,
          "Failed to save checkpoint (commit)",
          Y,
        ));
      let { stdout: K } = await ib(["rev-parse", "HEAD"], W, "Failed to save checkpoint (no new commit hash)", Y);
      J = K.trim();
    }
    if (!J) throw new Error("Failed to save checkpoint (no commit hash)");
    if (
      ((A.commit = J),
      G({ ...Z, saving: !1, saveError: void 0, checkpoints: { ...Z.checkpoints, [A.id]: A } }),
      oL0(A).catch((K) => {}),
      !Q)
    ) {
      let K = Date.now() - I;
      Y1("tengu_checkpoint_save_success", { duration: K });
    }
  } catch (W) {
    if ((G({ ...Z, saving: !1, saveError: `${W}` }), U1(W, e3A), d0(`${W}`), !Q)) {
      let J = Date.now() - I;
      Y1("tengu_checkpoint_save_failed", { duration: J });
    }
    throw W;
  }
}
async function HCB(A, B, Q) {
  throw new Error("Not enabled");
}
function aL0(A, B) {
  return;
}
async function sL0(A, B) {
  return;
}
function H35(A) {
  let B = A.match(/(\d+) insertions?\(\+\)(?:, (\d+) deletions?\(-\))?/);
  if (!B) {
    let Q = A.match(/(\d+) deletions?\(-\)/);
    if (Q && Q[1]) return { insertions: 0, deletions: parseInt(Q[1], 10) };
    return { insertions: 0, deletions: 0 };
  }
  return { insertions: parseInt(B[1] ?? "0", 10), deletions: B[2] ? parseInt(B[2], 10) : 0 };
}
function zCB(A) {
  let B = A.checkpoints;
  if (B) for (let Q of B) oL0(Q).catch((Z) => {});
}
async function ib(A, B, Q, Z) {
  Tc();
  let { code: G, stdout: Y, stderr: I } = await z7("git", A, { cwd: B, abortSignal: Z });
  if (G !== 0) throw (d0(`Checkpointing: ${Q}: code=${G}, stdout=${Y}, stderr=${I}`), new Error(`${Q}`));
  return { stdout: Y, stderr: I };
}
async function DCB() {
  try {
    let A = H0(),
      B = A.checkpointingShadowRepos || [];
    if (B.length === 0) return;
    let Q = w1(),
      Z = new Date();
    Z.setMonth(Z.getMonth() - 1);
    let G = Z.getTime(),
      Y = [],
      I = 0;
    for (let W of B) {
      if (!Q.existsSync(W.path)) {
        d0(`Checkpointing: Cleaned up shadow repo that no longer exists: ${W.path}`);
        continue;
      }
      try {
        if (W.lastAccessedTime < G)
          (d0(`Checkpointing: Cleaned up old shadow repo: ${W.path}`),
            Q.rmSync(W.path, { recursive: !0, force: !0 }),
            I++);
        else Y.push(W);
      } catch (J) {
        (d0(`Checkpointing: Failed to clean up shadow repo ${W.path}: ${J}`), Y.push(W));
      }
    }
    if (Y.length !== B.length) {
      if ((TA({ ...A, checkpointingShadowRepos: Y }), I > 0)) Y1("tengu_checkpoint_cleanup", { shadowReposCleaned: I });
    }
  } catch (A) {
    d0(`Checkpointing: Failed to cleanup old shadow repos: ${A}`);
  }
}
async function rL0() {
  try {
    await B61(".claude/checkpoints", AA());
  } catch (A) {
    d0(`Checkpointing: Failed to git ignore .claude/checkpoints: ${A}`);
  }
}
async function z35(A, B) {
  Tc();
  let Q = await JCB(B),
    Z = await XCB(B),
    G = await D35(B),
    Y = G !== B ? await JCB(G) : [],
    I = G !== B ? await XCB(G) : [],
    W = Array.from(new Set(C35.concat(Y, I, Q, Z))),
    J = w1(),
    X = Rc(A, "info"),
    F = Rc(A, "info", "exclude");
  if (!J.existsSync(X)) J.mkdirSync(X);
  J.writeFileSync(
    F,
    W.join(`
`),
    { encoding: "utf8", flush: !0 },
  );
}
async function JCB(A) {
  try {
    let B = w1(),
      Q = Rc(A, ".gitattributes");
    if (B.existsSync(Q))
      return B.readFileSync(Q, { encoding: "utf8" })
        .split(
          `
`,
        )
        .filter((G) => G.includes("filter=lfs"))
        .map((G) => G.split(" ")[0]?.trim() || "")
        .filter((G) => G.length > 0);
  } catch (B) {}
  return [];
}
async function XCB(A) {
  try {
    let B = w1(),
      Q = Rc(A, ".gitignore");
    if (B.existsSync(Q))
      return B.readFileSync(Q, { encoding: "utf8" })
        .split(
          `
`,
        )
        .map((G) => G.trim())
        .filter((G) => G.length > 0 && !G.startsWith("#"));
  } catch (B) {}
  return [];
}
async function D35(A) {
  try {
    let { stdout: B, code: Q } = await z7("git", ["rev-parse", "--show-toplevel"], { cwd: A });
    if (Q === 0) return B.trim();
  } catch (B) {}
  return A;
}
function CCB(A) {
  let B = H0(),
    Q = B.checkpointingShadowRepos || [],
    Z = Q.findIndex((G) => G.path === A);
  if (Z >= 0 && Q[Z]) Q[Z].lastAccessedTime = Date.now();
  else Q.push({ path: A, lastAccessedTime: Date.now() });
  TA({ ...B, checkpointingShadowRepos: Q });
}
var C35 = [
  ".git/",
  ".parcel-cache/",
  ".pytest_cache/",
  ".nuxt/",
  ".sass-cache/",
  ".claude/",
  "__pycache__/",
  "node_modules/",
  "pycache/",
  "*.3gp",
  "*.avif",
  "*.gif",
  "*.png",
  "*.psd",
  "*.aac",
  "*.aiff",
  "*.asf",
  "*.avi",
  "*.bmp",
  "*.divx",
  "*.flac",
  "*.heic",
  "*.ico",
  "*.jpg",
  "*.jpeg",
  "*.m4a",
  "*.m4v",
  "*.mkv",
  "*.mov",
  "*.mp3",
  "*.mp4",
  "*.mpeg",
  "*.mpg",
  "*.ogg",
  "*.opus",
  "*.raw",
  "*.rm",
  "*.rmvb",
  "*.tiff",
  "*.tif",
  "*.vob",
  "*.wav",
  "*.webm",
  "*.webp",
  "*.wma",
  "*.wmv",
  "*.DS_Store",
  "*.cache",
  "*.crdownload",
  "*.dmp",
  "*.dump",
  "*.eslintcache",
  "*.pyc",
  "*.pyo",
  "*.swo",
  "*.swp",
  "*.Thumbs.db",
  "*.zip",
  "*.tar",
  "*.gz",
  "*.rar",
  "*.7z",
  "*.iso",
  "*.bin",
  "*.exe",
  "*.dll",
  "*.so",
  "*.dylib",
  "*.dat",
  "*.dmg",
  "*.msi",
  "*.arrow",
  "*.accdb",
  "*.aof",
  "*.avro",
  "*.bson",
  "*.db",
  "*.dbf",
  "*.dmp",
  "*.frm",
  "*.ibd",
  "*.mdb",
  "*.myd",
  "*.myi",
  "*.orc",
  "*.parquet",
  "*.pdb",
  "*.rdb",
  "*.sqlite",
  "*.shp",
  "*.shx",
  "*.sbn",
  "*.sbx",
  "*.gdb",
  "*.gpkg",
  "*.kmz",
  "*.dem",
  "*.img",
  "*.ecw",
  "*.las",
  "*.laz",
  "*.mxd",
  "*.qgs",
  "*.grd",
  "*.dwg",
  "*.dxf",
];
function U35(A) {
  if (A.type !== "attachment") return A;
  let B = A.attachment;
  if (B.type === "new_file") return { ...A, attachment: { ...B, type: "file" } };
  if (B.type === "new_directory") return { ...A, attachment: { ...B, type: "directory" } };
  return A;
}
function $35(A, B, Q) {
  if (Q.type !== "assistant") return;
  if (!Array.isArray(Q.message.content)) return;
  for (let Z of Q.message.content) {
    if (Z.type !== "tool_use") continue;
    let G = A.find((Y) => Y.name === Z.name);
    if (G) B.set(Z.id, G);
  }
}
function tL0(A, B) {
  try {
    let Q = A.map(U35),
      Z = bJB(Q);
    if (Z[Z.length - 1]?.type === "user") Z.push(wE({ content: JI1 }));
    let Y = new Map();
    for (let I of Z) $35(B, Y, I);
    return Z;
  } catch (Q) {
    throw (U1(Q, io1), Q);
  }
}
async function UCB(A, B) {
  try {
    let Q = await $2.get(A, { headers: B, timeout: 30000 });
    if (!Q.data || !Array.isArray(Q.data.log)) throw new Error("Invalid response format: missing or invalid log array");
    return Q.data;
  } catch (Q) {
    if ($2.isAxiosError(Q)) {
      let Z = Q.response ? `HTTP ${Q.response.status}: ${Q.response.statusText}` : Q.message;
      throw new Error(`Failed to fetch conversation from remote: ${Z}`);
    }
    throw Q;
  }
}
async function nb(A, B) {
  try {
    let Q;
    if (A === void 0) Q = await wCB(0);
    else if (typeof A === "string") Q = await $CB(A);
    else Q = A;
    if (!Q) return null;
    (yb1(Q), zCB(Q));
    let Z = tL0(Q.messages, B),
      G = await S$("resume");
    return (Z.push(...G), { messages: Z, log: Q });
  } catch (Q) {
    throw (U1(Q, io1), Q);
  }
}
var AM0 = A1(V1(), 1);
var SI = A1(V1(), 1);
var B7 = A1(V1(), 1);
function qCB({ onStashAndContinue: A, onCancel: B }) {
  let [Q, Z] = B7.useState(null),
    G = Q !== null ? [...Q.tracked, ...Q.untracked] : [],
    [Y, I] = B7.useState(!0),
    [W, J] = B7.useState(!1),
    [X, F] = B7.useState(null);
  B7.useEffect(() => {
    (async () => {
      try {
        let D = await f10();
        Z(D);
      } catch (D) {
        let C = D instanceof Error ? D.message : String(D);
        (d0(`Error getting changed files: ${C}`), F("Failed to get changed files"));
      } finally {
        I(!1);
      }
    })();
  }, []);
  let V = async () => {
      J(!0);
      try {
        if ((F1("Stashing changes before teleport..."), await x$A("Teleport auto-stash")))
          (F1("Successfully stashed changes"), A());
        else F("Failed to stash changes");
      } catch (z) {
        let D = z instanceof Error ? z.message : String(z);
        (d0(`Error stashing changes: ${D}`), F("Failed to stash changes"));
      } finally {
        J(!1);
      }
    },
    K = (z) => {
      if (z === "stash") V();
      else B();
    };
  if (Y)
    return B7.default.createElement(
      y,
      { flexDirection: "column", padding: 1 },
      B7.default.createElement(
        y,
        { marginBottom: 1 },
        B7.default.createElement(u6, null),
        B7.default.createElement(M, null, " Checking git status", t0.ellipsis),
      ),
    );
  if (X)
    return B7.default.createElement(
      y,
      { flexDirection: "column", padding: 1 },
      B7.default.createElement(M, { bold: !0, color: "error" }, "Error: ", X),
      B7.default.createElement(
        y,
        { marginTop: 1 },
        B7.default.createElement(M, { dimColor: !0 }, "Press "),
        B7.default.createElement(M, { bold: !0 }, "Escape"),
        B7.default.createElement(M, { dimColor: !0 }, " to cancel"),
      ),
    );
  let H = G.length > 8;
  return B7.default.createElement(
    Mb,
    { title: "Working Directory Has Changes", onCancel: B, borderDimColor: !0 },
    B7.default.createElement(M, null, "Teleport will switch git branches. The following changes were found:"),
    B7.default.createElement(
      y,
      { flexDirection: "column", paddingLeft: 2 },
      G.length > 0
        ? H
          ? B7.default.createElement(M, null, G.length, " files changed")
          : G.map((z, D) => B7.default.createElement(M, { key: D }, z))
        : B7.default.createElement(M, { dimColor: !0 }, "No changes detected"),
    ),
    B7.default.createElement(M, null, "Would you like to stash these changes and continue with teleport?"),
    W
      ? B7.default.createElement(
          y,
          null,
          B7.default.createElement(u6, null),
          B7.default.createElement(M, null, " Stashing changes..."),
        )
      : B7.default.createElement(xA, {
          options: [
            { label: "Stash changes and continue", value: "stash" },
            { label: "Exit", value: "exit" },
          ],
          onChange: K,
          onCancel: () => B(),
        }),
  );
}
function Eh1({ onComplete: A, errorsToIgnore: B = new Set() }) {
  let [Q, Z] = SI.useState(null),
    [G, Y] = SI.useState(!1),
    I = SI.useCallback(async () => {
      let K = await eL0(),
        H = new Set(Array.from(K).filter((z) => !B.has(z)));
      if (H.size === 0) {
        A();
        return;
      }
      if (H.has("needsLogin")) Z("needsLogin");
      else if (H.has("needsGitStash")) Z("needsGitStash");
    }, [A, B]);
  SI.useEffect(() => {
    I();
  }, [I]);
  let W = SI.useCallback(() => {
      G5(0);
    }, []),
    J = SI.useCallback(() => {
      (Y(!1), I());
    }, [I]),
    X = SI.useCallback(() => {
      Y(!0);
    }, [Y]),
    F = SI.useCallback(
      (K) => {
        if (K === "login") X();
        else W();
      },
      [X, W],
    ),
    V = SI.useCallback(() => {
      I();
    }, [I]);
  if (!Q) return null;
  switch (Q) {
    case "needsGitStash":
      return SI.default.createElement(qCB, { onStashAndContinue: V, onCancel: W });
    case "needsLogin": {
      if (G) return SI.default.createElement(gb, { onDone: J, mode: "login", forceLoginMethod: "claudeai" });
      return SI.default.createElement(
        Mb,
        { title: "Log in to Claude", onCancel: W, borderDimColor: !0 },
        SI.default.createElement(
          y,
          { flexDirection: "column" },
          SI.default.createElement(M, { dimColor: !0 }, "Teleport requires a Claude.ai account."),
          SI.default.createElement(
            M,
            { dimColor: !0 },
            "Your Claude Pro/Max subscription will be used by Claude Code.",
          ),
        ),
        SI.default.createElement(xA, {
          options: [
            { label: "Login with Claude account", value: "login" },
            { label: "Exit", value: "exit" },
          ],
          onChange: F,
          onCancel: W,
        }),
      );
    }
  }
}
async function eL0() {
  let A = new Set(),
    [B, Q] = await Promise.all([e41(), b2() ? Yv() : Promise.resolve(!0)]);
  if (Q) A.add("needsLogin");
  if (!B) A.add("needsGitStash");
  return A;
}
var FW1 = new Map();
async function RE() {
  let A = AA();
  if (FW1.has(A)) return FW1.get(A) ?? null;
  try {
    let B = await t41();
    if ((F1(`Git remote URL: ${B}`), !B)) return (F1("No git remote URL found"), FW1.set(A, null), null);
    let Q = vA1(B);
    return (F1(`Parsed repository: ${Q} from URL: ${B}`), FW1.set(A, Q), Q);
  } catch (B) {
    return (F1(`Error detecting repository: ${B}`), FW1.set(A, null), null);
  }
}
function vA1(A) {
  let B = A.trim(),
    Q = [/github\.com[:/]([^/]+\/[^/.]+?)(\.git)?$/, /github\.com[:/]([^/]+\/[^/.]+)$/];
  for (let Z of Q) {
    let G = B.match(Z);
    if (G && G[1]) return (F1(`Parsed repository: ${G[1]} from ${B}`), G[1]);
  }
  if (!B.includes("://") && !B.includes("@") && B.includes("/")) {
    let Z = B.split("/");
    if (Z.length === 2 && Z[0] && Z[1]) {
      let G = Z[1].replace(/\.git$/, "");
      return `${Z[0]}/${G}`;
    }
  }
  return (F1(`Could not parse repository from: ${B}`), null);
}
var VW1 = pB.object({
    id: pB.string(),
    title: pB.string(),
    description: pB.string(),
    status: pB.enum(["idle", "working", "waiting", "completed", "archived", "cancelled", "rejected"]),
    repo: pB
      .object({ name: pB.string(), owner: pB.object({ login: pB.string() }), default_branch: pB.string().optional() })
      .nullable(),
    turns: pB.array(pB.string()),
    created_at: pB.string(),
    updated_at: pB.string(),
  }),
  w35 = pB.array(VW1);
async function ECB() {
  let A = F3()?.accessToken;
  if (A === void 0) throw new Error("No access token found. Please authenticate first.");
  let B = await js();
  if (!B) throw new Error("Unable to get organization UUID");
  return { accessToken: A, orgUUID: B };
}
async function NCB() {
  let { accessToken: A, orgUUID: B } = await ECB(),
    Q = `${$4().BASE_API_URL}/v1/sessions/organizations/${B}/sessions`;
  try {
    let Z = Pc(A),
      G = await $2.get(Q, { headers: Z });
    if (G.status !== 200) throw new Error(`Failed to fetch code sessions: ${G.statusText}`);
    return G.data.data.map((I) => {
      let W = I.session_context.sources.find((X) => X.type === "git_repository"),
        J = null;
      if (W?.url) {
        let X = vA1(W.url);
        if (X) {
          let [F, V] = X.split("/");
          if (F && V) J = { name: V, owner: { login: F }, default_branch: W.revision || void 0 };
        }
      }
      return {
        id: I.id,
        title: I.title || "Untitled",
        description: "",
        status: I.session_status,
        repo: J,
        turns: [],
        created_at: I.created_at,
        updated_at: I.updated_at,
      };
    });
  } catch (Z) {
    let G = Z instanceof Error ? Z : new Error(String(Z));
    throw (U1(G, r91), d0(`Error message: ${G.message}`), Z);
  }
}
async function LCB() {
  let { accessToken: A, orgUUID: B } = await ECB(),
    Q = `${$4().BASE_API_URL}/api/oauth/organizations/${B}/code/sessions`;
  try {
    let Z = Pc(A),
      G = await $2.get(Q, { headers: Z });
    if (G.status !== 200) throw new Error(`Failed to fetch code sessions: ${G.statusText}`);
    let Y = w35.safeParse(G.data);
    if (!Y.success) throw new Error(`Invalid response structure from code sessions API: ${Y.error.message}`);
    return Y.data;
  } catch (Z) {
    let G = Z instanceof Error ? Z : new Error(String(Z));
    throw (U1(G, r91), d0(`Error message: ${G.message}`), Z);
  }
}
function Pc(A) {
  return { Authorization: `Bearer ${A}`, "Content-Type": "application/json", "anthropic-version": "2023-06-01" };
}
function MCB(A) {
  if (A === null) return X3("Session resumed", "info");
  let B = A instanceof I3 ? A.formattedMessage : A.message;
  return X3(`Session resumed without branch: ${B}`, "warning");
}
function OCB() {
  return bA({
    content: `This session is being continued from another machine. Application state may have changed. The updated working directory is ${WQ()}`,
    isMeta: !0,
  });
}
var q35 = `You are coming up with a succinct title for a coding session based on the provided description. The title should be clear, concise, and accurately reflect the content of the coding task.
You should keep it short and simple, ideally no more than 4 words. Avoid using jargon or overly technical terms unless absolutely necessary. The title should be easy to understand for anyone reading it.
You should wrap the title in <title> XML tags. You MUST return your best attempt for the title.

For example:
<title>Fix login button not working on mobile</title>
<title>Update README with installation instructions</title>
<title>Improve performance of data processing script</title>`;
async function RCB(A) {
  try {
    let B = `${q35}

Here is the session description:
<description>${A}</description>

Please generate a title for this session.
`,
      Q = "<title>",
      G = (
        await NI({
          systemPrompt: [],
          userPrompt: B,
          assistantPrompt: "<title>",
          signal: new AbortController().signal,
          isNonInteractiveSession: !0,
          temperature: 0,
          promptCategory: "title_generation",
        })
      ).message.content[0];
    if (G?.type === "text") {
      let I = G.text.trim();
      if (I.startsWith("<title>")) I = I.slice(7);
      if (I.endsWith("</title>")) I = I.slice(0, -8);
      return I.trim();
    }
  } catch (B) {
    d0(`Error generating title: ${B}`);
  }
  return A.length > 75 ? A.slice(0, 75) + "…" : A;
}
async function Nh1(A) {
  if (!(await e41())) {
    let Q = new I3(
      "Git working directory is not clean. Please commit or stash your changes before using --teleport.",
      n1.red(`Error: Git working directory is not clean. Please commit or stash your changes before using --teleport.
`),
    );
    if (A) await A(Q);
    throw Q;
  }
}
async function E35(A) {
  let B = A ? ["fetch", "origin", `${A}:${A}`] : ["fetch", "origin"],
    { code: Q, stderr: Z } = await B2("git", B);
  if (Q !== 0)
    if (A && Z.includes("refspec")) {
      F1(`Specific branch fetch failed, trying to fetch ref: ${A}`);
      let { code: G, stderr: Y } = await B2("git", ["fetch", "origin", A]);
      if (G !== 0) d0(`Warning: Failed to fetch from remote origin: ${Y}`);
    } else d0(`Warning: Failed to fetch from remote origin: ${Z}`);
}
async function N35(A, B) {
  let { code: Q, stderr: Z } = await B2("git", ["checkout", A]);
  if (Q !== 0) {
    F1(`Local checkout failed, trying to checkout from origin: ${Z}`);
    let G = await B2("git", ["checkout", "-b", A, "--track", `origin/${A}`]);
    if (((Q = G.code), (Z = G.stderr), Q !== 0)) {
      F1(`Remote checkout with -b failed, trying without -b: ${Z}`);
      let Y = await B2("git", ["checkout", "--track", `origin/${A}`]);
      ((Q = Y.code), (Z = Y.stderr));
    }
  }
  if (Q !== 0) {
    let G = new I3(
      `Failed to checkout branch '${A}': ${Z}`,
      n1.red(`Error: Failed to checkout branch '${A}': ${Z}
`),
    );
    if (B) await B(G);
    throw G;
  }
}
async function KW1() {
  let { stdout: A } = await B2("git", ["branch", "--show-current"]);
  return A.trim();
}
async function HW1(A, B) {
  try {
    let Q = await KW1();
    if ((F1(`Current branch before teleport: '${Q}'`), B)) {
      (F1(`Switching to branch '${B}'...`), await E35(B), await N35(B));
      let Y = await KW1();
      F1(`Branch after checkout: '${Y}'`);
    } else F1("No branch specified, staying on current branch");
    let Z = await KW1();
    return { messages: [...A, OCB(), MCB(null)], branchName: Z, branchError: null };
  } catch (Q) {
    let Z = await KW1(),
      G = Q instanceof Error ? Q : new Error(String(Q));
    return { messages: [...A, OCB(), MCB(G)], branchName: Z, branchError: G };
  }
}
async function L35(A, B, Q, Z) {
  let G = await RE(),
    Y = `${$4().BASE_API_URL}/api/oauth/organizations/${B}/code/sessions/${A}`;
  if (!G) {
    F1(`Not in git repo, fetching session metadata to provide guidance: ${Y}`);
    try {
      let I = await $2.get(Y, { headers: Q, timeout: 15000 });
      if (I.status === 200) {
        let W = VW1.safeParse(I.data);
        if (W.success) {
          let J = W.data;
          if (J.repo) {
            let X = `${J.repo.owner.login}/${J.repo.name}`,
              F = new I3(
                `You must run claude --teleport from a checkout of ${X}.`,
                n1.red(`Error: You must run claude --teleport from a checkout of ${n1.bold(X)}.
`),
              );
            if (Z) await Z(F);
            throw F;
          } else F1("Session has no repo requirement and not in git directory, proceeding");
        }
      }
    } catch (I) {
      if ($2.isAxiosError(I))
        F1(`Failed to fetch session metadata - Status: ${I.response?.status}, Message: ${I.message}`);
      let W = new I3(
        "You must run claude --teleport from a checkout of the git repo the session was created in.",
        n1.red(`Error: You must run claude --teleport from a checkout of the git repo the session was created in.
`),
      );
      if (Z) await Z(W);
      throw W;
    }
    return;
  }
  F1(`Fetching session metadata from: ${Y}`);
  try {
    let I = await $2.get(Y, { headers: Q, timeout: 15000 });
    if (I.status === 200) {
      let W = VW1.safeParse(I.data);
      if (W.success) {
        let J = W.data;
        if (J.repo) {
          let X = `${J.repo.owner.login}/${J.repo.name}`;
          if ((F1(`Session is for repository: ${X}, current repo: ${G}`), G !== X)) {
            let F = new I3(
              `You must run claude --teleport from a checkout of ${X}.`,
              n1.red(`Error: You must run claude --teleport from a checkout of ${n1.bold(X)}.
`),
            );
            if (Z) await Z(F);
            throw F;
          }
          F1("Repository matches, proceeding with teleport");
        } else F1("Session has no associated repository, proceeding without validation");
      } else F1(`Could not validate session structure: ${W.error.message}`);
    }
  } catch (I) {
    if ($2.isAxiosError(I)) {
      if (
        (F1(`Failed to fetch session metadata - Status: ${I.response?.status}, Message: ${I.message}`),
        I.response?.data)
      )
        F1(`Error response data: ${JSON.stringify(I.response.data)}`);
    } else F1(`Could not fetch session metadata: ${I}`);
  }
}
async function M35(A, B, Q, Z) {
  let G = await RE(),
    Y = `${$4().BASE_API_URL}/v1/sessions/organizations/${B}/sessions/${A}`;
  if (!G) {
    F1(`Not in git repo, fetching session metadata to provide guidance: ${Y}`);
    try {
      let I = await $2.get(Y, { headers: Q, timeout: 15000 });
      if (I.status === 200) {
        let J = I.data.session_context.sources.find((X) => X.type === "git_repository");
        if (J?.url) {
          let X = vA1(J.url);
          if (X) {
            let F = new I3(
              `You must run claude --teleport from a checkout of ${X}.`,
              n1.red(`Error: You must run claude --teleport from a checkout of ${n1.bold(X)}.
`),
            );
            if (Z) await Z(F);
            throw F;
          }
        } else F1("Session has no repo requirement and not in git directory, proceeding");
      }
    } catch (I) {
      if ($2.isAxiosError(I))
        F1(`Failed to fetch session metadata - Status: ${I.response?.status}, Message: ${I.message}`);
      let W = new I3(
        "You must run claude --teleport from a checkout of the git repo the session was created in.",
        n1.red(`Error: You must run claude --teleport from a checkout of the git repo the session was created in.
`),
      );
      if (Z) await Z(W);
      throw W;
    }
    return;
  }
  F1(`Fetching session metadata from: ${Y}`);
  try {
    let I = await $2.get(Y, { headers: Q, timeout: 15000 });
    if (I.status === 200) {
      let J = I.data.session_context.sources.find((X) => X.type === "git_repository");
      if (J?.url) {
        let X = vA1(J.url);
        if (X) {
          if ((F1(`Session is for repository: ${X}, current repo: ${G}`), G !== X)) {
            let F = new I3(
              `You must run claude --teleport from a checkout of ${X}.`,
              n1.red(`Error: You must run claude --teleport from a checkout of ${n1.bold(X)}.
`),
            );
            if (Z) await Z(F);
            throw F;
          }
          F1("Repository matches, proceeding with teleport");
        }
      } else F1("Session has no associated repository, proceeding without validation");
    }
  } catch (I) {
    if ($2.isAxiosError(I)) {
      if (
        (F1(`Failed to fetch session metadata - Status: ${I.response?.status}, Message: ${I.message}`),
        I.response?.data)
      )
        F1(`Error response data: ${JSON.stringify(I.response.data)}`);
    } else F1(`Could not fetch session metadata: ${I}`);
  }
}
async function zW1(A, B) {
  F1(`Resuming code session ID: ${A}`);
  try {
    let Q = process.env.TELEPORT_RESUME_URL;
    if (Q) return (F1("Using TELEPORT_RESUME_URL from environment"), await BM0(Q, void 0, B));
    let Z = F3()?.accessToken;
    if (!Z)
      throw (
        Y1("tengu_teleport_resume_error", { error_type: "no_access_token" }),
        new Error("No access token found. Please authenticate first.")
      );
    let G = await js();
    if (!G)
      throw (
        Y1("tengu_teleport_resume_error", { error_type: "no_org_uuid" }),
        new Error("Unable to get organization UUID for constructing session URL")
      );
    let Y = Pc(Z),
      I = await RE();
    if (Eg(I)) return (F1("Using Sessions API for resume"), await M35(A, G, Y, B), await R35(A, G, Z));
    await L35(A, G, Y, B);
    let W = `${$4().BASE_API_URL}/api/oauth/organizations/${G}/code/sessions/${A}/resume`;
    return await BM0(W, Y, B);
  } catch (Q) {
    if (Q instanceof I3) {
      if (B) await B(Q);
      throw Q;
    }
    let Z = Q instanceof Error ? Q : new Error(String(Q));
    (U1(Z, RT),
      d0(`Error during code session resume: ${Z.message}`),
      Y1("tengu_teleport_resume_error", { error_type: "resume_session_id_catch" }));
    let G = new I3(
      Z.message,
      n1.red(`Error: ${Z.message}
`),
    );
    if (B) await B(G);
    throw G;
  }
}
async function BM0(A, B, Q) {
  F1(`Teleporting from URL: ${A}`);
  let Z = {};
  if (process.env.TELEPORT_HEADERS) {
    F1("Parsing TELEPORT_HEADERS from environment...");
    try {
      ((Z = JSON.parse(process.env.TELEPORT_HEADERS)),
        F1(`Parsed ${Object.keys(Z).length} headers from TELEPORT_HEADERS`));
    } catch (G) {
      let Y = G instanceof Error ? G : new Error(String(G));
      (U1(Y, RT), d0(`Failed to parse TELEPORT_HEADERS: ${Y.message}`));
      let I = new I3(
        `Invalid JSON in TELEPORT_HEADERS: ${Y.message}`,
        n1.red(`Error: Invalid JSON in TELEPORT_HEADERS: ${Y.message}
`),
      );
      if (Q) throw (await Q(I), I);
    }
  } else F1("No TELEPORT_HEADERS environment variable found");
  if (B) {
    for (let [G, Y] of Object.entries(B))
      if (typeof Y !== "string") {
        let I = new Error(`Invalid header value for "${G}": headers must be strings, got ${typeof Y}`);
        throw (U1(I, RT), I);
      }
    ((Z = { ...Z, ...B }), F1(`Added ${Object.keys(B).length} additional headers`));
  }
  try {
    F1("Fetching conversation from remote URL...");
    let G = await UCB(A, Z);
    if (!G) {
      (d0("Remote URL returned empty response"),
        Y1("tengu_teleport_resume_error", {
          error_type: "empty_response",
          url_type: A.startsWith("http") ? "http(s)" : "other",
        }));
      let Y = new I3(
        "Failed to load conversation from remote URL",
        n1.red(`Error: Failed to load conversation from remote URL
`),
      );
      if (Q) throw (await Q(Y), Y);
      throw new Error("Failed to load conversation");
    }
    return (
      F1("Successfully loaded conversation from remote URL"),
      F1(`Response contains ${G.log?.length || 0} messages`),
      F1(`Response branch: ${G.branch || "none specified"}`),
      Y1("tengu_teleport_resume_success", { messages_count: G.log?.length || 0, has_branch: !!G.branch }),
      G
    );
  } catch (G) {
    let Y = G instanceof Error ? G : new Error(String(G));
    (U1(Y, RT),
      d0(`Error during remote URL teleport: ${Y.message}`),
      Y1("tengu_teleport_resume_error", { error_type: "teleport_from_url_catch" }));
    let I = new I3(
      Y.message,
      n1.red(`Error: ${Y.message}
`),
    );
    if (Q) await Q(I);
    throw I;
  }
}
async function DW1(A, B) {
  if (!A) throw new Error("No URL or session ID provided for teleport");
  if (A.startsWith("http:") || A.startsWith("https:")) return BM0(A, void 0, B);
  return zW1(A, B);
}
async function TCB(A) {
  let B = await eL0();
  if (B.size > 0)
    (Y1("tengu_teleport_errors_detected", {
      error_types: Array.from(B).join(","),
      errors_ignored: Array.from(A || []).join(","),
    }),
      await new Promise((Q) => {
        let { unmount: Z } = s6(
          AM0.default.createElement(
            M7,
            null,
            AM0.default.createElement(Eh1, {
              errorsToIgnore: A,
              onComplete: () => {
                (Y1("tengu_teleport_errors_resolved", { error_types: Array.from(B).join(",") }), Z(), Q());
              },
            }),
          ),
          { exitOnCtrlC: !1 },
        );
      }));
}
async function PCB(A, B) {
  return (await TCB(), DW1(A, B));
}
async function jCB(A) {
  return (await TCB(new Set(["needsGitStash"])), QM0(A));
}
function O35(A) {
  if (A && typeof A === "object" && "type" in A) {
    if (A.type === "env_manager_log" || A.type === "control_response") return null;
    if ("session_id" in A) return A;
  }
  return (F1(`Event is not a valid SDKMessage: ${JSON.stringify(A)}`), null);
}
async function R35(A, B, Q) {
  let Z = Pc(Q);
  try {
    let G = `${$4().BASE_API_URL}/v1/sessions/organizations/${B}/sessions/${A}/events`;
    F1(`Fetching events from: ${G}`);
    let Y = await $2.get(G, { headers: Z, timeout: 30000 });
    if (Y.status !== 200) throw new Error(`Failed to fetch session events: ${Y.statusText}`);
    let I = Y.data;
    if (!I?.data || !Array.isArray(I.data)) throw new Error("Invalid events response: missing or invalid data array");
    let W = [];
    for (let X of I.data) {
      let F = O35(X);
      if (F) W.push(F);
    }
    let J;
    try {
      let X = `${$4().BASE_API_URL}/v1/sessions/organizations/${B}/sessions/${A}`;
      F1(`Fetching session details from: ${X}`);
      let F = await $2.get(X, { headers: Z, timeout: 15000 });
      if (F.status === 200) {
        F1(`Session details: ${JSON.stringify(F.data, null, 2)}`);
        let K = F.data.session_context.outcomes?.find((H) => H.type === "git_repository");
        if (K?.git_info?.branches.length) ((J = K.git_info.branches[0]), F1(`Found branch from session context: ${J}`));
      }
    } catch (X) {
      d0(`Could not fetch session details: ${X}`);
    }
    return { log: W, branch: J };
  } catch (G) {
    let Y = G instanceof Error ? G : new Error(String(G));
    if ($2.isAxiosError(G) && G.response?.status === 404)
      throw new I3(
        `${A} not found.`,
        `${A} not found.
${n1.dim("Run /status in Claude Code to check your account.")}`,
      );
    if ((U1(Y, r91), d0(`Error fetching from Sessions API: ${Y.message}`), $2.isAxiosError(G) && G.response?.data))
      d0(`API error response: ${JSON.stringify(G.response.data)}`);
    throw new Error(`Failed to fetch session from Sessions API: ${Y.message}`);
  }
}
async function T35(A) {
  try {
    await Yv();
    let B = F3()?.accessToken;
    if (!B) return (d0("No access token found for remote session creation"), null);
    let Q = await js();
    if (!Q) return (d0("Unable to get organization UUID for remote session creation"), null);
    let Z = await RE(),
      G = null;
    if (Z) {
      let [H, z] = Z.split("/");
      if (H && z) {
        let D = await KW1();
        G = { type: "git_repository", url: `https://github.com/${H}/${z}`, revision: D || null };
      } else d0(`Invalid repository format: ${Z} - expected 'owner/name'`);
    }
    let Y = await RCB(A),
      I = Pc(B),
      W = "env_011CSUkSjSxeWzWtatWym6Yn",
      J = `${$4().BASE_API_URL}/v1/sessions/organizations/${Q}/sessions`,
      X = {
        sources: G ? [G] : [],
        cwd: WQ(),
        outcomes: null,
        custom_system_prompt: null,
        append_system_prompt: null,
        model: null,
      },
      F = { title: Y, events: [], session_context: X, environment_id: W },
      V = await $2.post(J, F, { headers: I });
    if (V.status !== 200 && V.status !== 201)
      return (
        d0(`API request failed with status ${V.status}: ${V.statusText}

Response data: ${JSON.stringify(V.data, null, 2)}`),
        null
      );
    let K = V.data;
    if (K && typeof K.id === "string")
      return (F1(`Successfully created remote session: ${K.id}`), { id: K.id, title: K.title || Y });
    return (d0(`Cannot determine session ID from API response: ${JSON.stringify(V.data)}`), null);
  } catch (B) {
    let Q = B instanceof Error ? B : new Error(String(B));
    if ((U1(Q, RT), Q instanceof $2.AxiosError)) d0(`Error data: ${JSON.stringify(Q.response?.data, null, 2)}`);
    return (d0(`Error creating remote session: ${Q.message}`), null);
  }
}
async function P35(A) {
  F1(`teleportToRemoteLegacy: Creating remote session with description: ${A.slice(0, 100)}...`);
  try {
    await Yv();
    let B = F3()?.accessToken;
    if (!B) return (d0("No access token found for remote session creation"), null);
    let Q = await js();
    if (!Q) return (d0("Unable to get organization UUID for remote session creation"), null);
    let Z = await RE(),
      G = null;
    if (Z) {
      F1(`Detected repository: ${Z}`);
      let [K, H] = Z.split("/");
      if (K && H) {
        let z = await _$A();
        ((G = { name: H, owner: { login: K }, default_branch: z }),
          F1(`Repository data prepared: ${JSON.stringify(G)}`));
      } else d0(`Invalid repository format: ${Z} - expected 'owner/name'`);
    } else F1("No repository detected, creating session without repo context");
    F1("Generating title for session...");
    let Y = await RCB(A);
    F1(`Generated title: ${Y}`);
    let I = `${$4().BASE_API_URL}/api/oauth/organizations/${Q}/code/sessions`,
      W = Pc(B),
      J = { description: A, title: Y, repo: G };
    (F1(`Making API request to: ${I}`), F1(`Request body: ${JSON.stringify(J)}`));
    let X = await $2.post(I, J, { headers: W });
    if (X.status !== 200 && X.status !== 201)
      return (
        d0(`API request failed with status ${X.status}: ${X.statusText}

Response data: ${JSON.stringify(X.data, null, 2)}`),
        null
      );
    let F = VW1.safeParse(X.data);
    if (F.success) {
      let K = F.data;
      return (F1(`Successfully created remote session: ${K.id}`), { id: K.id, title: K.title });
    }
    let V = X.data;
    if (typeof V === "object" && V !== null) {
      let { id: K, title: H } = V;
      if (typeof K === "string") return { id: K, title: typeof H === "string" ? H : Y };
    }
    return (d0(`Cannot determine session ID from API response: ${JSON.stringify(X.data)}`), null);
  } catch (B) {
    let Q = B instanceof Error ? B : new Error(String(B));
    if ((U1(Q, RT), Q instanceof $2.AxiosError)) d0(`Error data: ${JSON.stringify(Q.response?.data, null, 2)}`);
    return (d0(`Error creating remote session: ${Q.message}`), null);
  }
}
async function QM0(A) {
  let B = await RE();
  if (Eg(B)) return (F1("Using Sessions API for creating remote session"), T35(A));
  return (F1("Using legacy API for creating remote session"), P35(A));
}
var Q7 = A1(V1(), 1);
var $S = A1(V1(), 1);
var CW1 = A1(V1(), 1);
function SCB() {
  return CW1.createElement(NA, { height: 1 }, CW1.createElement(BO, null));
}
var US = A1(V1(), 1);
function yCB({ progressMessagesForMessage: A, tool: B, tools: Q, param: Z, verbose: G }) {
  let [Y] = sB();
  if (typeof Z.content === "string" && Z.content.startsWith(P$))
    return US.createElement(NA, { height: 1 }, US.createElement(BO, null));
  if (typeof Z.content === "string" && Z.content.startsWith(FE0)) {
    let I = Z.content.substring(FE0.length);
    return US.createElement($b1, { plan: I, themeName: Y });
  }
  if (!B) return US.createElement(K5, { result: Z.content, verbose: G });
  return B.renderToolUseErrorMessage(Z.content, { progressMessagesForMessage: n01(A), tools: Q, verbose: G });
}
var UW1 = A1(V1(), 1);
function kCB({ input: A, progressMessagesForMessage: B, style: Q, tool: Z, tools: G, messages: Y, verbose: I }) {
  let { columns: W } = IB(),
    [J] = sB();
  if (!Z) return UW1.createElement(o8, null);
  let X = Z.inputSchema.safeParse(A);
  if (!X.success) return UW1.createElement(o8, null);
  return Z.renderToolUseRejectedMessage(X.data, {
    columns: W,
    messages: Y,
    tools: G,
    verbose: I,
    progressMessagesForMessage: n01(B),
    style: Q,
    theme: J,
  });
}
var $W1 = A1(V1(), 1);
var ANSI_RESET = "\x1B[0m\x1B(B";
function xCB({ message: A, progressMessagesForMessage: B, style: Q, tool: Z, tools: G, verbose: Y, width: I }) {
  let [W] = sB();
  if (!A.toolUseResult || !Z) return null;
  let J = Z.renderToolResultMessage(A.toolUseResult, n01(B), { style: Q, theme: W, tools: G, verbose: Y });
  if (J === null) return null;
  return $W1.createElement(y, { flexDirection: "row", width: I }, J, $W1.createElement(M, null, ANSI_RESET));
}
var vCB = A1(V1(), 1);
function j35(A, B) {
  let Q = null;
  for (let Z of B) {
    if (Z.type !== "assistant" || !Array.isArray(Z.message.content)) continue;
    for (let G of Z.message.content) if (G.type === "tool_use" && G.id === A) Q = G;
  }
  return Q;
}
function bCB(A, B, Q) {
  return vCB.useMemo(() => {
    let Z = j35(A, Q);
    if (!Z) return null;
    let G = B.find((Y) => Y.name === Z.name);
    if (!G) return null;
    return { tool: G, toolUse: Z };
  }, [A, Q, B]);
}
function fCB({
  param: A,
  message: B,
  messages: Q,
  progressMessagesForMessage: Z,
  style: G,
  tools: Y,
  verbose: I,
  width: W,
}) {
  let J = bCB(A.tool_use_id, Y, Q);
  if (!J) return null;
  if (A.content === Ub) return $S.createElement(SCB, null);
  if (A.content === WI1 || A.content === P$)
    return $S.createElement(kCB, {
      input: J.toolUse.input,
      progressMessagesForMessage: Z,
      tool: J.tool,
      tools: Y,
      messages: Q,
      style: G,
      verbose: I,
    });
  if (A.is_error)
    return $S.createElement(yCB, { progressMessagesForMessage: Z, tool: J.tool, tools: Y, param: A, verbose: I });
  return $S.createElement(xCB, {
    message: B,
    progressMessagesForMessage: Z,
    style: G,
    tool: J.tool,
    tools: Y,
    verbose: I,
    width: W,
  });
}
var qJ = A1(V1(), 1);
var ZM0 = A1(V1(), 1);
var Lh1 = A1(V1(), 1);
import { EventEmitter as S35 } from "events";
function y35() {
  let A = new S35();
  A.setMaxListeners(100);
  let B = null,
    Q = !0;
  return {
    subscribe(Z) {
      if ((A.on("blink", Z), A.listenerCount("blink") === 1))
        B = setInterval(() => {
          ((Q = !Q), A.emit("blink"));
        }, 600);
      return Q;
    },
    unsubscribe(Z) {
      if ((A.off("blink", Z), A.listenerCount("blink") === 0 && B)) (clearInterval(B), (B = null));
    },
    getCurrentState() {
      return Q;
    },
  };
}
var hCB = YA(y35);
function gCB(A) {
  let B = hCB(),
    [Q, Z] = Lh1.useState(B.getCurrentState());
  return (
    Lh1.useEffect(() => {
      if (!A) return;
      let G = hCB(),
        Y = () => Z(G.getCurrentState()),
        I = G.subscribe(Y);
      return (
        Z(I),
        () => {
          G.unsubscribe(Y);
        }
      );
    }, [A]),
    A ? Q : !0
  );
}
function uCB({ isError: A, isUnresolved: B, shouldAnimate: Q }) {
  let Z = gCB(Q);
  return ZM0.default.createElement(
    y,
    { minWidth: 2 },
    ZM0.default.createElement(
      M,
      { color: B ? void 0 : A ? "error" : "success", dimColor: B },
      !Q || Z || A || !B ? DO : " ",
    ),
  );
}
function mCB({
  param: A,
  addMargin: B,
  tools: Q,
  verbose: Z,
  erroredToolUseIDs: G,
  inProgressToolUseIDs: Y,
  resolvedToolUseIDs: I,
  progressMessagesForMessage: W,
  shouldAnimate: J,
  shouldShowDot: X,
  inProgressToolCallCount: F,
}) {
  let V = IB(),
    [K] = sB(),
    H = Q.find((O) => O.name === A.name);
  if (!H) return (U1(new Error(`Tool ${A.name} not found`), j3A), null);
  let z = I.has(A.id),
    D = !Y.has(A.id) && !z,
    C = H.inputSchema.safeParse(A.input),
    w = H.userFacingName(C.success ? C.data : void 0),
    E = H.userFacingNameBackgroundColor?.(C.success ? C.data : void 0);
  if (w === "") return null;
  let L = C.success ? k35(H, C.data, { theme: K, verbose: Z }) : null;
  if (L === null) return null;
  return qJ.default.createElement(
    y,
    { flexDirection: "row", justifyContent: "space-between", marginTop: B ? 1 : 0, width: "100%" },
    qJ.default.createElement(
      y,
      { flexDirection: "column" },
      qJ.default.createElement(
        y,
        { flexDirection: "row", flexWrap: "nowrap", minWidth: w.length + (X ? 2 : 0) },
        X &&
          (D
            ? qJ.default.createElement(y, { minWidth: 2 }, qJ.default.createElement(M, { dimColor: D }, DO))
            : qJ.default.createElement(uCB, { shouldAnimate: J, isUnresolved: !z, isError: G.has(A.id) })),
        qJ.default.createElement(
          y,
          { flexShrink: 0 },
          qJ.default.createElement(
            M,
            { bold: !0, wrap: "truncate-end", backgroundColor: E, color: E ? "inverseText" : void 0 },
            w,
          ),
        ),
        L !== "" && qJ.default.createElement(y, { flexWrap: "nowrap" }, qJ.default.createElement(M, null, "(", L, ")")),
        H.name === BASH_TOOL_NAME &&
          C.success &&
          C.data.timeout &&
          (() => {
            let O = C.data.timeout,
              R = u11();
            if (O !== R) {
              let P = Math.round(O / 1000),
                _;
              if (P >= 60) _ = `${P / 60}m`;
              else _ = `${P}s`;
              return qJ.default.createElement(
                y,
                { flexWrap: "nowrap", marginLeft: 1 },
                qJ.default.createElement(M, { dimColor: !0 }, "timeout: ", _),
              );
            }
            return null;
          })(),
      ),
      !z && !D && x35(H, Q, W, { verbose: Z, inProgressToolCallCount: F }, V),
      !z && D && v35(H),
    ),
  );
}
function k35(A, B, { theme: Q, verbose: Z }) {
  try {
    let G = A.inputSchema.safeParse(B);
    if (!G.success) return "";
    return A.renderToolUseMessage(G.data, { theme: Q, verbose: Z });
  } catch (G) {
    return (U1(new Error(`Error rendering tool use message for ${A.name}: ${G}`), P3A), "");
  }
}
function _35(A) {
  if (A.length === 0) return null;
  let B = A[A.length - 1];
  if (!B) return null;
  return qJ.default.createElement(
    NA,
    null,
    qJ.default.createElement(
      M,
      { dimColor: !0 },
      "Running hook ",
      qJ.default.createElement(M, { bold: !0 }, B.data.hookName),
      "...",
    ),
  );
}
function x35(A, B, Q, { verbose: Z, inProgressToolCallCount: G }, Y) {
  let I = Q.filter((J) => J.data?.type !== "running_hook"),
    W = Q.filter((J) => J.data?.type === "running_hook");
  try {
    let J = A.renderToolUseProgressMessage(I, {
        tools: B,
        verbose: Z,
        terminalSize: Y,
        inProgressToolCallCount: G ?? 1,
      }),
      X = _35(W);
    return qJ.default.createElement(qJ.default.Fragment, null, X, J);
  } catch (J) {
    return (U1(new Error(`Error rendering tool use progress message for ${A.name}: ${J}`), R3A), null);
  }
}
function v35(A) {
  try {
    return A.renderToolUseQueuedMessage?.();
  } catch (B) {
    return (U1(new Error(`Error rendering tool use queued message for ${A.name}: ${B}`), T3A), null);
  }
}
var G6 = A1(V1(), 1);
function dCB({ param: { text: A }, addMargin: B, shouldShowDot: Q }) {
  let { columns: Z } = IB(),
    [G] = sB();
  if (VI1(A)) return null;
  if (ZF2(A)) {
    let Y = PZ(),
      W =
        Y === "team" || Y === "enterprise"
          ? null
          : G6.default.createElement(M, { dimColor: !0 }, "/upgrade to increase your usage limit."),
      J = Sx() || b2();
    return G6.default.createElement(
      NA,
      null,
      G6.default.createElement(
        y,
        { flexDirection: "column" },
        G6.default.createElement(M, { color: "error" }, A),
        J && W,
      ),
    );
  }
  if (A.startsWith(IE0)) {
    let Y = Number(A.split("|")[1] ?? 0),
      I = iC(Y),
      W = G6.default.createElement(M, { dimColor: !0 }, "/upgrade to increase your usage limit."),
      J = Sx() || b2();
    return G6.default.createElement(
      NA,
      null,
      G6.default.createElement(
        y,
        { flexDirection: "column" },
        G6.default.createElement(
          M,
          { color: "error" },
          "Claude usage limit reached.",
          Y ? ` Your limit will reset at ${I}.` : "",
        ),
        J && W,
      ),
    );
  }
  switch (A) {
    case JI1:
      return null;
    case GI1:
      return G6.default.createElement(
        NA,
        { height: 1 },
        G6.default.createElement(M, { color: "error" }, "Context low · Run /compact to compact & continue"),
      );
    case YE0:
      return G6.default.createElement(
        NA,
        { height: 1 },
        G6.default.createElement(
          M,
          { color: "error" },
          "Credit balance too low · Add funds: https://console.anthropic.com/settings/billing",
        ),
      );
    case zb1:
      return G6.default.createElement(NA, { height: 1 }, G6.default.createElement(M, { color: "error" }, zb1));
    case Db1:
      return G6.default.createElement(NA, { height: 1 }, G6.default.createElement(M, { color: "error" }, Db1));
    case Cb1:
      return G6.default.createElement(NA, { height: 1 }, G6.default.createElement(M, { color: "error" }, Cb1));
    case Ub1:
      return G6.default.createElement(
        NA,
        { height: 1 },
        G6.default.createElement(
          M,
          { color: "error" },
          Ub1,
          process.env.API_TIMEOUT_MS &&
            G6.default.createElement(
              G6.default.Fragment,
              null,
              " ",
              "(API_TIMEOUT_MS=",
              process.env.API_TIMEOUT_MS,
              "ms, try increasing it)",
            ),
        ),
      );
    case OPUS_OVERLOAD_ERROR:
    case f01:
      return G6.default.createElement(
        NA,
        null,
        G6.default.createElement(
          y,
          { flexDirection: "column", gap: 1 },
          G6.default.createElement(M, { color: "error" }, "We are experiencing high demand for Opus 4."),
          G6.default.createElement(
            M,
            null,
            "To continue immediately, use /model to switch to",
            " ",
            uP(Px()),
            " and continue coding.",
          ),
        ),
      );
    case wI1:
      return G6.default.createElement(NA, { height: 1 }, G6.default.createElement(BO, null));
    case XE0:
      return null;
    default:
      if (A.startsWith(API_ERROR))
        return G6.default.createElement(
          NA,
          null,
          G6.default.createElement(M, { color: "error" }, A === API_ERROR ? `${API_ERROR}: Please wait a moment and try again.` : A),
        );
      return G6.default.createElement(
        y,
        {
          alignItems: "flex-start",
          flexDirection: "row",
          justifyContent: "space-between",
          marginTop: B ? 1 : 0,
          width: "100%",
        },
        G6.default.createElement(
          y,
          { flexDirection: "row" },
          Q && G6.default.createElement(y, { minWidth: 2 }, G6.default.createElement(M, { color: "text" }, DO)),
          G6.default.createElement(
            y,
            { flexDirection: "column", width: Z - 6 },
            G6.default.createElement(M, null, PX(A, G)),
          ),
        ),
      );
  }
}
var wS = A1(V1(), 1);
function Mh1({ param: { text: A }, addMargin: B }) {
  let Q = tQ(A, "bash-input");
  if (!Q) return null;
  return wS.createElement(
    y,
    { flexDirection: "column", marginTop: B ? 1 : 0, width: "100%" },
    wS.createElement(
      y,
      null,
      wS.createElement(M, { color: "bashBorder" }, "!"),
      wS.createElement(M, { dimColor: !0 }, " ", Q),
    ),
  );
}
var wW1 = A1(V1(), 1);
function cCB({ addMargin: A, param: { text: B } }) {
  let Q = tQ(B, "command-message"),
    Z = tQ(B, "command-args");
  if (!Q) return null;
  return wW1.createElement(
    y,
    { flexDirection: "column", marginTop: A ? 1 : 0, width: "100%" },
    wW1.createElement(M, { dimColor: !0 }, "> /", Q, " ", Z),
  );
}
var jc = A1(V1(), 1);
var aF = A1(V1(), 1);
function lCB({ text: A, thinkingMetadata: B }) {
  if (!B || B.triggers.length === 0) return aF.createElement(M, { dimColor: !0 }, A);
  let Q = B.disabled ? void 0 : Cs[B.level],
    Z = fw1(A, B.triggers);
  return aF.createElement(
    aF.Fragment,
    null,
    Z.map((G, Y) => {
      if (G.isTrigger)
        if (bw1(G.text))
          return aF.createElement(
            M,
            { key: Y },
            G.text.split("").map((W, J) => aF.createElement(M, { key: J, color: Y51(J, !1) }, W)),
          );
        else return aF.createElement(M, { key: Y, dimColor: !0, color: Q }, G.text);
      return aF.createElement(M, { key: Y, dimColor: !0 }, G.text);
    }),
  );
}
function pCB({ addMargin: A, param: { text: B }, thinkingMetadata: Q }) {
  let { columns: Z } = IB();
  if (!B) return (U1(new Error("No content found in user prompt message"), PYA), null);
  let G = B.trim();
  return jc.default.createElement(
    y,
    { flexDirection: "row", marginTop: A ? 1 : 0, width: "100%" },
    jc.default.createElement(y, { minWidth: 2, width: 2 }, jc.default.createElement(M, { dimColor: !0 }, ">")),
    jc.default.createElement(
      y,
      { flexDirection: "column", width: Z - 4 },
      jc.default.createElement(M, { wrap: "wrap" }, jc.default.createElement(lCB, { text: G, thinkingMetadata: Q })),
    ),
  );
}
var _Y = A1(V1(), 1);
var hD = A1(V1(), 1);
var iCB = A1(vG1(), 1);
function b35() {
  return iCB.sample(["Got it.", "Good to know.", "Noted."]);
}
function nCB({ param: { text: A }, addMargin: B }) {
  let Q = tQ(A, "user-memory-input");
  if (!Q) return null;
  return hD.createElement(
    y,
    { flexDirection: "column", marginTop: B ? 1 : 0, width: "100%" },
    hD.createElement(
      y,
      null,
      hD.createElement(M, { color: "remember" }, "#"),
      hD.createElement(M, { color: "remember" }, " ", Q),
    ),
    hD.createElement(NA, { height: 1 }, hD.createElement(M, { dimColor: !0 }, b35())),
  );
}
var GM0 = A1(V1(), 1);
function aCB({ content: A, verbose: B }) {
  let Q = tQ(A, "bash-stdout") ?? "",
    Z = tQ(A, "bash-stderr") ?? "";
  return GM0.createElement(kd, { content: { stdout: Q, stderr: Z }, verbose: !!B });
}
var gD = A1(V1(), 1);
function sCB({ content: A }) {
  let B = tQ(A, "local-command-stdout"),
    Q = tQ(A, "local-command-stderr");
  if (!B && !Q) return gD.createElement(NA, null, gD.createElement(M, { dimColor: !0 }, PD));
  let Z = [];
  if (B?.trim()) Z.push(gD.createElement(NA, { key: "stdout" }, gD.createElement(M, { color: "text" }, B.trim())));
  if (Q?.trim()) Z.push(gD.createElement(NA, { key: "stderr" }, gD.createElement(M, { color: "error" }, Q.trim())));
  return Z;
}
var qS = A1(V1(), 1);
function bA1({ param: { text: A }, addMargin: B }) {
  let Q = tQ(A, "background-task-input");
  if (!Q) return null;
  return qS.createElement(
    y,
    { flexDirection: "column", marginTop: B ? 1 : 0, width: "100%" },
    qS.createElement(
      y,
      null,
      qS.createElement(M, { color: "background" }, "&"),
      qS.createElement(M, { dimColor: !0 }, " ", Q),
    ),
  );
}
var qW1 = A1(V1(), 1);
function rCB({ content: A }) {
  let B = tQ(A, "background-task-output") ?? "";
  return qW1.createElement(NA, null, qW1.createElement(M, { dimColor: !0 }, B));
}
function Oh1({ addMargin: A, param: B, verbose: Q, thinkingMetadata: Z }) {
  if (B.text.trim() === PD) return null;
  if (B.text.startsWith("<bash-stdout") || B.text.startsWith("<bash-stderr"))
    return _Y.createElement(aCB, { content: B.text, verbose: Q });
  if (B.text.startsWith("<background-task-output>")) return _Y.createElement(rCB, { content: B.text });
  if (B.text.startsWith("<local-command-stdout") || B.text.startsWith("<local-command-stderr"))
    return _Y.createElement(sCB, { content: B.text });
  if (B.text === REQUEST_INTERRUPTED_MESSAGE || B.text === P$) return _Y.createElement(NA, { height: 1 }, _Y.createElement(BO, null));
  if (B.text.includes("<bash-input>")) return _Y.createElement(Mh1, { addMargin: A, param: B });
  if (B.text.includes("<background-task-input>")) return _Y.createElement(bA1, { addMargin: A, param: B });
  if (B.text.includes("<command-message>")) return _Y.createElement(cCB, { addMargin: A, param: B });
  if (B.text.includes("<user-memory-input>")) return _Y.createElement(nCB, { addMargin: A, param: B });
  return _Y.createElement(pCB, { addMargin: A, param: B, thinkingMetadata: Z });
}
var EW1 = A1(V1(), 1);
function oCB({ param: { thinking: A }, addMargin: B = !1 }) {
  let [Q] = sB();
  if (!A) return null;
  return EW1.default.createElement(
    y,
    { flexDirection: "column", gap: 1, marginTop: B ? 1 : 0, width: "100%" },
    EW1.default.createElement(M, { dimColor: !0, italic: !0 }, "✻ Thinking…"),
    EW1.default.createElement(
      y,
      { paddingLeft: 2 },
      EW1.default.createElement(M, { dimColor: !0, italic: !0 }, PX(A, Q)),
    ),
  );
}
var YM0 = A1(V1(), 1);
function tCB({ addMargin: A = !1 }) {
  return YM0.default.createElement(
    y,
    { marginTop: A ? 1 : 0 },
    YM0.default.createElement(M, { dimColor: !0, italic: !0 }, "✻ Thinking…"),
  );
}
var fX = A1(V1(), 1);
import { relative as fA1, sep as h35 } from "path";
var fO = A1(V1(), 1);
import { relative as f35 } from "path";
function eCB({ attachment: A, verbose: B }) {
  if (A.files.length === 0) return null;
  let Q = A.files.reduce((G, Y) => G + Y.diagnostics.length, 0),
    Z = A.files.length;
  if (B)
    return fO.default.createElement(
      y,
      { flexDirection: "column" },
      A.files.map((G, Y) =>
        fO.default.createElement(
          fO.default.Fragment,
          { key: Y },
          fO.default.createElement(
            NA,
            null,
            fO.default.createElement(
              M,
              { dimColor: !0, wrap: "wrap" },
              n1.bold(f35(AA(), G.uri.replace("file://", "").replace("_claude_fs_right:", ""))),
              " ",
              n1.dim(
                G.uri.startsWith("file://")
                  ? "(file://)"
                  : G.uri.startsWith("_claude_fs_right:")
                    ? "(claude_fs_right)"
                    : `(${G.uri.split(":")[0]})`,
              ),
              ":",
            ),
          ),
          G.diagnostics.map((I, W) =>
            fO.default.createElement(
              NA,
              { key: W },
              fO.default.createElement(
                M,
                { dimColor: !0, wrap: "wrap" },
                "  ",
                FE.getSeveritySymbol(I.severity),
                " [Line ",
                I.range.start.line + 1,
                ":",
                I.range.start.character + 1,
                "] ",
                I.message,
                I.code ? ` [${I.code}]` : "",
                I.source ? ` (${I.source})` : "",
              ),
            ),
          ),
        ),
      ),
    );
  else
    return fO.default.createElement(
      NA,
      null,
      fO.default.createElement(
        M,
        { dimColor: !0, wrap: "wrap" },
        `Found ${n1.bold(Q)} new diagnostic ${Q === 1 ? "issue" : "issues"} in ${Z} ${Z === 1 ? "file" : "files"} (ctrl-o to expand)`,
      ),
    );
}
function AUB({ attachment: A, addMargin: B, verbose: Q }) {
  switch (A.type) {
    case "directory":
      return fX.default.createElement(u$, { text: `Listed directory ${n1.bold(fA1(AA(), A.path) + h35)}` });
    case "file":
    case "already_read_file":
      if (A.content.type === "notebook")
        return fX.default.createElement(u$, {
          text: `Read ${n1.bold(fA1(AA(), A.filename))} (${A.content.file.cells.length} cells)`,
        });
      return fX.default.createElement(u$, {
        text: `Read ${n1.bold(fA1(AA(), A.filename))} (${A.content.type === "text" ? `${A.content.file.numLines}${A.truncated ? "+" : ""} lines` : `${n1.bold(dW(A.content.file.originalSize))}`})`,
      });
    case "compact_file_reference":
      return fX.default.createElement(u$, { text: `Referenced file ${n1.bold(fA1(AA(), A.filename))}` });
    case "selected_lines_in_ide":
      return fX.default.createElement(u$, {
        text: `⧉ Selected ${n1.bold(A.lineEnd - A.lineStart + 1)} lines from ${n1.bold(fA1(AA(), A.filename))} in ${A.ideName}`,
      });
    case "nested_memory":
      return fX.default.createElement(u$, { text: n1.bold(fA1(AA(), A.path)) });
    case "queued_command": {
      let Z = typeof A.prompt === "string" ? A.prompt : Lb1(A.prompt) || "";
      return fX.default.createElement(Oh1, { addMargin: B, param: { text: Z, type: "text" }, verbose: Q });
    }
    case "todo":
      if (A.context === "post-compact")
        return fX.default.createElement(u$, {
          text: `Todo list read (${A.itemCount} ${A.itemCount === 1 ? "item" : "items"})`,
        });
      return null;
    case "diagnostics":
      return fX.default.createElement(eCB, { attachment: A, verbose: Q });
    case "mcp_resource":
      return fX.default.createElement(u$, { text: `Read MCP resource ${n1.bold(A.name)} from ${A.server}` });
    case "command_permissions":
      if (Q)
        return fX.default.createElement(u$, {
          text: `Allowed ${n1.bold(A.allowedTools.length)} tools for this command: ${A.allowedTools.join(", ")}`,
        });
      return fX.default.createElement(u$, { text: `Allowed ${n1.bold(A.allowedTools.length)} tools for this command` });
    case "async_hook_response": {
      if (!Q) return fX.default.createElement(u$, { text: `Async hook ${n1.bold(A.hookEvent)} completed` });
      let Z = A.response,
        G = `Async hook ${n1.bold(A.hookEvent)} completed:
`;
      if (Z.systemMessage) G += `${Z.systemMessage}`;
      else if (
        Z.hookSpecificOutput &&
        "additionalContext" in Z.hookSpecificOutput &&
        Z.hookSpecificOutput.additionalContext
      )
        G += `${Z.hookSpecificOutput.additionalContext}`;
      return fX.default.createElement(u$, { text: G });
    }
    case "agent_mention":
    case "background_remote_session_status":
    case "background_shell_status":
    case "edited_image_file":
    case "edited_text_file":
    case "memory":
    case "opened_file_in_ide":
    case "output_style":
    case "plan_mode":
    case "todo_reminder":
    case "ultramemory":
      return null;
  }
}
function u$({ text: A }) {
  return fX.default.createElement(NA, null, fX.default.createElement(M, { dimColor: !0, wrap: "wrap" }, A.trim()));
}
var IK = A1(V1(), 1);
function Rh1({ message: A, addMargin: B, verbose: Q }) {
  if (!Q && A.level === "info") return null;
  let Z = A.content;
  return IK.createElement(
    y,
    { flexDirection: "row", marginTop: B && !Q ? 1 : 0, width: "100%" },
    IK.createElement(g35, {
      content: Z,
      addMargin: B,
      dot: A.level !== "info",
      color: A.level === "warning" ? "warning" : void 0,
      dimColor: A.level !== "warning",
    }),
  );
}
function g35({ content: A, addMargin: B, dot: Q, color: Z, dimColor: G }) {
  let { columns: Y } = IB();
  return IK.createElement(
    y,
    { flexDirection: "row", marginTop: B ? 1 : 0, width: "100%" },
    Q && IK.createElement(y, { minWidth: 2 }, IK.createElement(M, { color: Z, dimColor: G }, DO)),
    IK.createElement(
      y,
      { flexDirection: "column", width: Y - 10 },
      IK.createElement(M, { color: Z, dimColor: G, wrap: "wrap" }, A.trim()),
    ),
  );
}
var IM0 = A1(V1(), 1);
var Sc = A1(V1(), 1);
function u35({ width: A = "auto", dividerChar: B, dividerColor: Q, dividerDimColor: Z = !0, boxProps: G }) {
  return Sc.default.createElement(y, {
    width: A,
    borderStyle: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: B || "─",
      bottomLeft: "",
      left: "",
    },
    borderColor: Q,
    borderDimColor: Z,
    flexGrow: 1,
    borderBottom: !0,
    borderTop: !1,
    borderLeft: !1,
    borderRight: !1,
    ...G,
  });
}
function m35({
  title: A,
  width: B = "auto",
  padding: Q = 0,
  titlePadding: Z = 1,
  titleColor: G = "text",
  titleDimColor: Y = !0,
  dividerChar: I = "─",
  dividerColor: W,
  dividerDimColor: J = !0,
  boxProps: X,
}) {
  let F = Sc.default.createElement(u35, { dividerChar: I, dividerColor: W, dividerDimColor: J, boxProps: X });
  if (!A) return Sc.default.createElement(y, { paddingLeft: Q, paddingRight: Q }, F);
  return Sc.default.createElement(
    y,
    { width: B, paddingLeft: Q, paddingRight: Q, gap: Z },
    F,
    Sc.default.createElement(y, null, Sc.default.createElement(M, { color: G, dimColor: Y }, A)),
    F,
  );
}
var ab = m35;
function BUB() {
  let { columns: A } = IB();
  return IM0.createElement(ab, { dividerChar: "═", title: "Conversation compacted · ctrl+o for history", width: A });
}
var KG = A1(V1(), 1);
function QUB({ message: A, verbose: B }) {
  let Q = A.content === "cancelled";
  if (!B)
    return KG.createElement(
      NA,
      null,
      KG.createElement(M, { dimColor: !0 }, "Hook "),
      KG.createElement(M, { dimColor: !0, bold: !0 }, "PostToolUse:", A.toolName),
      KG.createElement(M, { dimColor: !0 }, " ", Q ? "cancelled" : "completed"),
    );
  return KG.createElement(
    y,
    { flexDirection: "column", width: "100%" },
    KG.createElement(
      NA,
      null,
      KG.createElement(M, { dimColor: !0 }, "Hook "),
      KG.createElement(M, { dimColor: !0, bold: !0 }, "PostToolUse:", A.toolName),
      KG.createElement(M, { dimColor: !0 }, " ", Q ? "cancelled" : "completed", ":"),
    ),
    KG.createElement(y, { paddingLeft: 5 }, KG.createElement(Rh1, { message: A, addMargin: !1, verbose: B })),
  );
}
function sb({
  message: A,
  messages: B,
  addMargin: Q,
  tools: Z,
  verbose: G,
  erroredToolUseIDs: Y,
  inProgressToolUseIDs: I,
  resolvedToolUseIDs: W,
  progressMessagesForMessage: J,
  shouldAnimate: X,
  shouldShowDot: F,
  style: V,
  width: K,
}) {
  switch (A.type) {
    case "attachment":
      return Q7.createElement(AUB, { addMargin: Q, attachment: A.attachment, verbose: G });
    case "assistant":
      return Q7.createElement(
        y,
        { flexDirection: "column", width: "100%" },
        A.message.content.map((H, z) =>
          Q7.createElement(c35, {
            key: z,
            param: H,
            addMargin: Q,
            tools: Z,
            verbose: G,
            erroredToolUseIDs: Y,
            inProgressToolUseIDs: I,
            resolvedToolUseIDs: W,
            progressMessagesForMessage: J,
            shouldAnimate: X,
            shouldShowDot: F,
            width: K,
            inProgressToolCallCount: I.size,
          }),
        ),
      );
    case "user":
      return Q7.createElement(
        y,
        { flexDirection: "column", width: "100%" },
        A.message.content.map((H, z) =>
          Q7.createElement(d35, {
            key: z,
            message: A,
            messages: B,
            addMargin: Q,
            tools: Z,
            progressMessagesForMessage: J,
            param: H,
            style: V,
            verbose: G,
          }),
        ),
      );
    case "system":
      if (A.subtype === "compact_boundary") return Q7.createElement(BUB, null);
      if (A.subtype === "post_tool_hook_success" || A.subtype === "post_tool_hook_cancelled")
        return Q7.createElement(QUB, { message: A, verbose: G });
      return Q7.createElement(Rh1, { message: A, addMargin: Q, verbose: G });
  }
}
function d35({
  message: A,
  messages: B,
  addMargin: Q,
  tools: Z,
  progressMessagesForMessage: G,
  param: Y,
  style: I,
  verbose: W,
}) {
  let { columns: J } = IB();
  switch (Y.type) {
    case "text":
      return Q7.createElement(Oh1, { addMargin: Q, param: Y, verbose: W, thinkingMetadata: A.thinkingMetadata });
    case "tool_result":
      return Q7.createElement(fCB, {
        param: Y,
        message: A,
        messages: B,
        progressMessagesForMessage: G,
        style: I,
        tools: Z,
        verbose: W,
        width: J - 5,
      });
    default:
      return;
  }
}
function c35({
  param: A,
  addMargin: B,
  tools: Q,
  verbose: Z,
  erroredToolUseIDs: G,
  inProgressToolUseIDs: Y,
  resolvedToolUseIDs: I,
  progressMessagesForMessage: W,
  shouldAnimate: J,
  shouldShowDot: X,
  width: F,
  inProgressToolCallCount: V,
}) {
  switch (A.type) {
    case "tool_use":
      return Q7.createElement(mCB, {
        param: A,
        addMargin: B,
        tools: Q,
        verbose: Z,
        erroredToolUseIDs: G,
        inProgressToolUseIDs: Y,
        resolvedToolUseIDs: I,
        progressMessagesForMessage: W,
        shouldAnimate: J,
        shouldShowDot: X,
        inProgressToolCallCount: V,
      });
    case "text":
      return Q7.createElement(dCB, { param: A, addMargin: B, shouldShowDot: X, width: F });
    case "redacted_thinking":
      return Q7.createElement(tCB, { addMargin: B });
    case "thinking":
      return Q7.createElement(oCB, { addMargin: B, param: A });
    default:
      return (U1(new Error(`Unable to render message type: ${A.type}`), K3A), null);
  }
}
import { randomUUID as l35 } from "crypto";
function TE(A) {
  return A.flatMap((B) => {
    switch (B.type) {
      case "assistant":
        return [
          {
            type: "assistant",
            message: B.message,
            uuid: B.uuid,
            requestId: void 0,
            timestamp: new Date().toISOString(),
          },
        ];
      case "user":
        return [{ type: "user", message: B.message, uuid: B.uuid ?? l35(), timestamp: new Date().toISOString() }];
      case "system":
        if (B.subtype === "compact_boundary") {
          let Q = B;
          return [
            {
              type: "system",
              content: "Conversation compacted",
              level: "info",
              subtype: "compact_boundary",
              compactMetadata: { trigger: Q.compact_metadata.trigger, preTokens: Q.compact_metadata.pre_tokens },
              uuid: B.uuid,
              timestamp: new Date().toISOString(),
            },
          ];
        }
        return [];
      default:
        return [];
    }
  });
}
function ZUB(A) {
  return A.flatMap((B) => {
    switch (B.type) {
      case "assistant":
        return [{ type: "assistant", message: B.message, session_id: U2(), parent_tool_use_id: null, uuid: B.uuid }];
      case "user":
        return [{ type: "user", message: B.message, session_id: U2(), parent_tool_use_id: null, uuid: B.uuid }];
      case "system":
        if (B.subtype === "compact_boundary" && B.compactMetadata)
          return [
            {
              type: "system",
              subtype: "compact_boundary",
              session_id: U2(),
              uuid: B.uuid,
              compact_metadata: { trigger: B.compactMetadata.trigger, pre_tokens: B.compactMetadata.preTokens },
            },
          ];
        return [];
      default:
        return [];
    }
  });
}
function GUB({ session: A, toolUseContext: B, onDone: Q }) {
  let [Z, G] = NW1.useState(!1),
    [Y, I] = NW1.useState(null);
  s0((K, H) => {
    if (H.escape || H.return || K === " ") Q();
    else if (K === "t" && !Z) J();
  });
  let W = Z2();
  async function J() {
    (G(!0), I(null));
    try {
      await zW1(A.id, async (K) => {
        (I(K.message), G(!1));
      });
    } catch (K) {
      (I(K instanceof Error ? K.message : String(K)), G(!1));
    }
  }
  let X = (K) => {
      let H = Math.floor((Date.now() - K) / 1000),
        z = Math.floor(H / 3600),
        D = Math.floor((H - z * 3600) / 60),
        C = H - z * 3600 - D * 60;
      return `${z > 0 ? `${z}h ` : ""}${D > 0 || z > 0 ? `${D}m ` : ""}${C}s`;
    },
    F = NW1.useMemo(() => {
      return OI(TE(A.log.slice(-3))).filter((K) => K.type !== "progress");
    }, [A]),
    V = A.title.length > 50 ? A.title.substring(0, 47) + "..." : A.title;
  return M6.default.createElement(
    y,
    { width: "100%", flexDirection: "column" },
    M6.default.createElement(
      y,
      { width: "100%" },
      M6.default.createElement(
        y,
        {
          borderStyle: "round",
          borderColor: "background",
          flexDirection: "column",
          marginTop: 1,
          paddingLeft: 1,
          paddingRight: 1,
          width: "100%",
        },
        M6.default.createElement(
          y,
          null,
          M6.default.createElement(M, { color: "background", bold: !0 }, "Remote session details"),
        ),
        M6.default.createElement(
          y,
          { flexDirection: "column", marginTop: 1 },
          M6.default.createElement(
            M,
            null,
            M6.default.createElement(M, { bold: !0 }, "Status"),
            ":",
            " ",
            A.status === "running" || A.status === "starting"
              ? M6.default.createElement(M, { color: "background" }, A.status)
              : A.status === "completed"
                ? M6.default.createElement(M, { color: "success" }, A.status)
                : M6.default.createElement(M, { color: "error" }, A.status),
          ),
          M6.default.createElement(M, null, M6.default.createElement(M, { bold: !0 }, "Runtime"), ": ", X(A.startTime)),
          M6.default.createElement(
            M,
            { wrap: "truncate-end" },
            M6.default.createElement(M, { bold: !0 }, "Title"),
            ": ",
            V,
          ),
          M6.default.createElement(
            M,
            null,
            M6.default.createElement(M, { bold: !0 }, "Progress"),
            ":",
            " ",
            M6.default.createElement(wh1, { session: A }),
          ),
          M6.default.createElement(
            M,
            null,
            M6.default.createElement(M, { bold: !0 }, "Session URL"),
            ":",
            " ",
            M6.default.createElement(M, { dimColor: !0 }, "https://claude.ai/code/", A.id),
          ),
        ),
        A.log.length > 0 &&
          M6.default.createElement(
            y,
            { flexDirection: "column", marginTop: 1 },
            M6.default.createElement(M, null, M6.default.createElement(M, { bold: !0 }, "Recent messages"), ":"),
            M6.default.createElement(
              y,
              { flexDirection: "column", height: 10, overflowY: "hidden" },
              F.map((K, H) =>
                M6.default.createElement(sb, {
                  key: H,
                  message: K,
                  messages: F,
                  addMargin: H > 0,
                  tools: B.options.tools,
                  verbose: B.options.verbose,
                  erroredToolUseIDs: new Set(),
                  inProgressToolUseIDs: new Set(),
                  resolvedToolUseIDs: new Set(),
                  progressMessagesForMessage: [],
                  shouldAnimate: !1,
                  shouldShowDot: !1,
                  style: "condensed",
                }),
              ),
            ),
            M6.default.createElement(
              y,
              { marginTop: 1 },
              M6.default.createElement(
                M,
                { dimColor: !0, italic: !0 },
                "Showing last ",
                Math.min(3, A.log.length),
                " of",
                " ",
                A.log.length,
                " messages",
              ),
            ),
          ),
        Y &&
          M6.default.createElement(
            y,
            { marginTop: 1 },
            M6.default.createElement(M, { color: "error" }, "Teleport failed: ", Y),
          ),
        Z &&
          M6.default.createElement(
            y,
            { marginTop: 1 },
            M6.default.createElement(M, { color: "background" }, "Teleporting to session..."),
          ),
      ),
    ),
    M6.default.createElement(
      y,
      { marginLeft: 2 },
      W.pending
        ? M6.default.createElement(M, { dimColor: !0 }, "Press ", W.keyName, " again to exit")
        : M6.default.createElement(
            M,
            { dimColor: !0 },
            "Press Esc/Enter/Space to close",
            !Z ? M6.default.createElement(M, null, " · t to teleport") : null,
          ),
    ),
  );
}
var hA1 = A1(V1(), 1);
function IUB({ shell: A }) {
  switch (A.status) {
    case "completed":
      return hA1.default.createElement(M, { color: "success", dimColor: !0 }, "done");
    case "failed":
      return hA1.default.createElement(M, { color: "error", dimColor: !0 }, "error");
    case "killed":
      return hA1.default.createElement(M, { color: "error", dimColor: !0 }, "killed");
    case "running": {
      let B = YUB(A.stderr) || YUB(A.stdout);
      if (!B) return hA1.default.createElement(M, { dimColor: !0 }, "no output");
      return hA1.default.createElement(M, { dimColor: !0 }, pC(B, 20, !0));
    }
  }
}
function YUB(A) {
  if (!A) return "";
  let B = A.split(`
`);
  for (let Q = B.length - 1; Q >= 0; Q--) {
    let Z = B[Q]?.trim();
    if (Z) return Z;
  }
  return "";
}
var ES = A1(V1(), 1);
function Th1({ task: A }) {
  switch (A.type) {
    case "shell":
      return ES.createElement(M, null, pC(A.command, 40, !0), " ", ES.createElement(IUB, { shell: A }));
    case "remote_session":
      return ES.createElement(M, null, pC(A.title, 40, !0), " ", ES.createElement(wh1, { session: A }));
  }
}
function Ph1({ onDone: A, toolUseContext: B }) {
  let [{ backgroundTasks: Q }, Z] = dB(),
    [G, Y] = yc.useState(null),
    [I, W] = yc.useState(0);
  s0((O, R) => {
    if (!G && R.escape) A();
    if (!G && R.return && D) Y(D.id);
    if (!G && O === "k" && D?.type === "shell") X(D.id);
    if (!G && (R.upArrow || R.downArrow)) {
      let P = z.length;
      if (P === 0) return;
      if (R.upArrow) W((_) => Math.max(0, _ - 1));
      else W((_) => Math.min(P - 1, _ + 1));
    }
  });
  let J = Z2();
  function X(O) {
    Z((R) => {
      let P = Q[O];
      if (!P) return R;
      if (P.type !== "shell") return R;
      return { ...R, backgroundTasks: { ...R.backgroundTasks, [O]: P_1(P) } };
    });
  }
  let F = Object.values(Q).map(p35),
    V = F.sort((O, R) => {
      if (O.status === "running" && R.status !== "running") return -1;
      if (O.status !== "running" && R.status === "running") return 1;
      return R.task.startTime - O.task.startTime;
    }),
    K = V.filter((O) => O.type === "shell"),
    H = V.filter((O) => O.type === "remote_session"),
    z = yc.useMemo(() => {
      return [...K, ...H];
    }, [K, H]),
    D = z[I] || null;
  if (
    (yc.useEffect(() => {
      if (G && !Object.values(Q).some((R) => R.id === G)) Y(null);
      let O = z.length;
      if (I >= O && O > 0) W(O - 1);
    }, [G, Q, I, z]),
    G)
  ) {
    let O = Object.values(Q).find((R) => R.id === G);
    if (!O) return null;
    if (O.type === "shell")
      return f5.default.createElement(ICB, { shell: O, onDone: A, onKillShell: () => X(O.id), key: `shell-${O.id}` });
    else return f5.default.createElement(GUB, { session: O, onDone: A, toolUseContext: B, key: `session-${O.id}` });
  }
  let C = K.filter((O) => O.status === "running").length,
    w = H.filter((O) => O.status === "running" || O.status === "starting").length,
    E = VW(
      [
        ...(C > 0
          ? [f5.default.createElement(M, { key: "shells" }, C, " ", C !== 1 ? "active shells" : "active shell")]
          : []),
        ...(w > 0
          ? [f5.default.createElement(M, { key: "sessions" }, w, " ", w !== 1 ? "active session" : "active session")]
          : []),
      ],
      (O) => f5.default.createElement(M, { key: `separator-${O}` }, " · "),
    ),
    L = [
      f5.default.createElement(M, { key: "upDown" }, "↑/↓ to select"),
      f5.default.createElement(M, { key: "enter" }, "Enter to view"),
      ...(D?.type === "shell" && D.status === "running"
        ? [f5.default.createElement(M, { key: "kill" }, "k to kill")]
        : []),
      f5.default.createElement(M, { key: "esc" }, "Esc to close"),
    ];
  return f5.default.createElement(
    y,
    { width: "100%", flexDirection: "column" },
    f5.default.createElement(
      y,
      {
        borderStyle: "round",
        borderColor: "background",
        flexDirection: "column",
        marginTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        width: "100%",
      },
      f5.default.createElement(M, { color: "background", bold: !0 }, "Background tasks"),
      f5.default.createElement(M, { dimColor: !0 }, E),
      F.length === 0
        ? f5.default.createElement(M, { dimColor: !0 }, "No tasks currently running")
        : f5.default.createElement(
            y,
            { flexDirection: "column", marginTop: 1 },
            K.length > 0 &&
              f5.default.createElement(
                y,
                { flexDirection: "column" },
                H.length > 0 &&
                  f5.default.createElement(
                    M,
                    { dimColor: !0 },
                    f5.default.createElement(M, { bold: !0 }, "  ", "Bashes"),
                    " (",
                    K.length,
                    ")",
                  ),
                f5.default.createElement(
                  y,
                  { flexDirection: "column" },
                  K.map((O, R) => f5.default.createElement(WUB, { key: O.id, item: O, isSelected: R === I })),
                ),
              ),
            H.length > 0 &&
              f5.default.createElement(
                y,
                { flexDirection: "column", marginTop: K.length > 0 ? 1 : 0 },
                f5.default.createElement(
                  M,
                  { dimColor: !0 },
                  f5.default.createElement(M, { bold: !0 }, "  ", "Remote sessions"),
                  " (",
                  H.length,
                  ")",
                ),
                f5.default.createElement(
                  y,
                  { flexDirection: "column" },
                  H.map((O, R) =>
                    f5.default.createElement(WUB, { key: O.id, item: O, isSelected: K.length + R === I }),
                  ),
                ),
              ),
          ),
    ),
    f5.default.createElement(
      y,
      { marginLeft: 2 },
      J.pending
        ? f5.default.createElement(M, { dimColor: !0 }, "Press ", J.keyName, " again to exit")
        : f5.default.createElement(
            M,
            { dimColor: !0 },
            VW(L, (O) => f5.default.createElement(M, { key: `separator-${O}` }, " · ")),
          ),
    ),
  );
}
function p35(A) {
  switch (A.type) {
    case "shell":
      return { id: A.id, type: "shell", label: A.description, status: A.status, task: A };
    case "remote_session":
      return { id: A.id, type: "remote_session", label: A.title, status: A.status, task: A };
  }
}
function WUB({ item: A, isSelected: B }) {
  return f5.default.createElement(
    y,
    { flexDirection: "row", gap: 1 },
    f5.default.createElement(
      M,
      { color: B ? "suggestion" : void 0 },
      B ? t0.pointer + " " : "  ",
      f5.default.createElement(Th1, { task: A.task }),
    ),
  );
}
var i35 = {
    type: "local-jsx",
    name: "bashes",
    description: "List and manage background tasks",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, B) {
      return WM0.createElement(Ph1, { toolUseContext: B, onDone: A });
    },
    userFacingName() {
      return "bashes";
    },
  },
  JUB = i35;
var kc = A1(V1(), 1);
var n35 = {
    type: "local",
    name: "todos",
    description: "List current todo items",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !0,
    async call(A, B) {
      let Q = U2(),
        Z = AS(Q);
      if (Z.length === 0) return { type: "text", value: "No todos currently tracked" };
      let G = kc.default.createElement(
        y,
        { flexDirection: "column" },
        kc.default.createElement(
          M,
          null,
          kc.default.createElement(M, { bold: !0 }, Z.length, " ", Z.length === 1 ? "todo" : "todos"),
          kc.default.createElement(M, null, ":"),
        ),
        kc.default.createElement(y, { marginTop: 1 }, kc.default.createElement(o01, { todos: Z })),
      );
      return { type: "text", value: await Ic(G) };
    },
    userFacingName() {
      return "todos";
    },
  },
  XUB = n35;
var a35 = /```!\s*\n?([\s\S]*?)\n?```/g,
  s35 = /(?<!\w)!`([^`]+)`/g;
async function gA1(A, B, Q) {
  let Z = A;
  return (
    await Promise.all(
      [...A.matchAll(a35), ...A.matchAll(s35)].map(async (G) => {
        let Y = G[1]?.trim();
        if (Y)
          try {
            let I = await Zq(gQ, { command: Y }, B, wE({ content: [] }), "");
            if (I.behavior !== "allow")
              throw (
                d0(`Bash command permission check failed for command in ${Q}: ${Y}. Error: ${I.message}`),
                new rN(
                  `Bash command permission check failed for pattern "${G[0]}": ${I.message || "Permission denied"}`,
                )
              );
            let { data: W } = await j9B(gQ.call({ command: Y }, B)),
              J = FUB(W.stdout, W.stderr);
            Z = Z.replace(G[0], J);
          } catch (I) {
            if (I instanceof rN) throw I;
            r35(I, G[0]);
          }
      }),
    ),
    Z
  );
}
function FUB(A, B, Q = !1) {
  let Z = [];
  if (A.trim()) Z.push(A.trim());
  if (B.trim())
    if (Q) Z.push(`[stderr: ${B.trim()}]`);
    else
      Z.push(`[stderr]
${B.trim()}`);
  return Z.join(
    Q
      ? " "
      : `
`,
  );
}
function r35(A, B, Q = !1) {
  if (A instanceof oN) {
    if (A.interrupted) throw new rN(`Bash command interrupted for pattern "${B}": [Command interrupted]`);
    let Y = FUB(A.stdout, A.stderr, Q);
    throw new rN(`Bash command failed for pattern "${B}": ${Y}`);
  }
  let Z = A instanceof Error ? A.message : String(A),
    G = Q
      ? `[Error: ${Z}]`
      : `[Error]
${Z}`;
  throw new rN(G);
}
var o35 = `---
allowed-tools: Bash(git diff:*), Bash(git status:*), Bash(git log:*), Bash(git show:*), Bash(git remote show:*), Read, Glob, Grep, LS, Task
description: Complete a security review of the pending changes on the current branch
---

You are a senior security engineer conducting a focused security review of the changes on this branch.

GIT STATUS:

\`\`\`
!\`git status\`
\`\`\`

FILES MODIFIED:

\`\`\`
!\`git diff --name-only origin/HEAD...\`
\`\`\`

COMMITS:

\`\`\`
!\`git log --no-decorate origin/HEAD...\`
\`\`\`

DIFF CONTENT:

\`\`\`
!\`git diff --merge-base origin/HEAD\`
\`\`\`

Review the complete diff above. This contains all code changes in the PR.


OBJECTIVE:
Perform a security-focused code review to identify HIGH-CONFIDENCE security vulnerabilities that could have real exploitation potential. This is not a general code review - focus ONLY on security implications newly added by this PR. Do not comment on existing security concerns.

CRITICAL INSTRUCTIONS:
1. MINIMIZE FALSE POSITIVES: Only flag issues where you're >80% confident of actual exploitability
2. AVOID NOISE: Skip theoretical issues, style concerns, or low-impact findings
3. FOCUS ON IMPACT: Prioritize vulnerabilities that could lead to unauthorized access, data breaches, or system compromise
4. EXCLUSIONS: Do NOT report the following issue types:
   - Denial of Service (DOS) vulnerabilities, even if they allow service disruption
   - Secrets or sensitive data stored on disk (these are handled by other processes)
   - Rate limiting or resource exhaustion issues

SECURITY CATEGORIES TO EXAMINE:

**Input Validation Vulnerabilities:**
- SQL injection via unsanitized user input
- Command injection in system calls or subprocesses
- XXE injection in XML parsing
- Template injection in templating engines
- NoSQL injection in database queries
- Path traversal in file operations

**Authentication & Authorization Issues:**
- Authentication bypass logic
- Privilege escalation paths
- Session management flaws
- JWT token vulnerabilities
- Authorization logic bypasses

**Crypto & Secrets Management:**
- Hardcoded API keys, passwords, or tokens
- Weak cryptographic algorithms or implementations
- Improper key storage or management
- Cryptographic randomness issues
- Certificate validation bypasses

**Injection & Code Execution:**
- Remote code execution via deseralization
- Pickle injection in Python
- YAML deserialization vulnerabilities
- Eval injection in dynamic code execution
- XSS vulnerabilities in web applications (reflected, stored, DOM-based)

**Data Exposure:**
- Sensitive data logging or storage
- PII handling violations
- API endpoint data leakage
- Debug information exposure

Additional notes:
- Even if something is only exploitable from the local network, it can still be a HIGH severity issue

ANALYSIS METHODOLOGY:

Phase 1 - Repository Context Research (Use file search tools):
- Identify existing security frameworks and libraries in use
- Look for established secure coding patterns in the codebase
- Examine existing sanitization and validation patterns
- Understand the project's security model and threat model

Phase 2 - Comparative Analysis:
- Compare new code changes against existing security patterns
- Identify deviations from established secure practices
- Look for inconsistent security implementations
- Flag code that introduces new attack surfaces

Phase 3 - Vulnerability Assessment:
- Examine each modified file for security implications
- Trace data flow from user inputs to sensitive operations
- Look for privilege boundaries being crossed unsafely
- Identify injection points and unsafe deserialization

REQUIRED OUTPUT FORMAT:

You MUST output your findings in markdown. The markdown output should contain the file, line number, severity, category (e.g. \`sql_injection\` or \`xss\`), description, exploit scenario, and fix recommendation. 

For example:

# Vuln 1: XSS: \`foo.py:42\`

* Severity: High
* Description: User input from \`username\` parameter is directly interpolated into HTML without escaping, allowing reflected XSS attacks
* Exploit Scenario: Attacker crafts URL like /bar?q=<script>alert(document.cookie)</script> to execute JavaScript in victim's browser, enabling session hijacking or data theft
* Recommendation: Use Flask's escape() function or Jinja2 templates with auto-escaping enabled for all user inputs rendered in HTML

SEVERITY GUIDELINES:
- **HIGH**: Directly exploitable vulnerabilities leading to RCE, data breach, or authentication bypass
- **MEDIUM**: Vulnerabilities requiring specific conditions but with significant impact
- **LOW**: Defense-in-depth issues or lower-impact vulnerabilities

CONFIDENCE SCORING:
- 0.9-1.0: Certain exploit path identified, tested if possible
- 0.8-0.9: Clear vulnerability pattern with known exploitation methods
- 0.7-0.8: Suspicious pattern requiring specific conditions to exploit
- Below 0.7: Don't report (too speculative)

FINAL REMINDER:
Focus on HIGH and MEDIUM findings only. Better to miss some theoretical issues than flood the report with false positives. Each finding should be something a security engineer would confidently raise in a PR review.

FALSE POSITIVE FILTERING:

> You do not need to run commands to reproduce the vulnerability, just read the code to determine if it is a real vulnerability. Do not use the bash tool or write to any files.
>
> HARD EXCLUSIONS - Automatically exclude findings matching these patterns:
> 1. Denial of Service (DOS) vulnerabilities or resource exhaustion attacks.
> 2. Secrets or credentials stored on disk if they are otherwise secured.
> 3. Rate limiting concerns or service overload scenarios.
> 4. Memory consumption or CPU exhaustion issues.
> 5. Lack of input validation on non-security-critical fields without proven security impact.
> 6. Input sanitization concerns for GitHub Action workflows unless they are clearly triggerable via untrusted input.
> 7. A lack of hardening measures. Code is not expected to implement all security best practices, only flag concrete vulnerabilities.
> 8. Race conditions or timing attacks that are theoretical rather than practical issues. Only report a race condition if it is concretely problematic.
> 9. Vulnerabilities related to outdated third-party libraries. These are managed separately and should not be reported here.
> 10. Memory safety issues such as buffer overflows or use-after-free-vulnerabilities are impossible in rust. Do not report memory safety issues in rust or any other memory safe languages.
> 11. Files that are only unit tests or only used as part of running tests.
> 12. Log spoofing concerns. Outputting un-sanitized user input to logs is not a vulnerability.
> 13. SSRF vulnerabilities that only control the path. SSRF is only a concern if it can control the host or protocol.
> 14. Including user-controlled content in AI system prompts is not a vulnerability.
> 15. Regex injection. Injecting untrusted content into a regex is not a vulnerability.
> 16. Regex DOS concerns.
> 16. Insecure documentation. Do not report any findings in documentation files such as markdown files.
> 17. A lack of audit logs is not a vulnerability.
> 
> PRECEDENTS -
> 1. Logging high value secrets in plaintext is a vulnerability. Logging URLs is assumed to be safe.
> 2. UUIDs can be assumed to be unguessable and do not need to be validated.
> 3. Environment variables and CLI flags are trusted values. Attackers are generally not able to modify them in a secure environment. Any attack that relies on controlling an environment variable is invalid.
> 4. Resource management issues such as memory or file descriptor leaks are not valid.
> 5. Subtle or low impact web vulnerabilities such as tabnabbing, XS-Leaks, prototype pollution, and open redirects should not be reported unless they are extremely high confidence.
> 6. React and Angular are generally secure against XSS. These frameworks do not need to sanitize or escape user input unless it is using dangerouslySetInnerHTML, bypassSecurityTrustHtml, or similar methods. Do not report XSS vulnerabilities in React or Angular components or tsx files unless they are using unsafe methods.
> 7. Most vulnerabilities in github action workflows are not exploitable in practice. Before validating a github action workflow vulnerability ensure it is concrete and has a very specific attack path.
> 8. A lack of permission checking or authentication in client-side JS/TS code is not a vulnerability. Client-side code is not trusted and does not need to implement these checks, they are handled on the server-side. The same applies to all flows that send untrusted data to the backend, the backend is responsible for validating and sanitizing all inputs.
> 9. Only include MEDIUM findings if they are obvious and concrete issues.
> 10. Most vulnerabilities in ipython notebooks (*.ipynb files) are not exploitable in practice. Before validating a notebook vulnerability ensure it is concrete and has a very specific attack path where untrusted input can trigger the vulnerability.
> 11. Logging non-PII data is not a vulnerability even if the data may be sensitive. Only report logging vulnerabilities if they expose sensitive information such as secrets, passwords, or personally identifiable information (PII).
> 12. Command injection vulnerabilities in shell scripts are generally not exploitable in practice since shell scripts generally do not run with untrusted user input. Only report command injection vulnerabilities in shell scripts if they are concrete and have a very specific attack path for untrusted input.
> 
> SIGNAL QUALITY CRITERIA - For remaining findings, assess:
> 1. Is there a concrete, exploitable vulnerability with a clear attack path?
> 2. Does this represent a real security risk vs theoretical best practice?
> 3. Are there specific code locations and reproduction steps?
> 4. Would this finding be actionable for a security team?
> 
> For each finding, assign a confidence score from 1-10:
> - 1-3: Low confidence, likely false positive or noise
> - 4-6: Medium confidence, needs investigation
> - 7-10: High confidence, likely true vulnerability

START ANALYSIS:

Begin your analysis now. Do this in 3 steps:

1. Use a sub-task to identify vulnerabilities. Use the repository exploration tools to understand the codebase context, then analyze the PR changes for security implications. In the prompt for this sub-task, include all of the above.
2. Then for each vulnerability identified by the above sub-task, create a new sub-task to filter out false-positives. Launch these sub-tasks as parallel sub-tasks. In the prompt for these sub-tasks, include everything in the "FALSE POSITIVE FILTERING" instructions.
3. Filter out any vulnerabilities where the sub-task reported a confidence less than 8.

Your final reply must contain the markdown report and nothing else.`,
  VUB = {
    type: "prompt",
    name: "security-review",
    description: "Complete a security review of the pending changes on the current branch",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "analyzing code changes for security risks",
    userFacingName() {
      return "security-review";
    },
    source: "builtin",
    async getPromptForCommand(A, B) {
      let Q = B_(o35),
        Z = Es(Q.frontmatter["allowed-tools"]);
      return [
        {
          type: "text",
          text: await gA1(
            Q.content,
            {
              ...B,
              async getAppState() {
                let Y = await B.getAppState();
                return {
                  ...Y,
                  toolPermissionContext: {
                    ...Y.toolPermissionContext,
                    alwaysAllowRules: { ...Y.toolPermissionContext.alwaysAllowRules, command: Z },
                  },
                };
              },
            },
            "security-review",
          ),
        },
      ];
    },
  };
function t35() {
  let A = H0(),
    B = A.editorMode || "normal";
  if (B === "emacs") B = "normal";
  let Q = B === "normal" ? "vim" : "normal";
  return (
    TA({ ...A, editorMode: Q }),
    Y1("tengu_editor_mode_changed", { mode: Q, source: "command" }),
    Promise.resolve({
      type: "text",
      value: `Editor mode set to ${Q}. ${Q === "vim" ? "Use Escape key to toggle between INSERT and NORMAL modes." : "Using standard (readline) keyboard bindings."}`,
    })
  );
}
var e35 = {
    name: "vim",
    description: "Toggle between Vim and Normal editing modes",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    type: "local",
    userFacingName: () => "vim",
    call: t35,
  },
  KUB = e35;
var xO0 = A1(V1(), 1);
var FB = A1(V1(), 1);
var CW = A1(V1(), 1);
var WK = A1(V1(), 1);
function jh1({ ruleValue: A }) {
  switch (A.toolName) {
    case gQ.name:
      if (A.ruleContent)
        if (A.ruleContent.endsWith(":*"))
          return WK.createElement(
            M,
            { dimColor: !0 },
            "Any Bash command starting with",
            " ",
            WK.createElement(M, { bold: !0 }, A.ruleContent.slice(0, -2)),
          );
        else
          return WK.createElement(
            M,
            { dimColor: !0 },
            "The Bash command ",
            WK.createElement(M, { bold: !0 }, A.ruleContent),
          );
      else return WK.createElement(M, { dimColor: !0 }, "Any Bash command");
    default:
      if (!A.ruleContent)
        return WK.createElement(
          M,
          { dimColor: !0 },
          "Any use of the ",
          WK.createElement(M, { bold: !0 }, A.toolName),
          " tool",
        );
      else return null;
  }
}
var hX = A1(V1(), 1);
var HUB = A1(V1(), 1);
function XM0(A) {
  switch (A) {
    case "localSettings":
      return { label: "Project settings (local)", description: `Saved in ${X61("localSettings")}`, value: A };
    case "projectSettings":
      return { label: "Project settings", description: `Checked in at ${X61("projectSettings")}`, value: A };
    case "userSettings":
      return { label: "User settings", description: "Saved in at ~/.claude/settings.json", value: A };
  }
}
var uA1 = ["localSettings", "projectSettings", "userSettings"];
function zUB({
  onAddRules: A,
  onCancel: B,
  ruleValues: Q,
  ruleBehavior: Z,
  initialContext: G,
  setToolPermissionContext: Y,
}) {
  let I = uA1.map(XM0),
    W = HUB.useCallback(
      (X) => {
        if (X === "cancel") {
          B();
          return;
        } else if (uA1.includes(X)) {
          let F = X,
            V = HF(G, { type: "addRules", rules: Q, behavior: Z, destination: F });
          (ig({ type: "addRules", rules: Q, behavior: Z, destination: F }), Y(V));
          let K = Q.map((H) => ({ ruleValue: H, ruleBehavior: Z, source: F }));
          A(K);
        }
      },
      [A, B, Q, Z, G, Y],
    ),
    J = `Add ${Z} permission rule${Q.length === 1 ? "" : "s"}`;
  return hX.createElement(
    Mb,
    { title: J, onCancel: B, borderColor: "permission" },
    hX.createElement(
      y,
      { flexDirection: "column", paddingX: 2 },
      Q.map((X) =>
        hX.createElement(
          y,
          { flexDirection: "column", key: n6(X) },
          hX.createElement(M, { bold: !0 }, n6(X)),
          hX.createElement(jh1, { ruleValue: X }),
        ),
      ),
    ),
    hX.createElement(
      y,
      { flexDirection: "column", marginY: 1 },
      hX.createElement(
        M,
        null,
        Q.length === 1 ? "Where should this rule be saved?" : "Where should these rules be saved?",
      ),
      hX.createElement(xA, { options: I, onChange: W, onCancel: B }),
    ),
  );
}
var X8 = A1(V1(), 1);
var nqB = A1(V1(), 1);
var bqB = A1(xqB(), 1);
class yO0 extends Error {
  constructor(A) {
    super(`Claude Code is unable to fetch from ${A}`);
    this.name = "DomainBlockedError";
  }
}
class kO0 extends Error {
  constructor(A) {
    super(
      `Unable to verify if domain ${A} is safe to fetch. This may be due to network restrictions or enterprise security policies blocking claude.ai.`,
    );
    this.name = "DomainCheckFailedError";
  }
}
var Kg1 = new Map(),
  fqB = 900000;
function BW5() {
  let A = Date.now();
  for (let [B, Q] of Kg1.entries()) if (A - Q.timestamp > fqB) Kg1.delete(B);
}
var QW5 = 2000,
  ZW5 = 10485760,
  vqB = 1e5;
function GW5(A) {
  if (A.length > QW5) return !1;
  let B;
  try {
    B = new URL(A);
  } catch {
    return !1;
  }
  if (B.username || B.password) return !1;
  if (B.hostname.split(".").length < 2) return !1;
  return !0;
}
async function YW5(A) {
  try {
    let B = await $2.get(`https://claude.ai/api/web/domain_info?domain=${encodeURIComponent(A)}`);
    if (B.status === 200) return B.data.can_fetch === !0 ? { status: "allowed" } : { status: "blocked" };
    return { status: "check_failed", error: new Error(`Domain check returned status ${B.status}`) };
  } catch (B) {
    return (U1(B, jYA), { status: "check_failed", error: B });
  }
}
function IW5(A, B) {
  try {
    let Q = new URL(A),
      Z = new URL(B);
    if (Z.protocol !== Q.protocol) return !1;
    if (Z.port !== Q.port) return !1;
    if (Z.username || Z.password) return !1;
    let G = (W) => W.replace(/^www\./, ""),
      Y = G(Q.hostname),
      I = G(Z.hostname);
    return Y === I;
  } catch (Q) {
    return !1;
  }
}
async function hqB(A, B, Q) {
  try {
    return await $2.get(A, { signal: B, maxRedirects: 0, responseType: "arraybuffer", maxContentLength: ZW5 });
  } catch (Z) {
    if ($2.isAxiosError(Z) && Z.response && [301, 302, 307, 308].includes(Z.response.status)) {
      let G = Z.response.headers.location;
      if (!G) throw new Error("Redirect missing Location header");
      let Y = new URL(G, A).toString();
      if (Q(A, Y)) return hqB(Y, B, Q);
      else return { type: "redirect", originalUrl: A, redirectUrl: Y, statusCode: Z.response.status };
    }
    throw Z;
  }
}
function WW5(A) {
  return "type" in A && A.type === "redirect";
}
async function gqB(A, B) {
  if (!GW5(A)) throw new Error("Invalid URL");
  BW5();
  let Q = Date.now(),
    Z = Kg1.get(A);
  if (Z && Q - Z.timestamp < fqB) return { bytes: Z.bytes, code: Z.code, codeText: Z.codeText, content: Z.content };
  let G,
    Y = A;
  try {
    if (((G = new URL(A)), G.protocol === "http:")) ((G.protocol = "https:"), (Y = G.toString()));
    let V = G.hostname;
    if (!E2().skipWebFetchPreflight)
      switch ((await YW5(V)).status) {
        case "allowed":
          break;
        case "blocked":
          throw new yO0(V);
        case "check_failed":
          throw new kO0(V);
      }
  } catch (V) {
    if ((U1(V, SYA), V instanceof yO0 || V instanceof kO0)) throw V;
  }
  let I = await hqB(Y, B.signal, IW5);
  if (WW5(I)) return I;
  let W = Buffer.from(I.data).toString("utf-8"),
    J = I.headers["content-type"] ?? "",
    X = Buffer.byteLength(W),
    F;
  if (J.includes("text/html")) F = new bqB.default().turndown(W);
  else F = W;
  if (F.length > vqB) F = F.substring(0, vqB) + "...[content truncated]";
  return (
    Kg1.set(A, { bytes: X, code: I.status, codeText: I.statusText, content: F, timestamp: Q }),
    { code: I.status, codeText: I.statusText, content: F, bytes: X }
  );
}
async function uqB(A, B, Q, Z) {
  let G = zBB(B, A),
    Y = await NI({
      systemPrompt: [],
      userPrompt: G,
      isNonInteractiveSession: Z,
      signal: Q,
      promptCategory: "web_fetch_apply",
    });
  if (Q.aborted) throw new QH();
  let { content: I } = Y.message;
  if (I.length > 0) {
    let W = I[0];
    if ("text" in W) return W.text;
  }
  return "No response from model";
}
var mqB = new Set([
  "docs.anthropic.com",
  "modelcontextprotocol.io",
  "docs.python.org",
  "en.cppreference.com",
  "docs.oracle.com",
  "learn.microsoft.com",
  "developer.mozilla.org",
  "go.dev",
  "www.php.net",
  "docs.swift.org",
  "kotlinlang.org",
  "ruby-doc.org",
  "doc.rust-lang.org",
  "www.typescriptlang.org",
  "react.dev",
  "angular.io",
  "vuejs.org",
  "nextjs.org",
  "expressjs.com",
  "nodejs.org",
  "jquery.com",
  "getbootstrap.com",
  "tailwindcss.com",
  "d3js.org",
  "threejs.org",
  "redux.js.org",
  "webpack.js.org",
  "jestjs.io",
  "reactrouter.com",
  "docs.djangoproject.com",
  "flask.palletsprojects.com",
  "fastapi.tiangolo.com",
  "pandas.pydata.org",
  "numpy.org",
  "www.tensorflow.org",
  "pytorch.org",
  "scikit-learn.org",
  "matplotlib.org",
  "requests.readthedocs.io",
  "jupyter.org",
  "laravel.com",
  "symfony.com",
  "wordpress.org",
  "docs.spring.io",
  "hibernate.org",
  "tomcat.apache.org",
  "gradle.org",
  "maven.apache.org",
  "asp.net",
  "dotnet.microsoft.com",
  "nuget.org",
  "blazor.net",
  "reactnative.dev",
  "docs.flutter.dev",
  "developer.apple.com",
  "developer.android.com",
  "keras.io",
  "spark.apache.org",
  "huggingface.co",
  "www.kaggle.com",
  "www.mongodb.com",
  "redis.io",
  "www.postgresql.org",
  "dev.mysql.com",
  "www.sqlite.org",
  "graphql.org",
  "prisma.io",
  "docs.aws.amazon.com",
  "cloud.google.com",
  "learn.microsoft.com",
  "kubernetes.io",
  "www.docker.com",
  "www.terraform.io",
  "www.ansible.com",
  "vercel.com/docs",
  "docs.netlify.com",
  "devcenter.heroku.com/",
  "cypress.io",
  "selenium.dev",
  "docs.unity.com",
  "docs.unrealengine.com",
  "git-scm.com",
  "nginx.org",
  "httpd.apache.org",
]);
var nH = A1(V1(), 1);
function dqB({ url: A, prompt: B }, { verbose: Q }) {
  if (!A) return null;
  if (Q) return `url: "${A}"${Q && B ? `, prompt: "${B}"` : ""}`;
  return A;
}
function cqB() {
  return nH.default.createElement(o8, null);
}
function lqB(A, { verbose: B }) {
  return nH.default.createElement(K5, { result: A, verbose: B });
}
function pqB() {
  return nH.default.createElement(NA, { height: 1 }, nH.default.createElement(M, { dimColor: !0 }, "Fetching…"));
}
function iqB({ bytes: A, code: B, codeText: Q, result: Z }, G, { verbose: Y }) {
  let I = dW(A);
  if (Y)
    return nH.default.createElement(
      y,
      { flexDirection: "column" },
      nH.default.createElement(
        NA,
        { height: 1 },
        nH.default.createElement(
          M,
          null,
          "Received ",
          nH.default.createElement(M, { bold: !0 }, I),
          " (",
          B,
          " ",
          Q,
          ")",
        ),
      ),
      nH.default.createElement(y, { flexDirection: "column" }, nH.default.createElement(M, null, Z)),
    );
  return nH.default.createElement(
    NA,
    { height: 1 },
    nH.default.createElement(M, null, "Received ", nH.default.createElement(M, { bold: !0 }, I), " (", B, " ", Q, ")"),
  );
}
var JW5 = f.strictObject({
    url: f.string().url().describe("The URL to fetch content from"),
    prompt: f.string().describe("The prompt to run on the fetched content"),
  }),
  c13 = f.object({
    bytes: f.number().describe("Size of the fetched content in bytes"),
    code: f.number().describe("HTTP response code"),
    codeText: f.string().describe("HTTP response code text"),
    result: f.string().describe("Processed result from applying the prompt to the content"),
    durationMs: f.number().describe("Time taken to fetch and process the content"),
    url: f.string().describe("The URL that was fetched"),
  });
function XW5(A) {
  try {
    let B = LJ.inputSchema.safeParse(A);
    if (!B.success) return `input:${A.toString()}`;
    let { url: Q } = B.data;
    return `domain:${new URL(Q).hostname}`;
  } catch {
    return `input:${A.toString()}`;
  }
}
var LJ = {
  name: WEB_FETCH_TOOL_NAME,
  async description(A) {
    let { url: B } = A;
    try {
      return `Claude wants to fetch content from ${new URL(B).hostname}`;
    } catch {
      return "Claude wants to fetch content from this URL";
    }
  },
  userFacingName() {
    return "Fetch";
  },
  isEnabled() {
    return !0;
  },
  inputSchema: JW5,
  isConcurrencySafe() {
    return !0;
  },
  isReadOnly() {
    return !0;
  },
  async checkPermissions(A, B) {
    let Z = (await B.getAppState()).toolPermissionContext;
    try {
      let { url: J } = A,
        X = new URL(J),
        F = X.hostname,
        V = X.pathname;
      for (let K of mqB)
        if (K.includes("/")) {
          let [H, ...z] = K.split("/"),
            D = "/" + z.join("/");
          if (F === H && V.startsWith(D))
            return {
              behavior: "allow",
              updatedInput: A,
              decisionReason: { type: "other", reason: "Preapproved host and path" },
            };
        } else if (F === K)
          return { behavior: "allow", updatedInput: A, decisionReason: { type: "other", reason: "Preapproved host" } };
    } catch {}
    let G = XW5(A),
      Y = Qq(Z, LJ, "deny").get(G);
    if (Y)
      return {
        behavior: "deny",
        message: `${LJ.name} denied access to ${G}.`,
        decisionReason: { type: "rule", rule: Y },
      };
    let I = Qq(Z, LJ, "ask").get(G);
    if (I)
      return {
        behavior: "ask",
        message: `Claude requested permissions to use ${LJ.name}, but you haven't granted it yet.`,
        decisionReason: { type: "rule", rule: I },
      };
    let W = Qq(Z, LJ, "allow").get(G);
    if (W) return { behavior: "allow", updatedInput: A, decisionReason: { type: "rule", rule: W } };
    return {
      behavior: "ask",
      message: `Claude requested permissions to use ${LJ.name}, but you haven't granted it yet.`,
    };
  },
  async prompt() {
    return HBB;
  },
  async validateInput(A) {
    let { url: B } = A;
    try {
      new URL(B);
    } catch {
      return {
        result: !1,
        message: `Error: Invalid URL "${B}". The URL provided could not be parsed.`,
        meta: { reason: "invalid_url" },
        errorCode: 1,
      };
    }
    return { result: !0 };
  },
  renderToolUseMessage: dqB,
  renderToolUseRejectedMessage: cqB,
  renderToolUseErrorMessage: lqB,
  renderToolUseProgressMessage: pqB,
  renderToolResultMessage: iqB,
  async *call({ url: A, prompt: B }, { abortController: Q, options: { isNonInteractiveSession: Z } }) {
    let G = Date.now(),
      Y = await gqB(A, Q);
    if ("type" in Y && Y.type === "redirect") {
      let K =
          Y.statusCode === 301
            ? "Moved Permanently"
            : Y.statusCode === 308
              ? "Permanent Redirect"
              : Y.statusCode === 307
                ? "Temporary Redirect"
                : "Found",
        H = `REDIRECT DETECTED: The URL redirects to a different host.

Original URL: ${Y.originalUrl}
Redirect URL: ${Y.redirectUrl}
Status: ${Y.statusCode} ${K}

To complete your request, I need to fetch content from the redirected URL. Please use WebFetch again with these parameters:
- url: "${Y.redirectUrl}"
- prompt: "${B}"`;
      yield {
        type: "result",
        data: {
          bytes: Buffer.byteLength(H),
          code: Y.statusCode,
          codeText: K,
          result: H,
          durationMs: Date.now() - G,
          url: A,
        },
      };
      return;
    }
    let { content: I, bytes: W, code: J, codeText: X } = Y,
      F = await uqB(B, I, Q.signal, Z);
    yield { type: "result", data: { bytes: W, code: J, codeText: X, result: F, durationMs: Date.now() - G, url: A } };
  },
  mapToolResultToToolResultBlockParam({ result: A }, B) {
    return { tool_use_id: B, type: "tool_result", content: A };
  },
};
function aqB({ onCancel: A, onSubmit: B, ruleBehavior: Q }) {
  let [Z, G] = nqB.useState(""),
    Y = Z2();
  s0((X, F) => {
    if (F.escape) A();
  });
  let { columns: I } = IB(),
    W = I - 6,
    J = (X) => {
      let F = X.trim();
      if (F.length === 0) return;
      let V = xz(F);
      B(V, Q);
    };
  return X8.createElement(
    X8.Fragment,
    null,
    X8.createElement(
      y,
      {
        flexDirection: "column",
        gap: 1,
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "permission",
      },
      X8.createElement(M, { bold: !0, color: "permission" }, "Add ", Q, " permission rule"),
      X8.createElement(
        y,
        { flexDirection: "column" },
        X8.createElement(
          M,
          null,
          "Permission rules are a tool name, optionally followed by a specifier in parentheses.",
          X8.createElement(l3, null),
          "e.g.,",
          " ",
          X8.createElement(M, { bold: !0 }, n6({ toolName: LJ.name })),
          X8.createElement(M, { bold: !1 }, " or "),
          X8.createElement(M, { bold: !0 }, n6({ toolName: gQ.name, ruleContent: "ls:*" })),
        ),
        X8.createElement(
          y,
          { borderDimColor: !0, borderStyle: "round", marginY: 1, paddingLeft: 1 },
          X8.createElement(s4, {
            showCursor: !0,
            value: Z,
            onChange: G,
            onSubmit: J,
            placeholder: `Enter permission rule${t0.ellipsis}`,
            columns: W,
            cursorOffset: Z.length,
            onChangeCursorOffset: () => {},
          }),
        ),
      ),
    ),
    X8.createElement(
      y,
      { marginLeft: 3 },
      Y.pending
        ? X8.createElement(M, { dimColor: !0 }, "Press ", Y.keyName, " again to exit")
        : X8.createElement(M, { dimColor: !0 }, "Enter to submit · Esc to cancel"),
    ),
  );
}
var aH = A1(V1(), 1);
var sqB = A1(V1(), 1);
function rqB({ onExit: A, getToolPermissionContext: B, onRequestAddDirectory: Q, onRequestRemoveDirectory: Z }) {
  let G = B(),
    Y = aH.useMemo(() => {
      return Array.from(G.additionalWorkingDirectories.keys()).map((J) => ({
        path: J,
        isCurrent: !1,
        isDeletable: !0,
      }));
    }, [G.additionalWorkingDirectories]),
    I = sqB.useCallback(
      (J) => {
        if (J === "add-directory") {
          Q();
          return;
        }
        let X = Y.find((F) => F.path === J);
        if (X && X.isDeletable) Z(X.path);
      },
      [Y, Q, Z],
    ),
    W = aH.useMemo(() => {
      let J = Y.map((X) => ({ label: X.path, value: X.path }));
      return (J.push({ label: `Add directory${t0.ellipsis}`, value: "add-directory" }), J);
    }, [Y]);
  return aH.createElement(
    y,
    { flexDirection: "column", marginBottom: 1 },
    aH.createElement(
      y,
      { flexDirection: "row", marginTop: 1, marginLeft: 2, gap: 1 },
      aH.createElement(M, null, `-  ${WQ()}`),
      aH.createElement(M, { dimColor: !0 }, "(Original working directory)"),
    ),
    aH.createElement(xA, { options: W, onChange: I, onCancel: () => A(), visibleOptionCount: Math.min(10, W.length) }),
  );
}
var mc = A1(V1(), 1);
var eF = ["allow", "ask", "deny", "workspace"];
function FW5(A) {
  switch (A) {
    case "allow":
      return "Allow";
    case "deny":
      return "Deny";
    case "ask":
      return "Ask";
    case "workspace":
      return "Workspace";
  }
}
function VW5(A) {
  switch (A) {
    case "allow":
      return "Claude Code won't ask before using allowed tools.";
    case "deny":
      return "Claude Code will always reject requests to use denied tools.";
    case "ask":
      return "Claude Code will always ask for confirmation before using these tools.";
    case "workspace":
      return "Claude Code can read files in the workspace, and make edits when auto-accept edits is on.";
  }
}
function oqB({ selectedTab: A }) {
  return mc.default.createElement(
    mc.default.Fragment,
    null,
    mc.default.createElement(
      y,
      { flexDirection: "row", gap: 1, marginBottom: 1 },
      mc.default.createElement(M, { bold: !0, color: "permission" }, "Permissions:"),
      eF.map((B) =>
        mc.default.createElement(
          M,
          {
            key: B,
            backgroundColor: A === B ? "permission" : void 0,
            color: A === B ? "inverseText" : void 0,
            bold: A === B,
          },
          ` ${FW5(B)} `,
        ),
      ),
    ),
    mc.default.createElement(M, null, VW5(A)),
  );
}
var O3 = A1(V1(), 1);
var _O0 = A1(V1(), 1);
function tqB({ directoryPath: A, onRemove: B, onCancel: Q, permissionContext: Z, setPermissionContext: G }) {
  let Y = Z2();
  s0((J, X) => {
    if (X.escape) Q();
  });
  let I = _O0.useCallback(() => {
      let J = HF(Z, { type: "removeDirectories", directories: [A], destination: "session" });
      (G(J), B());
    }, [A, Z, G, B]),
    W = _O0.useCallback(
      (J) => {
        if (J === "yes") I();
        else Q();
      },
      [I, Q],
    );
  return O3.createElement(
    O3.Fragment,
    null,
    O3.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "error" },
      O3.createElement(M, { bold: !0, color: "error" }, "Remove directory from workspace?"),
      O3.createElement(y, { marginY: 1, marginX: 2, flexDirection: "column" }, O3.createElement(M, { bold: !0 }, A)),
      O3.createElement(M, null, "Claude Code will no longer have access to files in this directory."),
      O3.createElement(
        y,
        { marginY: 1 },
        O3.createElement(xA, {
          onChange: W,
          onCancel: Q,
          options: [
            { label: "Yes", value: "yes" },
            { label: "No", value: "no" },
          ],
        }),
      ),
    ),
    O3.createElement(
      y,
      { marginLeft: 3 },
      Y.pending
        ? O3.createElement(M, { dimColor: !0 }, "Press ", Y.keyName, " again to exit")
        : O3.createElement(M, { dimColor: !0 }, "↑/↓ to select · Enter to confirm · Esc to cancel"),
    ),
  );
}
function KW5({ rule: A }) {
  return FB.createElement(M, { dimColor: !0 }, `From ${T10(A.source)}`);
}
function HW5(A) {
  switch (A) {
    case "allow":
      return "allowed";
    case "deny":
      return "denied";
    case "ask":
      return "ask";
  }
}
function zW5({ rule: A, onDelete: B, onCancel: Q }) {
  let Z = Z2();
  s0((I, W) => {
    if (W.escape) Q();
  });
  let G = FB.createElement(
      y,
      { flexDirection: "column", marginX: 2 },
      FB.createElement(M, { bold: !0 }, n6(A.ruleValue)),
      FB.createElement(jh1, { ruleValue: A.ruleValue }),
      FB.createElement(KW5, { rule: A }),
    ),
    Y = FB.createElement(
      y,
      { marginLeft: 3 },
      Z.pending
        ? FB.createElement(M, { dimColor: !0 }, "Press ", Z.keyName, " again to exit")
        : FB.createElement(M, { dimColor: !0 }, "Esc to cancel"),
    );
  if (A.source === "policySettings")
    return FB.createElement(
      FB.Fragment,
      null,
      FB.createElement(
        y,
        {
          flexDirection: "column",
          gap: 1,
          borderStyle: "round",
          paddingLeft: 1,
          paddingRight: 1,
          borderColor: "permission",
        },
        FB.createElement(M, { bold: !0, color: "permission" }, "Rule details"),
        G,
        FB.createElement(
          M,
          { italic: !0 },
          "This rule is configured by managed settings and cannot be modified.",
          `
`,
          "Contact your system administrator for more information.",
        ),
      ),
      Y,
    );
  return FB.createElement(
    FB.Fragment,
    null,
    FB.createElement(
      y,
      { flexDirection: "column", gap: 1, borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "error" },
      FB.createElement(M, { bold: !0, color: "error" }, "Delete ", HW5(A.ruleBehavior), " tool?"),
      G,
      FB.createElement(M, null, "Are you sure you want to delete this permission rule?"),
      FB.createElement(xA, {
        onChange: (I) => (I === "yes" ? B() : Q()),
        onCancel: Q,
        options: [
          { label: "Yes", value: "yes" },
          { label: "No", value: "no" },
        ],
      }),
    ),
    Y,
  );
}
function eqB({ onExit: A }) {
  let [B, Q] = CW.useState([]),
    [{ toolPermissionContext: Z }, G] = dB(),
    [Y, I] = CW.useState("allow"),
    [W, J] = CW.useState(),
    [X, F] = CW.useState(!1),
    [V, K] = CW.useState(null),
    [H, z] = CW.useState(!1),
    [D, C] = CW.useState(null),
    w = CW.useMemo(() => {
      let j = new Map();
      return (
        sg(Z).forEach((r) => {
          j.set(JSON.stringify(r), r);
        }),
        j
      );
    }, [Z]),
    E = CW.useMemo(() => {
      let j = new Map();
      return (
        xa(Z).forEach((r) => {
          j.set(JSON.stringify(r), r);
        }),
        j
      );
    }, [Z]),
    L = CW.useMemo(() => {
      let j = new Map();
      return (
        KU1(Z).forEach((r) => {
          j.set(JSON.stringify(r), r);
        }),
        j
      );
    }, [Z]),
    O = (() => {
      switch (Y) {
        case "allow":
          return w;
        case "deny":
          return E;
        case "ask":
          return L;
        case "workspace":
          return new Map();
      }
    })(),
    R = CW.useMemo(() => {
      let j = [];
      if (Y !== "workspace") j.push({ label: `Add a new rule${t0.ellipsis}`, value: "add-new-rule" });
      let r = Array.from(O.keys()).sort((Q1, J1) => {
        let R1 = O.get(Q1),
          s1 = O.get(J1);
        if (R1 && s1) {
          let Z0 = n6(R1.ruleValue).toLowerCase(),
            _0 = n6(s1.ruleValue).toLowerCase();
          return Z0.localeCompare(_0);
        }
        return 0;
      });
      for (let Q1 of r) {
        let J1 = O.get(Q1);
        if (J1) j.push({ label: n6(J1.ruleValue), value: Q1 });
      }
      return j;
    }, [O, Y]),
    P = Z2();
  s0((j, r) => {
    if (W || X || V || H || D) return;
    if (r.tab && !r.shift)
      I((Q1) => {
        let R1 = (eF.indexOf(Q1) + 1) % eF.length;
        return eF[R1];
      });
    else if ((r.tab && r.shift) || r.leftArrow)
      I((Q1) => {
        let R1 = (eF.indexOf(Q1) - 1 + eF.length) % eF.length;
        return eF[R1];
      });
    else if (r.rightArrow)
      I((Q1) => {
        let R1 = (eF.indexOf(Q1) + 1) % eF.length;
        return eF[R1];
      });
  });
  let _ = CW.useCallback(
      (j) => {
        if (j === "add-new-rule") {
          F(!0);
          return;
        } else {
          J(O.get(j));
          return;
        }
      },
      [J, O],
    ),
    b = CW.useCallback(() => {
      F(!1);
    }, []),
    S = CW.useCallback((j, r) => {
      (K({ ruleValue: j, ruleBehavior: r }), F(!1));
    }, []),
    d = CW.useCallback((j) => {
      K(null);
      for (let r of j) Q((Q1) => [...Q1, `Added ${r.ruleBehavior} rule ${n1.bold(n6(r.ruleValue))}`]);
    }, []),
    u = CW.useCallback(() => {
      K(null);
    }, []),
    o = () => {
      if (!W) return;
      (L$A({
        rule: W,
        initialContext: Z,
        setToolPermissionContext(j) {
          G((r) => ({ ...r, toolPermissionContext: j }));
        },
      }),
        Q((j) => [...j, `Deleted ${W.ruleBehavior} rule ${n1.bold(n6(W.ruleValue))}`]),
        J(void 0));
    };
  if (W) return FB.createElement(zW5, { rule: W, onDelete: o, onCancel: () => J(void 0) });
  if (X && Y !== "workspace") return FB.createElement(aqB, { onCancel: b, onSubmit: S, ruleBehavior: Y });
  if (V)
    return FB.createElement(zUB, {
      onAddRules: d,
      onCancel: u,
      ruleValues: [V.ruleValue],
      ruleBehavior: V.ruleBehavior,
      initialContext: Z,
      setToolPermissionContext: (j) => {
        G((r) => ({ ...r, toolPermissionContext: j }));
      },
    });
  if (H)
    return FB.createElement(mw1, {
      onAddDirectory: (j, r) => {
        let J1 = { type: "addDirectories", directories: [j], destination: r ? "localSettings" : "session" },
          R1 = HF(Z, J1);
        if ((G((s1) => ({ ...s1, toolPermissionContext: R1 })), r)) ig(J1);
        (Q((s1) => [
          ...s1,
          `Added directory ${n1.bold(j)} to workspace${r ? " and saved to local settings" : " for this session"}`,
        ]),
          z(!1));
      },
      onCancel: () => z(!1),
      permissionContext: Z,
    });
  if (D)
    return FB.createElement(tqB, {
      directoryPath: D,
      onRemove: () => {
        (Q((j) => [...j, `Removed directory ${n1.bold(D)} from workspace`]), C(null));
      },
      onCancel: () => C(null),
      permissionContext: Z,
      setPermissionContext: (j) => {
        G((r) => ({ ...r, toolPermissionContext: j }));
      },
    });
  function m() {
    if (Y === "workspace")
      return FB.createElement(rqB, {
        onExit: A,
        getToolPermissionContext: () => Z,
        onRequestAddDirectory: () => z(!0),
        onRequestRemoveDirectory: (j) => C(j),
      });
    return FB.createElement(
      y,
      { marginY: 1 },
      FB.createElement(xA, {
        options: R,
        onChange: _,
        onCancel: () => {
          if (B.length > 0)
            A(
              B.join(`
`),
            );
          else A();
        },
        visibleOptionCount: Math.min(10, R.length),
      }),
    );
  }
  return FB.createElement(
    FB.Fragment,
    null,
    FB.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "permission" },
      FB.createElement(oqB, { selectedTab: Y }),
      m(),
    ),
    FB.createElement(
      y,
      { marginLeft: 3 },
      P.pending
        ? FB.createElement(M, { dimColor: !0 }, "Press ", P.keyName, " again to exit")
        : FB.createElement(M, { dimColor: !0 }, "Tab to select tab · Enter to confirm · Esc to cancel"),
    ),
  );
}
var DW5 = {
    type: "local-jsx",
    name: "permissions",
    aliases: ["allowed-tools"],
    description: "Manage allow & deny tool permission rules",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A) {
      return xO0.createElement(eqB, { onExit: A });
    },
    userFacingName() {
      return "permissions";
    },
  },
  AEB = DW5;
var cW1 = A1(V1(), 1);
var GB = A1(V1(), 1);
var CW5 = ` _____________
 |          \\  \\
 | NEW TERMS \\__\\
 |              |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |              |
 |______________|`;
function BEB(A, B, Q) {
  if (A !== null && A.grove_enabled !== null) return !1;
  if (Q) return !0;
  let G = B?.notice_reminder_frequency;
  if (G !== null && G !== void 0 && A?.grove_notice_viewed_at)
    return Math.floor((Date.now() - new Date(A.grove_notice_viewed_at).getTime()) / 86400000) >= G;
  else {
    let Y = A?.grove_notice_viewed_at;
    return Y === null || Y === void 0;
  }
}
function Hg1({ showIfAlreadyViewed: A, location: B, onDone: Q }) {
  let [Z, G] = GB.useState(null),
    [Y, I] = GB.useState(null),
    W = Z2();
  if (
    (GB.useEffect(() => {
      async function F() {
        let [V, K] = await Promise.all([DA1(), hb()]);
        I(K);
        let H = BEB(V, K, A);
        if ((G(H), !H)) {
          Q("skip_rendering");
          return;
        }
        (QL0(), Y1("tengu_grove_policy_viewed", { location: B, dismissable: K?.notice_is_grace_period }));
      }
      F();
    }, [A, B, Q]),
    Z === null)
  )
    return null;
  if (!Z) return null;
  async function J(F) {
    switch (F) {
      case "accept_opt_in": {
        (await vf1(!0), Y1("tengu_grove_policy_submitted", { state: !0, dismissable: Y?.notice_is_grace_period }));
        break;
      }
      case "accept_opt_out": {
        (await vf1(!1), Y1("tengu_grove_policy_submitted", { state: !1, dismissable: Y?.notice_is_grace_period }));
        break;
      }
      case "defer":
        Y1("tengu_grove_policy_dismissed", { state: !0 });
        break;
      case "escape":
        Y1("tengu_grove_policy_escaped", {});
        break;
    }
    Q(F);
  }
  let X = Y?.domain_excluded
    ? [{ label: "Accept terms • Help improve Claude: OFF (for emails with your domain)", value: "accept_opt_out" }]
    : [
        { label: "Accept terms • Help improve Claude: ON", value: "accept_opt_in" },
        { label: "Accept terms • Help improve Claude: OFF", value: "accept_opt_out" },
      ];
  return GB.default.createElement(
    GB.default.Fragment,
    null,
    GB.default.createElement(
      y,
      {
        flexDirection: "column",
        width: 100,
        gap: 1,
        paddingTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        borderStyle: "round",
        borderColor: "professionalBlue",
      },
      GB.default.createElement(
        y,
        { flexDirection: "row" },
        GB.default.createElement(
          y,
          { flexDirection: "column", gap: 1, flexGrow: 1 },
          GB.default.createElement(
            y,
            { flexDirection: "column" },
            GB.default.createElement(
              M,
              { bold: !0, color: "professionalBlue" },
              "Updates to Consumer Terms and Policies",
            ),
            Y?.notice_is_grace_period
              ? GB.default.createElement(
                  M,
                  null,
                  "An update to our Consumer Terms and Privacy Policy will take effect on ",
                  GB.default.createElement(M, { bold: !0 }, "September 28, 2025"),
                  ". You can accept the updated terms today.",
                )
              : GB.default.createElement(M, null, "We’re updating our Consumer Terms and Privacy Policy"),
          ),
          GB.default.createElement(
            y,
            { flexDirection: "column" },
            GB.default.createElement(M, null, "What's changing?"),
            GB.default.createElement(
              y,
              { paddingLeft: 1 },
              GB.default.createElement(
                M,
                null,
                GB.default.createElement(M, null, "• "),
                GB.default.createElement(M, { bold: !0 }, "You can help improve Claude "),
                GB.default.createElement(
                  M,
                  null,
                  "— Allow the use of your chats and coding sessions to train and improve Anthropic AI models. Change anytime in your Privacy Settings (",
                  GB.default.createElement(H5, { url: "https://claude.ai/settings/data-privacy-controls" }),
                  ").",
                ),
              ),
            ),
            GB.default.createElement(
              y,
              { paddingLeft: 1 },
              GB.default.createElement(
                M,
                null,
                GB.default.createElement(M, null, "• "),
                GB.default.createElement(M, { bold: !0 }, "Updates to data retention "),
                GB.default.createElement(
                  M,
                  null,
                  "— To help us improve our AI models and safety protections, we're extending data retention to 5 years.",
                ),
              ),
            ),
          ),
          GB.default.createElement(
            M,
            null,
            "Learn more (",
            GB.default.createElement(H5, { url: "https://www.anthropic.com/news/updates-to-our-consumer-terms" }),
            ") or read the updated Consumer Terms (",
            GB.default.createElement(H5, { url: "https://anthropic.com/legal/terms" }),
            ") and Privacy Policy (",
            GB.default.createElement(H5, { url: "https://anthropic.com/legal/privacy" }),
            ")",
          ),
        ),
        GB.default.createElement(y, { flexShrink: 0 }, GB.default.createElement(M, { color: "professionalBlue" }, CW5)),
      ),
      GB.default.createElement(
        y,
        { flexDirection: "column", gap: 1, padding: 1, borderStyle: "round", borderColor: "professionalBlue" },
        GB.default.createElement(
          y,
          { flexDirection: "column" },
          GB.default.createElement(M, { bold: !0 }, "Please select how you'd like to continue"),
          GB.default.createElement(M, null, "Your choice takes effect immediately upon confirmation."),
        ),
        GB.default.createElement(xA, {
          options: [...X, ...(Y?.notice_is_grace_period ? [{ label: "Not now", value: "defer" }] : [])],
          onChange: (F) => J(F),
          onCancel: () => {
            if (Y?.notice_is_grace_period) {
              J("defer");
              return;
            }
            J("escape");
          },
        }),
      ),
    ),
    GB.default.createElement(
      y,
      { marginLeft: 1 },
      GB.default.createElement(
        M,
        { dimColor: !0 },
        W.pending
          ? GB.default.createElement(GB.default.Fragment, null, "Press ", W.keyName, " again to exit")
          : GB.default.createElement(GB.default.Fragment, null, "Enter to confirm · Esc to exit"),
      ),
    ),
  );
}
function QEB({ settings: A, domainExcluded: B, onDone: Q }) {
  let Z = Z2(),
    [G, Y] = GB.useState(A.grove_enabled);
  (GB.default.useEffect(() => {
    Y1("tengu_grove_privacy_settings_viewed", {});
  }, []),
    s0(async (W, J) => {
      if (J.escape) Q();
      if (!B && (J.tab || J.return || W === " ")) {
        let X = !G;
        (Y(X), await vf1(X));
      }
    }));
  let I = GB.default.createElement(M, { color: "error" }, "false");
  if (B) I = GB.default.createElement(M, { color: "error" }, "false (for emails with your domain)");
  else if (G) I = GB.default.createElement(M, { color: "success" }, "true");
  return GB.default.createElement(
    GB.default.Fragment,
    null,
    GB.default.createElement(
      y,
      { flexDirection: "column", gap: 1, padding: 1, borderStyle: "round", borderColor: "professionalBlue" },
      GB.default.createElement(
        y,
        { flexDirection: "column", gap: 1 },
        GB.default.createElement(M, { bold: !0, color: "professionalBlue" }, "Data Privacy"),
        GB.default.createElement(
          M,
          null,
          "Review and manage your privacy settings at",
          " ",
          GB.default.createElement(H5, { url: "https://claude.ai/settings/data-privacy-controls" }),
        ),
        GB.default.createElement(
          y,
          null,
          GB.default.createElement(y, { width: 44 }, GB.default.createElement(M, { bold: !0 }, "Help improve Claude")),
          GB.default.createElement(y, null, I),
        ),
      ),
    ),
    GB.default.createElement(
      y,
      { marginLeft: 1 },
      B
        ? GB.default.createElement(
            M,
            { dimColor: !0 },
            Z.pending
              ? GB.default.createElement(GB.default.Fragment, null, "Press ", Z.keyName, " again to exit")
              : GB.default.createElement(GB.default.Fragment, null, "Esc to exit"),
          )
        : GB.default.createElement(
            M,
            { dimColor: !0 },
            Z.pending
              ? GB.default.createElement(GB.default.Fragment, null, "Press ", Z.keyName, " again to exit")
              : GB.default.createElement(GB.default.Fragment, null, "Enter/Tab/Space to toggle · Esc to exit"),
          ),
    ),
  );
}
async function ZEB() {
  let [A, B] = await Promise.all([DA1(), hb()]);
  if (BEB(A, B, !1))
    if (
      (Y1("tengu_grove_print_viewed", { dismissable: B?.notice_is_grace_period }),
      B === null || B.notice_is_grace_period)
    )
      (jT(`
An update to our Consumer Terms and Privacy Policy will take effect on September 28, 2025. Run \`claude\` to review the updated terms.

`),
        await QL0());
    else
      (jT(`
[ACTION REQUIRED] An update to our Consumer Terms and Privacy Policy has taken effect on September 28, 2025. You must run \`claude\` to review the updated terms.

`),
        await Z5(1));
}
var PRIVACY_SETTINGS_MESSAGE = "Review and manage your privacy settings at https://claude.ai/settings/data-privacy-controls",
  UW5 = {
    type: "local-jsx",
    name: "privacy-settings",
    description: "View and update your privacy settings",
    isEnabled: () => {
      return GS1();
    },
    isHidden: !1,
    async call(A) {
      if (!(await CA1())) return (A(PRIVACY_SETTINGS_MESSAGE), null);
      let [Q, Z] = await Promise.all([DA1(), hb()]);
      if (Q === null) return (A(PRIVACY_SETTINGS_MESSAGE), null);
      async function G(I) {
        if (I === "escape" || I === "defer") {
          A();
          return;
        }
        await Y();
      }
      async function Y() {
        let I = await DA1();
        if (I === null) {
          A();
          return;
        }
        let W = I.grove_enabled ? "true" : "false";
        if (
          (A(`"Help improve Claude" set to ${W}.`),
          Q !== null && Q.grove_enabled !== null && Q.grove_enabled !== I.grove_enabled)
        )
          Y1("tengu_grove_policy_toggled", { state: I.grove_enabled, location: "settings" });
      }
      if (Q.grove_enabled !== null)
        return cW1.createElement(QEB, { settings: Q, domainExcluded: Z?.domain_excluded, onDone: Y });
      return cW1.createElement(Hg1, { showIfAlreadyViewed: !0, onDone: G, location: "settings" });
    },
    userFacingName() {
      return "privacy-settings";
    },
  },
  YEB = UW5;
var SR0 = A1(V1(), 1);
var nQ = A1(V1(), 1);
var MJ = A1(V1(), 1);
function IEB() {
  let A = [],
    B = ["userSettings", "projectSettings", "localSettings"];
  for (let Q of B) {
    let Z = D8(Q);
    if (!Z?.hooks) continue;
    for (let [G, Y] of Object.entries(Z.hooks))
      for (let I of Y) for (let W of I.hooks) A.push({ event: G, config: W, matcher: I.matcher, source: Q });
  }
  return A;
}
async function WEB(A, B, Q = "", Z = "userSettings") {
  let Y = (D8(Z) ?? {}).hooks ?? {},
    I = Y[A] ?? [],
    W = I.findIndex((V) => V.matcher === Q),
    J;
  if (W >= 0) {
    J = [...I];
    let V = J[W];
    J[W] = { matcher: V.matcher, hooks: [...V.hooks, B] };
  } else J = [...I, { matcher: Q, hooks: [B] }];
  let X = { ...Y, [A]: J },
    { error: F } = W4(Z, { hooks: X });
  if (F) throw new Error(F.message);
  h61();
}
async function JEB(A) {
  if (A.source === "pluginHook")
    throw new Error("Plugin hooks cannot be removed through settings. Disable the plugin instead.");
  let Q = (D8(A.source) ?? {}).hooks ?? {},
    G = (Q[A.event] ?? [])
      .map((I) => {
        if (I.matcher === A.matcher) {
          let W = I.hooks.filter((J) => J.command !== A.config.command);
          return W.length > 0 ? { ...I, hooks: W } : null;
        }
        return I;
      })
      .filter((I) => I !== null),
    Y = { ...Q, [A.event]: G };
  if (Y[A.event]?.length === 0) delete Y[A.event];
  (W4(A.source, { hooks: Object.keys(Y).length > 0 ? Y : void 0 }), h61());
}
function XEB(A) {
  switch (A) {
    case "userSettings":
      return "User settings (~/.claude/settings.json)";
    case "projectSettings":
      return "Project settings (.claude/settings.json)";
    case "localSettings":
      return "Local settings (.claude/settings.local.json)";
    case "pluginHook":
      return "Plugin hooks (~/.claude/plugins/*/hooks/hooks.json)";
    default:
      return A;
  }
}
function FEB(A) {
  switch (A) {
    case "userSettings":
      return "User Settings";
    case "projectSettings":
      return "Project Settings";
    case "localSettings":
      return "Local Settings";
    case "pluginHook":
      return "Plugin Hooks";
    default:
      return A;
  }
}
function VEB(A) {
  switch (A) {
    case "userSettings":
      return "User";
    case "projectSettings":
      return "Project";
    case "localSettings":
      return "Local";
    case "pluginHook":
      return "Plugin";
    default:
      return A;
  }
}
function KEB(A, B, Q) {
  let Z = uA1.reduce((G, Y, I) => {
    return ((G[Y] = I), G);
  }, {});
  return [...A].sort((G, Y) => {
    let I = B[Q]?.[G] || [],
      W = B[Q]?.[Y] || [],
      J = Array.from(new Set(I.map((H) => H.source))),
      X = Array.from(new Set(W.map((H) => H.source))),
      F = (H) => (H === "pluginHook" ? 999 : Z[H]),
      V = Math.min(...J.map(F)),
      K = Math.min(...X.map(F));
    if (V !== K) return V - K;
    return G.localeCompare(Y);
  });
}
var g5 = A1(V1(), 1);
var vO0 = A1(V1(), 1);
function HEB({ event: A, eventSummary: B, config: Q, matcher: Z, onSuccess: G, onCancel: Y }) {
  let [I, W] = vO0.useState(!1),
    [J, X] = vO0.useState(null),
    F = uA1.map(XM0),
    V = async (K) => {
      (W(!0), X(null));
      try {
        (await WEB(A, Q, Z, K), G());
      } catch (H) {
        (X(H instanceof Error ? H.message : "Failed to add hook"), W(!1));
      }
    };
  if (I)
    return g5.createElement(
      y,
      { flexDirection: "column", gap: 1 },
      g5.createElement(
        y,
        { flexDirection: "row", gap: 1 },
        g5.createElement(u6, null),
        g5.createElement(M, null, "Adding hook configuration..."),
      ),
    );
  if (J)
    return g5.createElement(
      y,
      { flexDirection: "column", gap: 1, borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "error" },
      g5.createElement(M, { bold: !0, color: "error" }, "Failed to add hook"),
      g5.createElement(M, null, J),
      g5.createElement(xA, { options: [{ label: "OK", value: "ok" }], onChange: Y, onCancel: Y }),
    );
  return g5.createElement(
    y,
    { flexDirection: "column", gap: 1, borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "success" },
    g5.createElement(M, { bold: !0, color: "success" }, "Save hook configuration"),
    g5.createElement(
      y,
      { flexDirection: "column", marginX: 2 },
      g5.createElement(M, null, "Event: ", A, " - ", B),
      g5.createElement(M, null, "Matcher: ", Z),
      g5.createElement(M, null, "Command: ", Q.command),
    ),
    g5.createElement(M, null, "Where should this hook be saved?"),
    g5.createElement(xA, { options: F, onChange: (K) => V(K), onCancel: Y, visibleOptionCount: 3 }),
  );
}
var c2 = A1(V1(), 1);
function zEB({
  hookEventMetadata: A,
  exitStatePending: B,
  exitStateKeyName: Q,
  configDifference: Z,
  onSelectEvent: G,
}) {
  return c2.createElement(
    c2.Fragment,
    null,
    c2.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "warning" },
      c2.createElement(
        y,
        { flexDirection: "column", marginBottom: 1 },
        c2.createElement(y, null, c2.createElement(M, { bold: !0, color: "warning" }, "Hook Configuration")),
        c2.createElement(
          y,
          { flexDirection: "column" },
          c2.createElement(
            y,
            { marginY: 0.5 },
            c2.createElement(
              M,
              null,
              n1.bold("Hooks"),
              " are shell commands you can register to run during Claude Code processing.",
              " ",
              c2.createElement(H5, { url: "https://docs.anthropic.com/en/docs/claude-code/hooks" }, "Docs"),
            ),
          ),
          c2.createElement(
            y,
            { flexDirection: "column", paddingTop: 0.25 },
            c2.createElement(M, null, "• Each hook event has its own input and output behavior"),
            c2.createElement(M, null, "• Multiple hooks can be registered per event, executed in parallel"),
            c2.createElement(M, null, "• Any changes to hooks outside of /hooks require a restart"),
            c2.createElement(M, null, "• Timeout: 60 seconds"),
          ),
        ),
        c2.createElement(
          y,
          { borderStyle: "round", borderColor: "error", paddingX: 1, marginY: 0.5 },
          c2.createElement(
            y,
            { flexDirection: "column" },
            c2.createElement(
              M,
              { bold: !0, color: "error" },
              t0.warning,
              " CRITICAL SECURITY WARNING - USE AT YOUR OWN RISK",
            ),
            c2.createElement(
              M,
              null,
              "Hooks execute arbitrary shell commands with YOUR full user permissions without confirmation.",
            ),
            c2.createElement(M, null, "• You are SOLELY RESPONSIBLE for ensuring your hooks are safe and secure"),
            c2.createElement(M, null, "• Hooks can modify, delete, or access ANY files your user account can access"),
            c2.createElement(
              M,
              null,
              "• Malicious or poorly written hooks can cause irreversible data loss or system damage",
            ),
            c2.createElement(
              M,
              null,
              "• Anthropic provides NO WARRANTY and assumes NO LIABILITY for any damages resulting from hook usage",
            ),
            c2.createElement(M, null, "• Only use hooks from trusted sources to prevent data exfiltration"),
            c2.createElement(
              M,
              null,
              "• Review",
              " ",
              c2.createElement(
                H5,
                { url: "https://docs.anthropic.com/en/docs/claude-code/hooks" },
                "the hooks documentation",
              ),
              " ",
              "before proceeding",
            ),
          ),
        ),
        Z &&
          c2.createElement(
            y,
            { borderStyle: "round", borderColor: "warning", paddingX: 1, marginY: 0.5 },
            c2.createElement(
              y,
              { flexDirection: "column" },
              c2.createElement(M, { bold: !0, color: "warning" }, t0.warning, " Settings Changed"),
              c2.createElement(
                M,
                null,
                "Hook settings have been modified outside of this menu. Review the following changes carefully:",
              ),
              c2.createElement(M, { dimColor: !0 }, Z),
            ),
          ),
      ),
      c2.createElement(
        y,
        { flexDirection: "column" },
        c2.createElement(M, { bold: !0 }, "Select hook event:"),
        c2.createElement(xA, {
          onChange: (Y) => {
            if (Y === "disable-all") G("disable-all");
            else G(Y);
          },
          onCancel: () => {},
          options: [
            ...Object.entries(A).map(([Y, I]) => ({ label: `${Y} - ${I.summary}`, value: Y })),
            { label: n1.red("Disable all hooks"), value: "disable-all" },
          ],
        }),
      ),
    ),
    c2.createElement(
      y,
      { marginLeft: 3 },
      B
        ? c2.createElement(M, { dimColor: !0 }, "Press ", Q, " again to exit")
        : c2.createElement(M, { dimColor: !0 }, "Enter to acknowledge risks and continue · Esc to exit"),
    ),
  );
}
var O7 = A1(V1(), 1);
function DEB({
  selectedEvent: A,
  matchersForSelectedEvent: B,
  hooksByEventAndMatcher: Q,
  eventDescription: Z,
  onSelect: G,
  onCancel: Y,
}) {
  let I = O7.useMemo(() => {
    return B.map((W) => {
      let J = Q[A]?.[W] || [],
        X = Array.from(new Set(J.map((F) => F.source)));
      return { matcher: W, sources: X, hookCount: J.length };
    });
  }, [B, Q, A]);
  return O7.createElement(
    O7.Fragment,
    null,
    O7.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "suggestion" },
      O7.createElement(M, { bold: !0, color: "suggestion" }, A, " - Tool Matchers"),
      Z && O7.createElement(y, { marginTop: 1 }, O7.createElement(M, { dimColor: !0 }, Z)),
      O7.createElement(
        y,
        { marginY: 1 },
        O7.createElement(xA, {
          options: [
            { label: `+ Add new matcher${t0.ellipsis}`, value: "add-new" },
            ...I.map((W) => {
              return {
                label: `[${W.sources.map(VEB).join(", ")}] ${W.matcher}`,
                value: W.matcher,
                description: `${W.hookCount} hook${W.hookCount !== 1 ? "s" : ""}`,
              };
            }),
          ],
          onChange: (W) => {
            if (W === "add-new") G(null);
            else G(W);
          },
          onCancel: Y,
        }),
        B.length === 0 &&
          O7.createElement(y, { marginLeft: 2 }, O7.createElement(M, { dimColor: !0 }, "No matchers configured yet")),
      ),
    ),
    O7.createElement(y, { marginLeft: 3 }, O7.createElement(M, { dimColor: !0 }, "Enter to select · Esc to go back")),
  );
}
var Y6 = A1(V1(), 1);
function CEB({ selectedEvent: A, newMatcher: B, onChangeNewMatcher: Q, eventDescription: Z, matcherMetadata: G }) {
  let [Y, I] = Y6.useState(B.length);
  return Y6.createElement(
    Y6.Fragment,
    null,
    Y6.createElement(
      y,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "success",
        gap: 1,
      },
      Y6.createElement(M, { bold: !0, color: "success" }, "Add new matcher for ", A),
      Z && Y6.createElement(y, { marginBottom: 0.5 }, Y6.createElement(M, { dimColor: !0 }, Z)),
      Y6.createElement(
        y,
        { flexDirection: "column", gap: 1 },
        Y6.createElement(M, null, "Possible matcher values for field ", G.fieldToMatch, ":"),
        Y6.createElement(M, { dimColor: !0 }, G.values.join(", ")),
      ),
      Y6.createElement(
        y,
        { flexDirection: "column" },
        Y6.createElement(M, null, "Tool matcher:"),
        Y6.createElement(
          y,
          { borderStyle: "round", borderDimColor: !0, paddingLeft: 1, paddingRight: 1 },
          Y6.createElement(s4, {
            value: B,
            onChange: Q,
            columns: 78,
            showCursor: !0,
            cursorOffset: Y,
            onChangeCursorOffset: I,
          }),
        ),
      ),
      Y6.createElement(
        y,
        { flexDirection: "column", gap: 1 },
        Y6.createElement(
          M,
          { dimColor: !0 },
          "Example Matchers:",
          `
`,
          "• Write (single tool)",
          `
`,
          "• Write|Edit|MultiEdit (multiple tools)",
          `
`,
          "• Web.* (regex pattern)",
        ),
      ),
    ),
    Y6.createElement(y, { marginLeft: 3 }, Y6.createElement(M, { dimColor: !0 }, "Enter to confirm · Esc to cancel")),
  );
}
var F2 = A1(V1(), 1);
function UEB({
  selectedEvent: A,
  selectedMatcher: B,
  eventDescription: Q,
  fullDescription: Z,
  supportsMatcher: G,
  command: Y,
  onChangeCommand: I,
}) {
  let [W, J] = F2.useState(Y.length),
    { columns: X } = IB(),
    F = Y.trim().split(/\s+/)[0] || "",
    V = F && !F.startsWith("/") && !F.startsWith("~") && F.includes("/"),
    K = /\bsudo\b/.test(Y);
  return F2.createElement(
    F2.Fragment,
    null,
    F2.createElement(
      y,
      {
        flexDirection: "column",
        borderStyle: "round",
        paddingLeft: 1,
        paddingRight: 1,
        borderColor: "success",
        gap: 1,
      },
      F2.createElement(M, { bold: !0, color: "success" }, "Add new hook"),
      F2.createElement(
        y,
        { borderStyle: "round", borderColor: "error", paddingLeft: 1, paddingRight: 1, flexDirection: "column" },
        F2.createElement(M, { bold: !0, color: "error" }, t0.warning, " CRITICAL SECURITY WARNING"),
        F2.createElement(
          M,
          null,
          "Hooks execute arbitrary shell commands with YOUR full user permissions. By proceeding, you acknowledge:",
        ),
        F2.createElement(M, null, "• You are SOLELY responsible for any commands you configure"),
        F2.createElement(M, null, "• Hooks can modify, delete, or access ANY files your user can access"),
        F2.createElement(M, null, "• Anthropic provides NO WARRANTY and assumes NO LIABILITY for damages"),
        F2.createElement(M, null, "• USE AT YOUR OWN RISK - Test thoroughly before production use"),
        F2.createElement(
          M,
          null,
          "• Review",
          " ",
          F2.createElement(
            H5,
            { url: "https://docs.anthropic.com/en/docs/claude-code/hooks" },
            "the hooks documentation",
          ),
          " ",
          "before proceeding",
        ),
      ),
      F2.createElement(M, null, "Event: ", F2.createElement(M, { bold: !0 }, A), " - ", Q),
      Z && F2.createElement(y, null, F2.createElement(M, { dimColor: !0 }, Z)),
      G && F2.createElement(M, null, "Matcher: ", F2.createElement(M, { bold: !0 }, B)),
      F2.createElement(M, null, "Command:"),
      F2.createElement(
        y,
        { borderStyle: "round", borderDimColor: !0, paddingLeft: 1, paddingRight: 1 },
        F2.createElement(s4, {
          value: Y,
          onChange: I,
          columns: X - 8,
          showCursor: !0,
          cursorOffset: W,
          onChangeCursorOffset: J,
          multiline: !0,
        }),
      ),
      (V || K) &&
        F2.createElement(
          y,
          { flexDirection: "column", gap: 0 },
          V &&
            F2.createElement(
              M,
              { color: "warning" },
              t0.warning,
              " Warning: Using a relative path for the executable may be insecure. Consider using an absolute path instead.",
            ),
          K &&
            F2.createElement(
              M,
              { color: "warning" },
              t0.warning,
              " Warning: Using sudo in hooks can be dangerous and may expose your system to security risks.",
            ),
        ),
      F2.createElement(
        M,
        { dimColor: !0 },
        "Examples:",
        F2.createElement(l3, null),
        `• jq -r '.tool_input.file_path | select(endswith(".go"))' | xargs -r gofmt -w`,
        F2.createElement(l3, null),
        `• jq -r '"\\(.tool_input.command) - \\(.tool_input.description // "No description")"' >> ~/.claude/bash-command-log.txt`,
        F2.createElement(l3, null),
        "• /usr/local/bin/security_check.sh",
        F2.createElement(l3, null),
        "• python3 ~/hooks/validate_changes.py",
      ),
      F2.createElement(
        y,
        { marginTop: 1, flexDirection: "column", gap: 0 },
        F2.createElement(M, { bold: !0, color: "warning" }, t0.warning, " Security Best Practices:"),
        F2.createElement(
          M,
          { dimColor: !0 },
          "• Use absolute paths for custom scripts (~/scripts/check.sh not check.sh)",
          F2.createElement(l3, null),
          "• Avoid using sudo - hooks run with your user permissions",
          F2.createElement(l3, null),
          "• Be cautious with patterns that match sensitive files (.env, .ssh/*, secrets.*)",
          F2.createElement(l3, null),
          "• Validate and sanitize input paths (reject ../ paths, check expected formats)",
          F2.createElement(l3, null),
          "• Avoid piping untrusted content to shells (curl ... | sh, | bash)",
          F2.createElement(l3, null),
          "• Use restrictive file permissions (chmod 644, not 777)",
          F2.createElement(l3, null),
          '• Quote all variable expansions to prevent injection: "$VAR"',
          F2.createElement(l3, null),
          "• Keep error checking enabled in scripts (avoid set +e)",
        ),
        F2.createElement(
          M,
          { bold: !0, color: "warning" },
          "By adding this hook, you accept all responsibility for its execution and any consequences.",
        ),
      ),
    ),
    F2.createElement(y, { marginLeft: 3 }, F2.createElement(M, { dimColor: !0 }, "Enter to confirm · Esc to cancel")),
  );
}
var dZ = A1(V1(), 1);
function $EB({ selectedMatcher: A, selectedEvent: B, onDelete: Q, onCancel: Z }) {
  return dZ.createElement(
    dZ.Fragment,
    null,
    dZ.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "error", gap: 1 },
      dZ.createElement(M, { bold: !0, color: "error" }, "Delete matcher?"),
      dZ.createElement(
        y,
        { flexDirection: "column", marginX: 2 },
        dZ.createElement(M, { bold: !0 }, A),
        dZ.createElement(M, { color: "text" }, "Event: ", B),
      ),
      dZ.createElement(M, null, "This matcher has no hooks configured. Delete it?"),
      dZ.createElement(xA, {
        onChange: (G) => (G === "yes" ? Q() : Z()),
        onCancel: Z,
        options: [
          { label: "Yes", value: "yes" },
          { label: "No", value: "no" },
        ],
      }),
    ),
    dZ.createElement(y, { marginLeft: 3 }, dZ.createElement(M, { dimColor: !0 }, "Enter to confirm · Esc to cancel")),
  );
}
var R3 = A1(V1(), 1);
function wEB({
  selectedEvent: A,
  selectedMatcher: B,
  hooksForSelectedMatcher: Q,
  hookEventMetadata: Z,
  onSelect: G,
  onCancel: Y,
}) {
  return R3.createElement(
    R3.Fragment,
    null,
    R3.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "success" },
      R3.createElement(M, { bold: !0, color: "success" }, A, Z.matcherMetadata !== void 0 ? ` - Matcher: ${B}` : ""),
      Z.description && R3.createElement(y, { marginTop: 1 }, R3.createElement(M, { dimColor: !0 }, Z.description)),
      R3.createElement(
        y,
        { marginY: 1 },
        R3.createElement(xA, {
          options: [
            { label: `+ Add new hook${t0.ellipsis}`, value: "add-new" },
            ...Q.map((I, W) => ({ label: I.config.command, value: W.toString(), description: FEB(I.source) })),
          ],
          onChange: (I) => {
            if (I === "add-new") G(null);
            else {
              let W = parseInt(I, 10),
                J = Q[W];
              if (J) G(J);
            }
          },
          onCancel: Y,
        }),
        Q.length === 0 &&
          R3.createElement(y, { marginLeft: 2 }, R3.createElement(M, { dimColor: !0 }, "No hooks configured yet")),
      ),
    ),
    R3.createElement(y, { marginLeft: 3 }, R3.createElement(M, { dimColor: !0 }, "Enter to select · Esc to go back")),
  );
}
var R7 = A1(V1(), 1);
function qEB({ selectedHook: A, eventSupportsMatcher: B, onDelete: Q, onCancel: Z }) {
  return R7.createElement(
    R7.Fragment,
    null,
    R7.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "error", gap: 1 },
      R7.createElement(M, { bold: !0, color: "error" }, "Delete hook?"),
      R7.createElement(
        y,
        { flexDirection: "column", marginX: 2 },
        R7.createElement(M, { bold: !0 }, A.config.command),
        R7.createElement(M, { dimColor: !0 }, "Event: ", A.event),
        B && R7.createElement(M, { dimColor: !0 }, "Matcher: ", A.matcher),
        R7.createElement(M, { dimColor: !0 }, XEB(A.source)),
      ),
      R7.createElement(M, null, "This will remove the hook configuration from your settings."),
      R7.createElement(xA, {
        onChange: (G) => (G === "yes" ? Q() : Z()),
        onCancel: Z,
        options: [
          { label: "Yes", value: "yes" },
          { label: "No", value: "no" },
        ],
      }),
    ),
    R7.createElement(y, { marginLeft: 3 }, R7.createElement(M, { dimColor: !0 }, "Enter to confirm · Esc to cancel")),
  );
}
var lW1 = YA(function (A) {
  return {
    PreToolUse: {
      summary: "Before tool execution",
      description: `Input to command is JSON of tool call arguments.
Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to model and block tool call
Other exit codes - show stderr to user only but continue with tool call`,
      matcherMetadata: { fieldToMatch: "tool_name", values: A },
    },
    PostToolUse: {
      summary: "After tool execution",
      description: `Input to command is JSON with fields "inputs" (tool call arguments) and "response" (tool call response).
Exit code 0 - stdout shown in transcript mode (Ctrl-O)
Exit code 2 - show stderr to model immediately
Other exit codes - show stderr to user only`,
      matcherMetadata: { fieldToMatch: "tool_name", values: A },
    },
    Notification: { summary: "When notifications are sent", description: "" },
    UserPromptSubmit: {
      summary: "When the user submits a prompt",
      description: `Input to command is JSON with original user prompt text.
Exit code 0 - stdout shown to Claude
Exit code 2 - block processing, erase original prompt, and show stderr to user only
Other exit codes - show stderr to user only`,
    },
    SessionStart: {
      summary: "When a new session is started",
      description: `Input to command is JSON with session start source.
Exit code 0 - stdout shown to Claude
Blocking errors are ignored
Other exit codes - show stderr to user only`,
      matcherMetadata: { fieldToMatch: "source", values: ["startup", "resume", "clear", "compact"] },
    },
    Stop: {
      summary: "Right before Claude concludes its response",
      description: `Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to model and continue conversation
Other exit codes - show stderr to user only`,
    },
    SubagentStop: {
      summary: "Right before a subagent (Task tool call) concludes its response",
      description: `Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to subagent and continue having it run
Other exit codes - show stderr to user only`,
    },
    PreCompact: {
      summary: "Before conversation compaction",
      description: `Input to command is JSON with compaction details.
Exit code 0 - stdout appended as custom compact instructions
Exit code 2 - block compaction
Other exit codes - show stderr to user only but continue with compaction`,
      matcherMetadata: { fieldToMatch: "trigger", values: ["manual", "auto"] },
    },
    SessionEnd: {
      summary: "When a session is ending",
      description: `Input to command is JSON with session end reason.
Exit code 0 - command completes successfully
Other exit codes - show stderr to user only`,
      matcherMetadata: { fieldToMatch: "reason", values: ["clear", "logout", "prompt_input_exit", "other"] },
    },
  };
});
function EEB(A) {
  let B = {
      PreToolUse: {},
      PostToolUse: {},
      Notification: {},
      UserPromptSubmit: {},
      SessionStart: {},
      SessionEnd: {},
      Stop: {},
      SubagentStop: {},
      PreCompact: {},
    },
    Q = lW1(A);
  IEB().forEach((G) => {
    let Y = B[G.event];
    if (Y) {
      let I = Q[G.event].matcherMetadata !== void 0 ? G.matcher || "" : "";
      if (!Y[I]) Y[I] = [];
      Y[I].push(G);
    }
  });
  let Z = n$1();
  if (Z)
    for (let [G, Y] of Object.entries(Z)) {
      let I = G,
        W = B[I];
      if (!W) continue;
      for (let J of Y) {
        let X = J.matcher || "";
        if (!W[X]) W[X] = [];
        for (let F of J.hooks)
          if (F.type === "callback")
            W[X].push({
              event: I,
              config: { type: "command", command: "[Plugin Hook]" },
              matcher: J.matcher,
              source: "pluginHook",
            });
      }
    }
  return B;
}
function NEB(A, B) {
  let Q = Object.keys(A[B] || {});
  return KEB(Q, A, B);
}
function LEB(A, B, Q) {
  let Z = Q ?? "";
  return A[B]?.[Z] ?? [];
}
function OS(A, B) {
  return lW1(B)[A].matcherMetadata;
}
function MEB(A, B) {
  return lW1(B)[A].summary;
}
function OEB({ toolNames: A, onExit: B }) {
  let [Q, Z] = MJ.useState([]),
    [G, Y] = MJ.useState({ mode: "select-event" }),
    [I, W] = MJ.useState(0),
    [J, X] = MJ.useState(""),
    [F, V] = MJ.useState(""),
    K = G.mode,
    H = "event" in G ? G.event : "PreToolUse",
    z = "matcher" in G ? G.matcher : null,
    [{ mcp: D }] = dB(),
    C = MJ.useMemo(() => [...A, ...D.tools.map((m) => m.name)], [A, D.tools]),
    w = MJ.useMemo(() => EEB(C), [C, I]),
    E = MJ.useMemo(() => NEB(w, H), [w, H]),
    L = MJ.useMemo(() => LEB(w, H, z), [w, H, z]),
    O = Z2();
  s0((m, j) => {
    if (K === "save-hook") return;
    if (j.escape) {
      switch (K) {
        case "select-event":
          if (Q.length > 0)
            B(
              Q.join(`
`),
            );
          else B();
          break;
        case "select-matcher":
          Y({ mode: "select-event" });
          break;
        case "add-matcher":
          if ("event" in G) Y({ mode: "select-matcher", event: G.event, matcherMetadata: G.matcherMetadata });
          V("");
          break;
        case "delete-matcher":
          if ("event" in G) Y({ mode: "select-matcher", event: G.event, matcherMetadata: G.matcherMetadata });
          break;
        case "select-hook":
          if ("event" in G) {
            let r = OS(G.event, C);
            if (r !== void 0) Y({ mode: "select-matcher", event: G.event, matcherMetadata: r });
            else Y({ mode: "select-event" });
          }
          break;
        case "add-hook":
          if ("event" in G && "matcher" in G) Y({ mode: "select-hook", event: G.event, matcher: G.matcher });
          X("");
          break;
        case "delete-hook":
          if ("event" in G && G.mode === "delete-hook") {
            let { hook: r } = G;
            Y({ mode: "select-hook", event: G.event, matcher: r.matcher || "" });
          }
          break;
      }
      return;
    }
    switch (K) {
      case "select-event":
        if (j.return) {
          let r = H,
            Q1 = OS(r, C);
          if (Q1 !== void 0) Y({ mode: "select-matcher", event: r, matcherMetadata: Q1 });
          else Y({ mode: "select-hook", event: r, matcher: "" });
        }
        break;
      case "add-matcher":
        if (j.return && F.trim() && "event" in G) Y({ mode: "select-hook", event: G.event, matcher: F.trim() });
        break;
      case "add-hook":
        if (j.return && J.trim() && "event" in G && "matcher" in G) {
          let r = {
            event: G.event,
            config: { type: "command", command: J.trim() },
            matcher: OS(G.event, C) !== void 0 ? G.matcher : "",
          };
          Y({ mode: "save-hook", event: G.event, hookToSave: r });
        }
        break;
      case "delete-matcher":
      case "delete-hook":
      case "select-matcher":
      case "select-hook":
        break;
    }
  });
  let R = MJ.useCallback(() => {
      if (G.mode === "save-hook") {
        let { hookToSave: m } = G;
        (Z((j) => [...j, `Added ${m.event} hook: ${n1.bold(m.config.command)}`]),
          Y({ mode: "select-hook", event: m.event, matcher: m.matcher }));
      }
      (X(""), W((m) => m + 1));
    }, [G]),
    P = MJ.useCallback(() => {
      if (G.mode === "save-hook") {
        let { hookToSave: m } = G;
        Y({ mode: "select-hook", event: m.event, matcher: m.matcher });
      }
      X("");
    }, [G]),
    _ = MJ.useCallback(async () => {
      if (G.mode !== "delete-hook") return;
      let { hook: m, event: j } = G;
      (await JEB(m), Z((J1) => [...J1, `Deleted ${m.event} hook: ${n1.bold(m.config.command)}`]), W((J1) => J1 + 1));
      let r = m.matcher || "",
        Q1 = w[j]?.[r]?.filter((J1) => J1.config.command !== m.config.command);
      if (!Q1 || Q1.length === 0) {
        let J1 = OS(j, C);
        if (J1 !== void 0) Y({ mode: "select-matcher", event: j, matcherMetadata: J1 });
        else Y({ mode: "select-event" });
      } else Y({ mode: "select-hook", event: j, matcher: r });
    }, [G, w, C]),
    b = MJ.useCallback(() => {
      if (G.mode === "delete-matcher") {
        let { matcher: m, event: j } = G;
        (Z((r) => [...r, `Deleted matcher: ${n1.bold(m)}`]),
          Y({ mode: "select-matcher", event: j, matcherMetadata: G.matcherMetadata }));
      }
    }, [G]),
    S = lW1(C),
    d = hLA();
  if (
    (MJ.useEffect(() => {
      h61();
    }, []),
    E2()?.disableAllHooks === !0)
  ) {
    let m = Object.values(w).reduce((j, r) => {
      return j + Object.values(r).reduce((Q1, J1) => Q1 + J1.length, 0);
    }, 0);
    return nQ.createElement(
      nQ.Fragment,
      null,
      nQ.createElement(
        y,
        { flexDirection: "column", borderStyle: "round", paddingLeft: 1, paddingRight: 1, borderColor: "warning" },
        nQ.createElement(
          y,
          { flexDirection: "column", marginBottom: 1 },
          nQ.createElement(
            y,
            null,
            nQ.createElement(M, { bold: !0, color: "warning" }, "Hook Configuration - Disabled"),
          ),
          nQ.createElement(
            y,
            { flexDirection: "column", marginTop: 0.5 },
            nQ.createElement(
              M,
              null,
              "All hooks are currently ",
              n1.red("disabled"),
              ". You have",
              " ",
              n1.bold(m),
              " configured hook",
              m !== 1 ? "s" : "",
              " that",
              " ",
              m !== 1 ? "are" : "is",
              " not running.",
            ),
            nQ.createElement(y, { marginTop: 0.5 }, nQ.createElement(M, null, "When hooks are disabled:")),
            nQ.createElement(M, null, "• No hook commands will execute"),
            nQ.createElement(M, null, "• StatusLine will not be displayed"),
            nQ.createElement(M, null, "• Tool operations will proceed without hook validation"),
          ),
        ),
        nQ.createElement(
          y,
          { flexDirection: "column" },
          nQ.createElement(M, { bold: !0 }, "Options:"),
          nQ.createElement(xA, {
            options: [
              { label: "Re-enable all hooks", value: "enable" },
              { label: "Exit", value: "exit" },
            ],
            onChange: (j) => {
              if (j === "enable") (W4("localSettings", { disableAllHooks: !1 }), B("Re-enabled all hooks"));
              else
                B(
                  Q.length > 0
                    ? Q.join(`
`)
                    : void 0,
                );
            },
            onCancel: () =>
              B(
                Q.length > 0
                  ? Q.join(`
`)
                  : void 0,
              ),
          }),
        ),
      ),
      nQ.createElement(y, { marginLeft: 3 }, nQ.createElement(M, { dimColor: !0 }, "Enter to select · Esc to exit")),
    );
  }
  switch (G.mode) {
    case "save-hook":
      return nQ.createElement(HEB, {
        event: G.hookToSave.event,
        eventSummary: S[G.hookToSave.event].summary,
        config: G.hookToSave.config,
        matcher: G.hookToSave.matcher,
        onSuccess: R,
        onCancel: P,
      });
    case "select-event":
      return nQ.createElement(zEB, {
        hookEventMetadata: S,
        exitStatePending: O.pending,
        exitStateKeyName: O.keyName || void 0,
        configDifference: d,
        onSelectEvent: (m) => {
          if (m === "disable-all") (W4("localSettings", { disableAllHooks: !0 }), B("All hooks have been disabled"));
          else {
            let j = OS(m, C);
            if (j !== void 0) Y({ mode: "select-matcher", event: m, matcherMetadata: j });
            else Y({ mode: "select-hook", event: m, matcher: "" });
          }
        },
      });
    case "select-matcher":
      return nQ.createElement(DEB, {
        selectedEvent: G.event,
        matchersForSelectedEvent: E,
        hooksByEventAndMatcher: w,
        eventDescription: S[G.event].description,
        onSelect: (m) => {
          if (m === null) Y({ mode: "add-matcher", event: G.event, matcherMetadata: G.matcherMetadata });
          else if ((w[G.event]?.[m] || []).length === 0)
            Y({ mode: "delete-matcher", event: G.event, matcher: m, matcherMetadata: G.matcherMetadata });
          else Y({ mode: "select-hook", event: G.event, matcher: m });
        },
        onCancel: () => {
          Y({ mode: "select-event" });
        },
      });
    case "add-matcher":
      return nQ.createElement(CEB, {
        selectedEvent: G.event,
        newMatcher: F,
        onChangeNewMatcher: V,
        eventDescription: S[G.event].description,
        matcherMetadata: G.matcherMetadata,
      });
    case "delete-matcher":
      return nQ.createElement($EB, {
        selectedMatcher: G.matcher,
        selectedEvent: G.event,
        onDelete: b,
        onCancel: () => Y({ mode: "select-matcher", event: G.event, matcherMetadata: G.matcherMetadata }),
      });
    case "select-hook":
      return nQ.createElement(wEB, {
        selectedEvent: G.event,
        selectedMatcher: G.matcher,
        hooksForSelectedMatcher: L,
        hookEventMetadata: S[G.event],
        onSelect: (m) => {
          if (m === null) Y({ mode: "add-hook", event: G.event, matcher: G.matcher });
          else Y({ mode: "delete-hook", event: G.event, hook: m });
        },
        onCancel: () => {
          let m = OS(G.event, C);
          if (m !== void 0) Y({ mode: "select-matcher", event: G.event, matcherMetadata: m });
          else Y({ mode: "select-event" });
        },
      });
    case "add-hook":
      return nQ.createElement(UEB, {
        selectedEvent: G.event,
        selectedMatcher: G.matcher,
        eventDescription: MEB(G.event, C),
        fullDescription: S[G.event].description,
        supportsMatcher: OS(G.event, C) !== void 0,
        command: J,
        onChangeCommand: X,
      });
    case "delete-hook":
      return nQ.createElement(qEB, {
        selectedHook: G.hook,
        eventSupportsMatcher: OS(G.event, C) !== void 0,
        onDelete: _,
        onCancel: () => {
          let { event: m, hook: j } = G;
          Y({ mode: "select-hook", event: m, matcher: j.matcher || "" });
        },
      });
  }
}
var pW1 = A1(V1(), 1);
var oG = A1(V1(), 1);
function bO0({ count: A, countLabel: B, secondaryCount: Q, secondaryLabel: Z, content: G, verbose: Y }) {
  let I = oG.default.createElement(
      oG.default.Fragment,
      null,
      "Found ",
      oG.default.createElement(M, { bold: !0 }, A, " "),
      A === 0 || A > 1 ? B : B.slice(0, -1),
    ),
    W =
      Q !== void 0 && Z
        ? oG.default.createElement(
            oG.default.Fragment,
            null,
            " ",
            "across ",
            oG.default.createElement(M, { bold: !0 }, Q, " "),
            Q === 0 || Q > 1 ? Z : Z.slice(0, -1),
          )
        : null;
  if (Y)
    return oG.default.createElement(
      y,
      { flexDirection: "column" },
      oG.default.createElement(y, { flexDirection: "row" }, oG.default.createElement(M, null, "  ⎿  ", I, W)),
      oG.default.createElement(y, { marginLeft: 5 }, oG.default.createElement(M, null, G)),
    );
  return oG.default.createElement(
    NA,
    { height: 1 },
    oG.default.createElement(M, null, I, W, " ", A > 0 && oG.default.createElement(n11, null)),
  );
}
function REB(
  { pattern: A, path: B, glob: Q, type: Z, output_mode: G = "files_with_matches", head_limit: Y },
  { verbose: I },
) {
  if (!A) return null;
  let W = [`pattern: "${A}"`];
  if (B) W.push(`path: "${I ? B : IJ(B)}"`);
  if (Q) W.push(`glob: "${Q}"`);
  if (Z) W.push(`type: "${Z}"`);
  if (G !== "files_with_matches") W.push(`output_mode: "${G}"`);
  if (Y !== void 0) W.push(`head_limit: ${Y}`);
  return W.join(", ");
}
function TEB() {
  return oG.default.createElement(o8, null);
}
function PEB(A, { verbose: B }) {
  if (!B && typeof A === "string" && tQ(A, "tool_use_error"))
    return oG.default.createElement(NA, null, oG.default.createElement(M, { color: "error" }, "Error searching files"));
  return oG.default.createElement(K5, { result: A, verbose: B });
}
function jEB() {
  return null;
}
function SEB(
  { mode: A = "files_with_matches", filenames: B, numFiles: Q, content: Z, numLines: G, numMatches: Y },
  I,
  { verbose: W },
) {
  if (A === "content")
    return oG.default.createElement(bO0, { count: G ?? 0, countLabel: "lines", content: Z, verbose: W });
  if (A === "count")
    return oG.default.createElement(bO0, {
      count: Y ?? 0,
      countLabel: "matches",
      secondaryCount: Q,
      secondaryLabel: "files",
      content: Z,
      verbose: W,
    });
  let J = B.map((X) => X).join(`
`);
  return oG.default.createElement(bO0, { count: Q, countLabel: "files", content: J, verbose: W });
}
var $W5 = f.strictObject({
    pattern: f.string().describe("The regular expression pattern to search for in file contents"),
    path: f
      .string()
      .optional()
      .describe("File or directory to search in (rg PATH). Defaults to current working directory."),
    glob: f
      .string()
      .optional()
      .describe('Glob pattern to filter files (e.g. "*.js", "*.{ts,tsx}") - maps to rg --glob'),
    output_mode: f
      .enum(["content", "files_with_matches", "count"])
      .optional()
      .describe(
        'Output mode: "content" shows matching lines (supports -A/-B/-C context, -n line numbers, head_limit), "files_with_matches" shows file paths (supports head_limit), "count" shows match counts (supports head_limit). Defaults to "files_with_matches".',
      ),
    "-B": f
      .number()
      .optional()
      .describe(
        'Number of lines to show before each match (rg -B). Requires output_mode: "content", ignored otherwise.',
      ),
    "-A": f
      .number()
      .optional()
      .describe(
        'Number of lines to show after each match (rg -A). Requires output_mode: "content", ignored otherwise.',
      ),
    "-C": f
      .number()
      .optional()
      .describe(
        'Number of lines to show before and after each match (rg -C). Requires output_mode: "content", ignored otherwise.',
      ),
    "-n": f
      .boolean()
      .optional()
      .describe('Show line numbers in output (rg -n). Requires output_mode: "content", ignored otherwise.'),
    "-i": f.boolean().optional().describe("Case insensitive search (rg -i)"),
    type: f
      .string()
      .optional()
      .describe(
        "File type to search (rg --type). Common types: js, py, rust, go, java, etc. More efficient than include for standard file types.",
      ),
    head_limit: f
      .number()
      .optional()
      .describe(
        'Limit output to first N lines/entries, equivalent to "| head -N". Works across all output modes: content (limits output lines), files_with_matches (limits file paths), count (limits count entries). When unspecified, shows all results from ripgrep.',
      ),
    multiline: f
      .boolean()
      .optional()
      .describe(
        "Enable multiline mode where . matches newlines and patterns can span lines (rg -U --multiline-dotall). Default: false.",
      ),
  }),
  fO0 = 20000;
function hO0(A) {
  if (A.length <= fO0) return A;
  let B = A.slice(0, fO0),
    Z = A.slice(fO0).split(`
`).length;
  return `${B}

... [${Z} lines truncated] ...`;
}
function gO0(A, B) {
  return B !== void 0 ? A.slice(0, B) : A;
}
var RS = {
  name: GREP_TOOL_NAME,
  async description() {
    return getGrepToolDescription();
  },
  userFacingName() {
    return "Search";
  },
  isEnabled() {
    return !0;
  },
  inputSchema: $W5,
  isConcurrencySafe() {
    return !0;
  },
  isReadOnly() {
    return !0;
  },
  getPath({ path: A }) {
    return A || AA();
  },
  async validateInput({ path: A }) {
    if (A) {
      let B = w1(),
        Q = i9(A);
      if (!B.existsSync(Q)) return { result: !1, message: `Path does not exist: ${A}`, errorCode: 1 };
    }
    return { result: !0 };
  },
  async checkPermissions(A, B) {
    let Q = await B.getAppState();
    return a11(RS, A, Q.toolPermissionContext);
  },
  async prompt() {
    return getGrepToolDescription();
  },
  renderToolUseMessage: REB,
  renderToolUseRejectedMessage: TEB,
  renderToolUseErrorMessage: PEB,
  renderToolUseProgressMessage: jEB,
  renderToolResultMessage: SEB,
  mapToolResultToToolResultBlockParam(
    { mode: A = "files_with_matches", numFiles: B, filenames: Q, content: Z, numLines: G, numMatches: Y },
    I,
  ) {
    if (A === "content") {
      let X = hO0(Z || "No matches found");
      return { tool_use_id: I, type: "tool_result", content: X };
    }
    if (A === "count") {
      let F = hO0(Z || "No matches found"),
        V = Y ?? 0,
        K = B ?? 0,
        H = `

Found ${V} total ${V === 1 ? "occurrence" : "occurrences"} across ${K} ${K === 1 ? "file" : "files"}.`;
      return { tool_use_id: I, type: "tool_result", content: F + H };
    }
    if (B === 0) return { tool_use_id: I, type: "tool_result", content: "No files found" };
    let W = `Found ${B} file${B === 1 ? "" : "s"}
${Q.join(`
`)}`,
      J = hO0(W);
    return { tool_use_id: I, type: "tool_result", content: J };
  },
  async *call(
    {
      pattern: A,
      path: B,
      glob: Q,
      type: Z,
      output_mode: G = "files_with_matches",
      "-B": Y,
      "-A": I,
      "-C": W,
      "-n": J = !1,
      "-i": X = !1,
      head_limit: F,
      multiline: V = !1,
    },
    { abortController: K, getAppState: H },
  ) {
    let z = B ? i9(B) : AA(),
      D = ["--hidden"];
    if (V) D.push("-U", "--multiline-dotall");
    if (X) D.push("-i");
    if (G === "files_with_matches") D.push("-l");
    else if (G === "count") D.push("-c");
    if (J && G === "content") D.push("-n");
    if (W !== void 0 && G === "content") D.push("-C", W.toString());
    else if (G === "content") {
      if (Y !== void 0) D.push("-B", Y.toString());
      if (I !== void 0) D.push("-A", I.toString());
    }
    if (A.startsWith("-")) D.push("-e", A);
    else D.push(A);
    if (Z) D.push("--type", Z);
    if (Q) {
      let _ = [],
        b = Q.split(/\s+/);
      for (let S of b)
        if (S.includes("{") && S.includes("}")) _.push(S);
        else _.push(...S.split(",").filter(Boolean));
      for (let S of _.filter(Boolean)) D.push("--glob", S);
    }
    let C = await H(),
      w = zg1(Dg1(C.toolPermissionContext), AA());
    for (let _ of w) {
      let b = _.startsWith("/") ? `!${_}` : `!**/${_}`;
      D.push("--glob", b);
    }
    let E = await pk(D, z, K.signal);
    if (G === "content") {
      let _ = gO0(E, F);
      yield {
        type: "result",
        data: {
          mode: "content",
          numFiles: 0,
          filenames: [],
          content: _.join(`
`),
          numLines: _.length,
        },
      };
      return;
    }
    if (G === "count") {
      let _ = gO0(E, F),
        b = 0,
        S = 0;
      for (let u of _) {
        let o = u.lastIndexOf(":");
        if (o > 0) {
          let m = u.substring(o + 1),
            j = parseInt(m, 10);
          if (!isNaN(j)) ((b += j), (S += 1));
        }
      }
      yield {
        type: "result",
        data: {
          mode: "count",
          numFiles: S,
          filenames: [],
          content: _.join(`
`),
          numMatches: b,
        },
      };
      return;
    }
    let L = await Promise.all(E.map((_) => w1().stat(_))),
      O = E.map((_, b) => [_, L[b]])
        .sort((_, b) => {
          let S = (b[1].mtimeMs ?? 0) - (_[1].mtimeMs ?? 0);
          if (S === 0) return _[0].localeCompare(b[0]);
          return S;
        })
        .map((_) => _[0]),
      R = gO0(O, F);
    yield { type: "result", data: { mode: "files_with_matches", filenames: R, numFiles: R.length } };
  },
};
function yEB() {
  return "Search";
}
function kEB({ pattern: A, path: B }, { verbose: Q }) {
  if (!A) return null;
  if (!B) return `pattern: "${A}"`;
  return `pattern: "${A}", path: "${Q ? B : IJ(B)}"`;
}
function _EB() {
  return pW1.default.createElement(o8, null);
}
function xEB(A, { verbose: B }) {
  if (!B && typeof A === "string" && tQ(A, "tool_use_error"))
    return pW1.default.createElement(
      NA,
      null,
      pW1.default.createElement(M, { color: "error" }, "Error searching files"),
    );
  return pW1.default.createElement(K5, { result: A, verbose: B });
}
function vEB() {
  return null;
}
var bEB = RS.renderToolResultMessage;
var wW5 = f.strictObject({
    pattern: f.string().describe("The glob pattern to match files against"),
    path: f
      .string()
      .optional()
      .describe(
        'The directory to search in. If not specified, the current working directory will be used. IMPORTANT: Omit this field to use the default directory. DO NOT enter "undefined" or "null" - simply omit it for the default behavior. Must be a valid directory path if provided.',
      ),
  }),
  _23 = f.object({
    durationMs: f.number().describe("Time taken to execute the search in milliseconds"),
    numFiles: f.number().describe("Total number of files found"),
    filenames: f.array(f.string()).describe("Array of file paths that match the pattern"),
    truncated: f.boolean().describe("Whether results were truncated (limited to 100 files)"),
  }),
  yE = {
    name: GLOB_TOOL_NAME,
    async description() {
      return GLOB_TOOL_DESCRIPTION;
    },
    userFacingName: yEB,
    isEnabled() {
      return !0;
    },
    inputSchema: wW5,
    isConcurrencySafe() {
      return !0;
    },
    isReadOnly() {
      return !0;
    },
    getPath({ path: A }) {
      return A ? i9(A) : AA();
    },
    async validateInput({ path: A }) {
      if (A) {
        let B = w1(),
          Q = i9(A);
        if (!B.existsSync(Q)) return { result: !1, message: `Directory does not exist: ${A}`, errorCode: 1 };
        if (!B.statSync(Q).isDirectory()) return { result: !1, message: `Path is not a directory: ${A}`, errorCode: 2 };
      }
      return { result: !0 };
    },
    async checkPermissions(A, B) {
      let Q = await B.getAppState();
      return a11(yE, A, Q.toolPermissionContext);
    },
    async prompt() {
      return GLOB_TOOL_DESCRIPTION;
    },
    renderToolUseMessage: kEB,
    renderToolUseRejectedMessage: _EB,
    renderToolUseErrorMessage: xEB,
    renderToolUseProgressMessage: vEB,
    renderToolResultMessage: bEB,
    async *call(A, { abortController: B, getAppState: Q }) {
      let Z = Date.now(),
        G = await Q(),
        { files: Y, truncated: I } = await fEB(
          A.pattern,
          yE.getPath(A),
          { limit: 100, offset: 0 },
          B.signal,
          G.toolPermissionContext,
        );
      yield { type: "result", data: { filenames: Y, durationMs: Date.now() - Z, numFiles: Y.length, truncated: I } };
    },
    mapToolResultToToolResultBlockParam(A, B) {
      if (A.filenames.length === 0) return { tool_use_id: B, type: "tool_result", content: "No files found" };
      return {
        tool_use_id: B,
        type: "tool_result",
        content: [
          ...A.filenames,
          ...(A.truncated ? ["(Results are truncated. Consider using a more specific path or pattern.)"] : []),
        ].join(`
`),
      };
    },
  };
async function hEB(A) {
  return `Launch a new agent to handle complex, multi-step tasks autonomously. 

Available agent types and the tools they have access to:
${(await QS()).map((Z) => `- ${Z.agentType}: ${Z.whenToUse} (Tools: ${Z.tools.join(", ")})`).join(`
`)}

When using the Task tool, you must specify a subagent_type parameter to select which agent type to use.

When NOT to use the Agent tool:
- If you want to read a specific file path, use the ${Q6.name} or ${yE.name} tool instead of the Agent tool, to find the match more quickly
- If you are searching for a specific class definition like "class Foo", use the ${yE.name} tool instead, to find the match more quickly
- If you are searching for code within a specific file or set of 2-3 files, use the ${Q6.name} tool instead of the Agent tool, to find the match more quickly
- Other tasks that are not related to the agent descriptions above


Usage notes:
1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple tool uses
2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.
3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.
4. The agent's outputs should generally be trusted
5. Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent
6. If the agent description mentions that it should be used proactively, then you should try your best to use it without the user having to ask for it first. Use your judgement.
7. If the user specifies that they want you to run agents "in parallel", you MUST send a single message with multiple ${Q21.name} tool use content blocks. For example, if you need to launch both a code-reviewer agent and a test-runner agent in parallel, send a single message with both tool calls.

Example usage:

<example_agent_descriptions>
"code-reviewer": use this agent after you are done writing a signficant piece of code
"greeting-responder": use this agent when to respond to user greetings with a friendly joke
</example_agent_description>

<example>
user: "Please write a function that checks if a number is prime"
assistant: Sure let me write a function that checks if a number is prime
assistant: First let me use the ${mF.name} tool to write a function that checks if a number is prime
assistant: I'm going to use the ${mF.name} tool to write the following code:
<code>
function isPrime(n) {
  if (n <= 1) return false
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) return false
  }
  return true
}
</code>
<commentary>
Since a signficant piece of code was written and the task was completed, now use the code-reviewer agent to review the code
</commentary>
assistant: Now let me use the code-reviewer agent to review the code
assistant: Uses the ${Q21.name} tool to launch the with the code-reviewer agent 
</example>

<example>
user: "Hello"
<commentary>
Since the user is greeting, use the greeting-responder agent to respond with a friendly joke
</commentary>
assistant: "I'm going to use the ${Q21.name} tool to launch the with the greeting-responder agent"
</example>
`;
}
import { randomUUID as MW5 } from "crypto";
import { extname as EW5, isAbsolute as nEB, resolve as aEB } from "path";
var NOTEBOOK_EDIT_DESCRIPTION = "Replace the contents of a specific cell in a Jupyter notebook.",
  uEB =
    "Completely replaces the contents of a specific cell in a Jupyter notebook (.ipynb file) with new source. Jupyter notebooks are interactive documents that combine code, text, and visualizations, commonly used for data analysis and scientific computing. The notebook_path parameter must be an absolute path, not a relative path. The cell_number is 0-indexed. Use edit_mode=insert to add a new cell at the index specified by cell_number. Use edit_mode=delete to delete the cell at the index specified by cell_number.";
var BZ = A1(V1(), 1);
var UW = A1(V1(), 1);
import { relative as qW5 } from "path";
function mEB({ notebook_path: A, cell_id: B, new_source: Q, cell_type: Z, edit_mode: G = "replace", verbose: Y }) {
  let I = G === "delete" ? "delete" : `${G} cell in`;
  return UW.createElement(
    NA,
    null,
    UW.createElement(
      y,
      { flexDirection: "column" },
      UW.createElement(
        y,
        { flexDirection: "row" },
        UW.createElement(M, { color: "error" }, "User rejected ", I, " "),
        UW.createElement(M, { bold: !0, color: "error" }, Y ? A : qW5(AA(), A)),
        UW.createElement(M, { color: "error" }, " at cell ", B),
      ),
      G !== "delete" &&
        UW.createElement(
          y,
          { marginTop: 1, flexDirection: "column" },
          UW.createElement(
            M,
            { dimColor: !0 },
            UW.createElement(M$, { code: Q, language: Z === "markdown" ? "markdown" : "python" }),
          ),
        ),
    ),
  );
}
function dEB({ notebook_path: A, cell_id: B, new_source: Q, cell_type: Z, edit_mode: G }, { verbose: Y }) {
  if (!A || !Q || !Z) return null;
  if (Y) return `${A}@${B}, content: ${Q.slice(0, 30)}…, cell_type: ${Z}, edit_mode: ${G ?? "replace"}`;
  return `${IJ(A)}@${B}`;
}
function cEB(A, { verbose: B }) {
  return BZ.createElement(mEB, {
    notebook_path: A.notebook_path,
    cell_id: A.cell_id,
    new_source: A.new_source,
    cell_type: A.cell_type,
    edit_mode: A.edit_mode,
    verbose: B,
  });
}
function lEB(A, { verbose: B }) {
  if (!B && typeof A === "string" && tQ(A, "tool_use_error"))
    return BZ.createElement(NA, null, BZ.createElement(M, { color: "error" }, "Error editing notebook"));
  return BZ.createElement(K5, { result: A, verbose: B });
}
function pEB() {
  return null;
}
function iEB({ cell_id: A, new_source: B, language: Q, error: Z }) {
  if (Z) return BZ.createElement(NA, null, BZ.createElement(M, { color: "error" }, Z));
  return BZ.createElement(
    NA,
    null,
    BZ.createElement(
      y,
      { flexDirection: "column" },
      BZ.createElement(M, null, "Updated cell ", BZ.createElement(M, { bold: !0 }, A), ":"),
      BZ.createElement(y, { marginLeft: 2 }, BZ.createElement(M$, { code: B, language: Q })),
    ),
  );
}
var NW5 = f.strictObject({
    notebook_path: f
      .string()
      .describe("The absolute path to the Jupyter notebook file to edit (must be absolute, not relative)"),
    cell_id: f
      .string()
      .optional()
      .describe(
        "The ID of the cell to edit. When inserting a new cell, the new cell will be inserted after the cell with this ID, or at the beginning if not specified.",
      ),
    new_source: f.string().describe("The new source for the cell"),
    cell_type: f
      .enum(["code", "markdown"])
      .optional()
      .describe(
        "The type of the cell (code or markdown). If not specified, it defaults to the current cell type. If using edit_mode=insert, this is required.",
      ),
    edit_mode: f
      .enum(["replace", "insert", "delete"])
      .optional()
      .describe("The type of edit to make (replace, insert, delete). Defaults to replace."),
  }),
  UB3 = f.object({
    new_source: f.string().describe("The new source code that was written to the cell"),
    cell_id: f.string().optional().describe("The ID of the cell that was edited"),
    cell_type: f.enum(["code", "markdown"]).describe("The type of the cell"),
    language: f.string().describe("The programming language of the notebook"),
    edit_mode: f.string().describe("The edit mode that was used"),
    error: f.string().optional().describe("Error message if the operation failed"),
  }),
  mO = {
    name: NOTEBOOK_EDIT_TOOL_NAME,
    async description() {
      return NOTEBOOK_EDIT_DESCRIPTION;
    },
    async prompt() {
      return uEB;
    },
    userFacingName() {
      return "Edit Notebook";
    },
    isEnabled() {
      return !0;
    },
    inputSchema: NW5,
    isConcurrencySafe() {
      return !1;
    },
    isReadOnly() {
      return !1;
    },
    getPath(A) {
      return A.notebook_path;
    },
    async checkPermissions(A, B) {
      let Q = await B.getAppState();
      return ud(mO, A, Q.toolPermissionContext);
    },
    mapToolResultToToolResultBlockParam({ cell_id: A, edit_mode: B, new_source: Q, error: Z }, G) {
      if (Z) return { tool_use_id: G, type: "tool_result", content: Z, is_error: !0 };
      switch (B) {
        case "replace":
          return { tool_use_id: G, type: "tool_result", content: `Updated cell ${A} with ${Q}` };
        case "insert":
          return { tool_use_id: G, type: "tool_result", content: `Inserted cell ${A} with ${Q}` };
        case "delete":
          return { tool_use_id: G, type: "tool_result", content: `Deleted cell ${A}` };
        default:
          return { tool_use_id: G, type: "tool_result", content: "Unknown edit mode" };
      }
    },
    renderToolUseMessage: dEB,
    renderToolUseRejectedMessage: cEB,
    renderToolUseErrorMessage: lEB,
    renderToolUseProgressMessage: pEB,
    renderToolResultMessage: iEB,
    async validateInput({ notebook_path: A, cell_type: B, cell_id: Q, edit_mode: Z = "replace" }) {
      let G = nEB(A) ? A : aEB(AA(), A),
        Y = w1();
      if (!Y.existsSync(G)) return { result: !1, message: "Notebook file does not exist.", errorCode: 1 };
      if (EW5(G) !== ".ipynb")
        return {
          result: !1,
          message:
            "File must be a Jupyter notebook (.ipynb file). For editing other file types, use the FileEdit tool.",
          errorCode: 2,
        };
      if (Z !== "replace" && Z !== "insert" && Z !== "delete")
        return { result: !1, message: "Edit mode must be replace, insert, or delete.", errorCode: 4 };
      if (Z === "insert" && !B)
        return { result: !1, message: "Cell type is required when using edit_mode=insert.", errorCode: 5 };
      let I = mW(G),
        W = Y.readFileSync(G, { encoding: I }),
        J = d3(W);
      if (!J) return { result: !1, message: "Notebook is not valid JSON.", errorCode: 6 };
      if (!Q) {
        if (Z !== "insert")
          return { result: !1, message: "Cell ID must be specified when not inserting a new cell.", errorCode: 7 };
      } else {
        let X = lG1(Q);
        if (X !== void 0) {
          if (!J.cells[X])
            return { result: !1, message: `Cell with index ${X} does not exist in notebook.`, errorCode: 7 };
        } else if (!J.cells.find((F) => F.id === Q))
          return { result: !1, message: `Cell with ID "${Q}" not found in notebook.`, errorCode: 8 };
      }
      return { result: !0 };
    },
    async *call(
      { notebook_path: A, new_source: B, cell_id: Q, cell_type: Z, edit_mode: G },
      { updateFileHistoryState: Y },
    ) {
      let I = nEB(A) ? A : aEB(AA(), A);
      try {
        let W = mW(I),
          J = w1().readFileSync(I, { encoding: W }),
          X = JSON.parse(J),
          F;
        if (!Q) F = 0;
        else {
          let C = lG1(Q);
          if (C !== void 0) {
            if (((F = C), G === "insert")) F += 1;
          } else if (((F = X.cells.findIndex((w) => w.id === Q)), G === "insert")) F += 1;
        }
        let V = G;
        if (V === "replace" && F === X.cells.length) {
          if (((V = "insert"), !Z)) Z = "code";
        }
        let K = X.metadata.language_info?.name ?? "python",
          H = void 0;
        if (X.nbformat > 4 || (X.nbformat === 4 && X.nbformat_minor >= 5)) {
          if (V === "insert") H = Math.random().toString(36).substring(2, 15);
          else if (Q !== null) H = Q;
        }
        if (V === "delete") X.cells.splice(F, 1);
        else if (V === "insert") {
          let C;
          if (Z === "markdown") C = { cell_type: "markdown", id: H, source: B, metadata: {} };
          else C = { cell_type: "code", id: H, source: B, metadata: {}, execution_count: null, outputs: [] };
          X.cells.splice(F, 0, C);
        } else {
          let C = X.cells[F];
          if (((C.source = B), C.cell_type === "code")) ((C.execution_count = null), (C.outputs = []));
          if (Z && Z !== C.cell_type) C.cell_type = Z;
        }
        let z = rj(I);
        (Yb(I, JSON.stringify(X, null, 1), W, z),
          yield {
            type: "result",
            data: {
              new_source: B,
              cell_type: Z ?? "code",
              language: K,
              edit_mode: V ?? "replace",
              cell_id: H || void 0,
              error: "",
            },
          });
      } catch (W) {
        if (W instanceof Error) {
          yield {
            type: "result",
            data: {
              new_source: B,
              cell_type: Z ?? "code",
              language: "python",
              edit_mode: "replace",
              error: W.message,
              cell_id: Q,
            },
          };
          return;
        }
        yield {
          type: "result",
          data: {
            new_source: B,
            cell_type: Z ?? "code",
            language: "python",
            edit_mode: "replace",
            error: "Unknown error occurred while editing notebook",
            cell_id: Q,
          },
        };
      }
    },
  };
class Cg1 {
  hideTimeoutId = null;
  getName() {
    return "ConEmu";
  }
  isAvailable() {
    if (!process.stdout.isTTY) return !1;
    if (process.env.ConEmuANSI || process.env.ConEmuPID || process.env.ConEmuTask) return !0;
    if (process.env.TERM_PROGRAM === "Ghostty" || process.env.TERM === "xterm-ghostty") return !0;
    return !1;
  }
  report(A) {
    if (!this.isAvailable()) return;
    if (this.hideTimeoutId) (clearTimeout(this.hideTimeoutId), (this.hideTimeoutId = null));
    let B = this.mapProgressState(A.state),
      Q = A.percentage ?? (A.state === "indeterminate" ? 0 : 0),
      Z = Math.max(0, Math.min(100, Math.round(Q))),
      G = `\x1B]9;4;${B};${Z}\x1B\\`;
    if ((this.writeSequence(G), A.state === "completed" || A.state === "error"))
      this.hideTimeoutId = setTimeout(() => {
        this.hide();
      }, 500);
  }
  mapProgressState(A) {
    switch (A) {
      case "error":
        return 2;
      case "indeterminate":
        return 3;
      case "started":
      case "running":
      case "completed":
      default:
        return 1;
    }
  }
  hide() {
    if (!this.isAvailable()) return;
    let A = "\x1B]9;4;0;0\x1B\\";
    this.writeSequence(A);
  }
  writeSequence(A) {
    let B = cT.get(process.stdout);
    if (B && B.writeToStdout) B.writeToStdout(A);
    else process.stdout.write(A);
  }
}
class dc {
  reporters = [];
  static instance = null;
  delayedReports = new Map();
  PROGRESS_DELAY_MS = 250;
  constructor() {
    this.registerReporter(new Cg1());
  }
  static getInstance() {
    if (!dc.instance) dc.instance = new dc();
    return dc.instance;
  }
  registerReporter(A) {
    this.reporters.push(A);
  }
  report(A) {
    for (let B of this.reporters)
      if (B.isAvailable())
        try {
          B.report(A);
        } catch {}
  }
  reportStart(A, B) {
    this.report({ state: "started", percentage: 0, toolName: A, toolUseId: B });
  }
  reportProgress(A, B, Q) {
    this.report({ state: "running", percentage: A, toolName: B, toolUseId: Q });
  }
  reportComplete(A, B) {
    this.report({ state: "completed", percentage: 100, toolName: A, toolUseId: B });
  }
  reportError(A, B, Q) {
    this.report({ state: "error", percentage: 100, message: A, toolName: B, toolUseId: Q });
  }
  reportIndeterminate(A, B) {
    this.report({ state: "indeterminate", toolName: A, toolUseId: B });
  }
  reportToolStart(A, B) {
    let Q = `${A}-${B || "default"}`,
      Z = setTimeout(() => {
        (this.reportIndeterminate(A, B), this.delayedReports.delete(Q));
      }, this.PROGRESS_DELAY_MS);
    this.delayedReports.set(Q, Z);
  }
  reportToolComplete(A, B) {
    let Q = `${A}-${B || "default"}`,
      Z = this.delayedReports.get(Q);
    if (Z) {
      (clearTimeout(Z), this.delayedReports.delete(Q));
      return;
    }
    this.reportComplete(A, B);
  }
  reportToolError(A, B, Q) {
    let Z = `${A}-${Q || "default"}`,
      G = this.delayedReports.get(Z);
    if (G) (clearTimeout(G), this.delayedReports.delete(Z));
    this.reportError(B, A, Q);
  }
  getAvailableReporters() {
    return this.reporters.filter((A) => A.isAvailable()).map((A) => A.getName());
  }
}
var iW1 = dc.getInstance();
function sEB(A) {
  let B = i91() !== void 0 && i91() !== null;
  if (!(_n() && !B)) return null;
  let Z = Px();
  if (Z === A) return null;
  return Z;
}
var LW5 = [];
async function rEB(A, B, Q, Z, G, Y) {
  let I = { messages: A, systemPrompt: B, userContext: Q, systemContext: Z, toolUseContext: G, querySource: Y };
  for (let W of LW5)
    try {
      await W(I);
    } catch (J) {
      U1(J instanceof Error ? J : new Error(`Post-sampling hook failed: ${J}`), _GA);
    }
}
var OW5 = 10;
function* Ug1(A, B) {
  for (let Q of A) {
    let Z = Q.message.content.filter((G) => G.type === "tool_use");
    for (let G of Z)
      yield bA({ content: [{ type: "tool_result", content: B, is_error: !0, tool_use_id: G.id }], toolUseResult: B });
  }
}
async function* dO({
  messages: A,
  systemPrompt: B,
  userContext: Q,
  systemContext: Z,
  canUseTool: G,
  toolUseContext: Y,
  autoCompactTracking: I,
  fallbackModel: W,
  stopHookActive: J,
  promptCategory: X,
  querySource: F,
}) {
  yield { type: "stream_request_start" };
  let V = wb(A),
    K = I,
    H = await Lb(V, void 0, Y);
  if (((V = H.messages), H.compactionInfo?.systemMessage)) yield H.compactionInfo.systemMessage;
  let { compactionResult: z } = await MXB(V, Y, F);
  if (z) {
    let { preCompactTokenCount: m, postCompactTokenCount: j } = z;
    if (
      (Y1("tengu_auto_compact_succeeded", {
        originalMessageCount: A.length,
        compactedMessageCount: z.summaryMessages.length + z.attachments.length + z.hookResults.length,
        preCompactTokenCount: m,
        postCompactTokenCount: j,
      }),
      !K?.compacted)
    )
      K = { compacted: !0, turnId: MW5(), turnCounter: 0 };
    let r = [z.boundaryMarker, ...z.summaryMessages, ...z.attachments, ...z.hookResults];
    for (let Q1 of r) yield Q1;
    V = r;
  }
  let D = [],
    w = (await Y.getAppState()).toolPermissionContext.mode,
    E = Xt({ permissionMode: w, mainLoopModel: Y.options.mainLoopModel, exceeds200kTokens: w === "plan" && Qb1(V) }),
    L = !0;
  try {
    while (L) {
      L = !1;
      try {
        let m = !1;
        for await (let j of b01(
          AI1(V, Q),
          _q0(B, Z),
          Y.options.maxThinkingTokens,
          Y.options.tools,
          Y.abortController.signal,
          {
            async getToolPermissionContext() {
              return (await Y.getAppState()).toolPermissionContext;
            },
            model: E,
            prependCLISysprompt: !0,
            toolChoice: void 0,
            isNonInteractiveSession: Y.options.isNonInteractiveSession,
            fallbackModel: W,
            onStreamingFallback: () => {
              m = !0;
            },
            promptCategory: X,
            querySource: F,
          },
        )) {
          if (m) (yield* Ug1(D, "Streaming fallback triggered"), (D.length = 0));
          if ((yield j, j.type === "assistant")) D.push(j);
        }
      } catch (m) {
        if (m instanceof Vb1 && W) {
          ((E = W),
            (L = !0),
            yield* Ug1(D, "Model fallback triggered"),
            (D.length = 0),
            (Y.options.mainLoopModel = W),
            Y1("tengu_model_fallback_triggered", {
              original_model: m.originalModel,
              fallback_model: W,
              entrypoint: "cli",
            }),
            yield X3(`Model fallback triggered: switching from ${m.originalModel} to ${m.fallbackModel}`, "info"));
          continue;
        }
        throw m;
      }
    }
  } catch (m) {
    U1(m instanceof Error ? m : new Error(String(m)), bGA);
    let j = m instanceof Error ? m.message : String(m);
    (Y1("tengu_query_error", {
      assistantMessages: D.length,
      toolUses: D.flatMap((r) => r.message.content.filter((Q1) => Q1.type === "tool_use")).length,
    }),
      yield* Ug1(D, j),
      yield FI1({ toolUse: !1 }),
      mk("Query error", m));
    return;
  }
  if (D.length > 0) rEB([...V, ...D], B, Q, Z, Y, F);
  if (Y.abortController.signal.aborted) {
    (yield* Ug1(D, "Interrupted by user"), yield FI1({ toolUse: !1 }));
    return;
  }
  let O = D.flatMap((m) => m.message.content.filter((j) => j.type === "tool_use"));
  if (!D.length || !O.length) {
    (yield* TW5(V, D, B, Q, Z, G, Y, K, W, J, X, F), yield* RW5(V, D, B, Q, Z, G, Y, K, W, X));
    return;
  }
  let R = [],
    P = !1,
    _ = Y;
  for await (let m of PW5(O, D, G, Y)) {
    _ = m.newContext;
    let j = m.message;
    if (!j) continue;
    if ((yield j, j && j.type === "system" && j.subtype === "informational" && j.preventContinuation)) P = !0;
    R.push(...dG([j]).filter((r) => r.type === "user"));
  }
  if (Y.abortController.signal.aborted) {
    let m = Y.abortController.signal.reason === "tool-rejection";
    yield FI1({ toolUse: !0 });
    return;
  }
  if (P) return;
  if (K?.compacted)
    (K.turnCounter++, Y1("tengu_post_autocompact_turn", { turnId: K.turnId, turnCounter: K.turnCounter }));
  let b = [..._.messageQueueManager.get()],
    S = [];
  for await (let m of p01(null, _, null, b, A, F)) if ((yield m, R.push(m), _b1(m))) S.push(m);
  _.messageQueueManager.remove(b);
  let d = sEB(_.options.mainLoopModel),
    u = _;
  if (d)
    ((u = { ..._, options: { ..._.options, mainLoopModel: d } }),
      Y1("tengu_fallback_system_msg", { mainLoopModel: _.options.mainLoopModel, fallbackModel: d }),
      yield X3(`Claude Opus limit reached, now using ${uP(d)}`, "warning"));
  let o = { ...u, pendingSteeringAttachments: S.length > 0 ? S : void 0 };
  yield* dO({
    messages: [...V, ...D, ...R],
    systemPrompt: B,
    userContext: Q,
    systemContext: Z,
    canUseTool: G,
    toolUseContext: o,
    autoCompactTracking: K,
    fallbackModel: W,
    stopHookActive: J,
    promptCategory: X,
    querySource: F,
  });
}
async function* RW5(A, B, Q, Z, G, Y, I, W, J, X) {
  if (I.pendingSteeringAttachments && I.pendingSteeringAttachments.length > 0) {
    let F = [];
    for (let V of I.pendingSteeringAttachments) {
      let K = V.attachment;
      if (K.type === "queued_command") {
        let H = bA({ content: K.prompt, isMeta: !0 });
        F.push(H);
      }
    }
    if (F.length > 0) {
      let V = { ...I, pendingSteeringAttachments: void 0 };
      (Y1("tengu_steering_attachment_resending", {}),
        yield* dO({
          messages: [...A, ...B, ...F],
          systemPrompt: Q,
          userContext: Z,
          systemContext: G,
          canUseTool: Y,
          toolUseContext: V,
          autoCompactTracking: W,
          fallbackModel: J,
          promptCategory: X,
        }));
    }
    return;
  }
}
async function* TW5(A, B, Q, Z, G, Y, I, W, J, X, F, V) {
  let K = [],
    H = !1,
    z,
    D = Date.now();
  try {
    let w = (await I.getAppState()).toolPermissionContext.mode,
      E = BMA(w, I.abortController.signal, void 0, X ?? !1, I.agentId !== U2());
    for await (let L of E) {
      if (L.message) yield L.message;
      if (L.blockingErrors) K = L.blockingErrors;
      if (L.preventContinuation) {
        if (((H = !0), L.stopReason)) z = L.stopReason;
      }
    }
    if (I.abortController.signal.aborted) {
      (Y1("tengu_pre_stop_hooks_cancelled", {}), yield FI1({ toolUse: !1 }));
      return;
    }
    if (H) {
      yield X3(z || "Stop hook prevented continuation", "warning", void 0, !0);
      return;
    }
    if (K.length > 0) {
      let L = bA({ content: rLA(K) });
      (yield L,
        yield* dO({
          messages: [...A, ...B, L],
          systemPrompt: Q,
          userContext: Z,
          systemContext: G,
          canUseTool: Y,
          toolUseContext: I,
          autoCompactTracking: W,
          fallbackModel: J,
          stopHookActive: !0,
          promptCategory: F,
          querySource: V,
        }));
      return;
    }
  } catch (C) {
    let w = Date.now() - D;
    (Y1("tengu_stop_hook_error", { duration: w }),
      yield X3(`Stop hook failed: ${C instanceof Error ? C.message : String(C)}`, "warning"));
  }
}
async function* PW5(A, B, Q, Z) {
  let G = Z;
  for (let { isConcurrencySafe: Y, blocks: I } of jW5(A, G))
    if (Y) {
      let W = {};
      for await (let J of yW5(I, B, Q, G)) {
        if (J.contextModifier) {
          let { toolUseID: X, modifyContext: F } = J.contextModifier;
          if (!W[X]) W[X] = [];
          W[X].push(F);
        }
        yield { message: J.message, newContext: G };
      }
      for (let J of I) {
        let X = W[J.id];
        if (!X) continue;
        for (let F of X) G = F(G);
      }
      yield { newContext: G };
    } else
      for await (let W of SW5(I, B, Q, G)) {
        if (W.newContext) G = W.newContext;
        yield { message: W.message, newContext: G };
      }
}
function jW5(A, B) {
  return A.reduce((Q, Z) => {
    let G = B.options.tools.find((W) => W.name === Z.name),
      Y = G?.inputSchema.safeParse(Z.input),
      I = Y?.success ? Boolean(G?.isConcurrencySafe(Y.data)) : !1;
    if (I && Q[Q.length - 1]?.isConcurrencySafe) Q[Q.length - 1].blocks.push(Z);
    else Q.push({ isConcurrencySafe: I, blocks: [Z] });
    return Q;
  }, []);
}
async function* SW5(A, B, Q, Z) {
  let G = Z;
  for (let Y of A)
    for await (let I of tEB(
      Y,
      B.find((W) => W.message.content.some((J) => J.type === "tool_use" && J.id === Y.id)),
      Q,
      G,
    )) {
      if (I.contextModifier) G = I.contextModifier.modifyContext(G);
      yield { message: I.message, newContext: G };
    }
}
async function* yW5(A, B, Q, Z) {
  let G = S9B(
    A.map((Y) =>
      tEB(
        Y,
        B.find((I) => I.message.content.some((W) => W.type === "tool_use" && W.id === Y.id)),
        Q,
        Z,
      ),
    ),
    OW5,
  );
  yield* mJB(G);
}
function $g1(A, B) {
  A.setInProgressToolUseIDs((Q) => new Set([...Q].filter((Z) => Z !== B)));
}
async function* tEB(A, B, Q, Z) {
  let G = A.name,
    Y = Z.options.tools.find((W) => W.name === G);
  if ((Z.setInProgressToolUseIDs((W) => new Set([...W, A.id])), !Y)) {
    (Y1("tengu_tool_use_error", { error: `No such tool available: ${G}`, toolName: G, toolUseID: A.id, isMcp: !1 }),
      yield {
        message: bA({
          content: [
            {
              type: "tool_result",
              content: `<tool_use_error>Error: No such tool available: ${G}</tool_use_error>`,
              is_error: !0,
              tool_use_id: A.id,
            },
          ],
          toolUseResult: `Error: No such tool available: ${G}`,
        }),
      },
      $g1(Z, A.id));
    return;
  }
  let I = A.input;
  try {
    if (Z.abortController.signal.aborted) {
      Y1("tengu_tool_use_cancelled", { toolName: Y.name, toolUseID: A.id, isMcp: Y.isMcp ?? !1 });
      let W = qb1(A.id);
      (yield { message: bA({ content: [W], toolUseResult: Ub }) }, $g1(Z, A.id));
      return;
    }
    for await (let W of kW5(Y, A.id, I, Z, Q, B)) yield W;
  } catch (W) {
    U1(W instanceof Error ? W : new Error(String(W)), hGA);
    let J = W instanceof Error ? W.message : String(W),
      F = `Error calling tool${Y ? ` (${Y.name})` : ""}: ${J}`;
    yield {
      message: bA({
        content: [
          { type: "tool_result", content: `<tool_use_error>${F}</tool_use_error>`, is_error: !0, tool_use_id: A.id },
        ],
        toolUseResult: F,
      }),
    };
  }
  $g1(Z, A.id);
}
async function* kW5(A, B, Q, Z, G, Y) {
  let I = A.inputSchema.safeParse(Q);
  if (!I.success) {
    let O = xW5(A.name, I.error);
    (Y1("tengu_tool_use_error", {
      error: "InputValidationError",
      errorDetails: O.slice(0, 2000),
      messageID: Y.message.id,
      toolName: A.name,
    }),
      yield {
        message: bA({
          content: [
            {
              type: "tool_result",
              content: `<tool_use_error>InputValidationError: ${O}</tool_use_error>`,
              is_error: !0,
              tool_use_id: B,
            },
          ],
          toolUseResult: `InputValidationError: ${I.error.message}`,
        }),
      });
    return;
  }
  let W = await A.validateInput?.(I.data, Z);
  if (W?.result === !1) {
    (Y1("tengu_tool_use_error", { messageID: Y.message.id, toolName: A.name, errorCode: W.errorCode }),
      yield {
        message: bA({
          content: [
            {
              type: "tool_result",
              content: `<tool_use_error>${W.message}</tool_use_error>`,
              is_error: !0,
              tool_use_id: B,
            },
          ],
          toolUseResult: `Error: ${W.message}`,
        }),
      });
    return;
  }
  let J = I.data,
    X = !1,
    F,
    V,
    K = Date.now();
  try {
    let R = (await Z.getAppState()).toolPermissionContext.mode,
      P = tLA(A.name, B, J, R, Z.abortController.signal),
      _ = [];
    for await (let b of P) {
      if (b.message) yield { message: b.message };
      if (b.blockingErrors) _ = b.blockingErrors;
      if (b.preventContinuation) {
        if (((X = !0), b.stopReason)) F = b.stopReason;
      }
      if (b.permissionBehavior !== void 0) {
        F1(`Hook result has permissionBehavior=${b.permissionBehavior}`);
        let S = { type: "hook", hookName: `PreToolUse:${A.name}`, reason: b.hookPermissionDecisionReason };
        if (b.permissionBehavior === "allow") V = { behavior: "allow", updatedInput: J, decisionReason: S };
        else
          V = {
            behavior: b.permissionBehavior,
            message: `Hook requested permission behavior: ${b.permissionBehavior}`,
            decisionReason: S,
          };
      }
    }
    if (Z.abortController.signal.aborted) {
      (Y1("tengu_pre_tool_hooks_cancelled", { toolName: A.name }),
        yield { message: bA({ content: [qb1(B)], toolUseResult: Ub }) });
      return;
    }
    if (_.length > 0) {
      let b = aLA(A.name, _);
      V = {
        behavior: "deny",
        message: b,
        decisionReason: { type: "hook", hookName: `PreToolUse:${A.name}`, reason: b },
      };
    }
  } catch (O) {
    let R = Date.now() - K;
    (Y1("tengu_pre_tool_hook_error", { messageID: Y.message.id, toolName: A.name, isMcp: A.isMcp ?? !1, duration: R }),
      yield { message: X3(`Pre-tool hook failed: ${uO0(O)}`, "warning", B) },
      yield { message: bA({ content: [qb1(B)], toolUseResult: Ub }) },
      $g1(Z, B));
    return;
  }
  let H;
  if (V !== void 0 && V.behavior === "allow")
    (F1(`Hook approved tool use for ${A.name}, bypassing permission check`), (H = V));
  else if (V !== void 0 && V.behavior === "deny") (F1(`Hook denied tool use for ${A.name}`), (H = V));
  else {
    let O = V?.behavior === "ask" ? V : void 0;
    H = await G(A, J, Z, Y, B, O);
  }
  if (H.behavior !== "allow") {
    Y1("tengu_tool_use_can_use_tool_rejected", { messageID: Y.message.id, toolName: A.name });
    let O = H.message;
    if (X) O = `Execution stopped by PreToolUse hook${F ? `: ${F}` : ""}`;
    yield {
      message: bA({
        content: [{ type: "tool_result", content: O, is_error: !0, tool_use_id: B }],
        toolUseResult: `Error: ${O}`,
      }),
    };
    return;
  }
  if (
    (Y1("tengu_tool_use_can_use_tool_allowed", { messageID: Y.message.id, toolName: A.name }),
    (J = H.updatedInput),
    A.name === "Bash" && J)
  ) {
    let O = J;
    if (O.command) {
      if ((F1(`Bash tool invoked with command: ${O.command}`), O.description))
        F1(`Bash tool description: ${O.description}`);
      if (O.timeout) F1(`Bash tool timeout: ${O.timeout}ms`);
      if (O.sandbox !== void 0) F1(`Bash tool sandbox mode: ${O.sandbox}`);
    }
  }
  let z = {};
  if (A.name === "Bash" && "command" in J) {
    let O = J;
    z = {
      bash_command: O.command.trim().split(/\s+/)[0] || "",
      full_command: O.command,
      ...(O.timeout !== void 0 && { timeout: O.timeout }),
      ...(O.description !== void 0 && { description: O.description }),
    };
  }
  let D = Date.now(),
    C = null,
    w = Z.toolDecisions?.get(B);
  iW1.reportToolStart(A.name, B);
  try {
    let O = A.call(J, { ...Z, userModified: H.userModified ?? !1 }, G, Y);
    for await (let R of O)
      switch (R.type) {
        case "result": {
          let P = Date.now() - D;
          if (
            (vo1(P),
            (C = R.data),
            iW1.reportToolComplete(A.name, B),
            Y1("tengu_tool_use_success", {
              messageID: Y.message.id,
              toolName: A.name,
              isMcp: A.isMcp ?? !1,
              durationMs: P,
            }),
            T$("tool_result", {
              tool_name: A.name,
              success: "true",
              duration_ms: String(P),
              ...(Object.keys(z).length > 0 && { tool_parameters: JSON.stringify(z) }),
              ...(w && { decision_source: w.source, decision_type: w.decision }),
            }),
            yield {
              message: bA({ content: [A.mapToolResultToToolResultBlockParam(R.data, B)], toolUseResult: R.data }),
              contextModifier: R.contextModifier ? { toolUseID: B, modifyContext: R.contextModifier } : void 0,
            },
            R.newMessages && R.newMessages.length > 0)
          )
            for (let _ of R.newMessages) yield { message: _ };
          if (X) yield { message: X3(F || "Execution stopped by hook", "warning", B, !0) };
          break;
        }
        case "progress":
          (Y1("tengu_tool_use_progress", { messageID: Y.message.id, toolName: A.name, isMcp: A.isMcp ?? !1 }),
            yield { message: kJB({ toolUseID: R.toolUseID, parentToolUseID: B, data: R.data }) });
          break;
      }
  } catch (O) {
    let R = Date.now() - D;
    if ((vo1(R), iW1.reportToolError(A.name, O instanceof Error ? O.message : String(O), B), !(O instanceof QH))) {
      if (!(O instanceof oN)) U1(O instanceof Error ? O : new Error(String(O)), fGA);
      (Y1("tengu_tool_use_error", { messageID: Y.message.id, toolName: A.name, isMcp: A.isMcp ?? !1 }),
        T$("tool_result", {
          tool_name: A.name,
          use_id: B,
          success: "false",
          duration_ms: String(R),
          error: O instanceof Error ? O.message : String(O),
          ...(Object.keys(z).length > 0 && { tool_parameters: JSON.stringify(z) }),
          ...(w && { decision_source: w.source, decision_type: w.decision }),
        }));
    }
    let P = uO0(O);
    yield {
      message: bA({
        content: [{ type: "tool_result", content: P, is_error: !0, tool_use_id: B }],
        toolUseResult: `Error: ${P}`,
      }),
    };
    return;
  } finally {
    if (w) Z.toolDecisions?.delete(B);
  }
  let E = Z.abortController.signal.aborted,
    L = Date.now();
  try {
    let R = (await Z.getAppState()).toolPermissionContext.mode,
      P = eLA(A.name, B, H.updatedInput, C, R, Z.abortController.signal),
      _ = [],
      b = !1,
      S,
      d = [],
      u = !1;
    for await (let o of P) {
      if (!E && Z.abortController.signal.aborted && !u) {
        ((u = !0), Y1("tengu_post_tool_hooks_cancelled", { toolName: A.name }), yield { message: HE0(A.name) });
        return;
      }
      if (o.message) yield { message: o.message };
      if (o.blockingErrors) _ = o.blockingErrors;
      if (o.preventContinuation) {
        if (((b = !0), o.stopReason)) S = o.stopReason;
      }
      if (o.additionalContexts && o.additionalContexts.length > 0) d.push(...o.additionalContexts);
    }
    if (!E && Z.abortController.signal.aborted && !u) {
      (Y1("tengu_post_tool_hooks_cancelled", { toolName: A.name }), yield { message: HE0(A.name) });
      return;
    }
    if (b) {
      yield { message: X3(S || "Execution stopped by PostToolUse hook", "warning", B, !0) };
      return;
    }
    if (_.length > 0) yield { message: hJB(A.name, sLA(A.name, _)) };
    if (d.length > 0)
      yield {
        message: bA({
          content: `<post-tool-use-hook>${d.join(`

`)}</post-tool-use-hook>`,
        }),
      };
  } catch (O) {
    let R = Date.now() - L;
    (Y1("tengu_post_tool_hook_error", { messageID: Y.message.id, toolName: A.name, isMcp: A.isMcp ?? !1, duration: R }),
      yield { message: X3(`PostToolUse hook failed: ${uO0(O)}`, "warning", B) });
  }
}
function uO0(A) {
  if (A instanceof QH) return A.message || P$;
  if (!(A instanceof Error)) return String(A);
  let Q =
    _W5(A)
      .filter(Boolean)
      .join(
        `
`,
      )
      .trim() || "Error";
  if (Q.length <= 1e4) return Q;
  let Z = 5000,
    G = Q.slice(0, Z),
    Y = Q.slice(-Z);
  return `${G}

... [${Q.length - 1e4} characters truncated] ...

${Y}`;
}
function _W5(A) {
  if (A instanceof oN) return [A.interrupted ? P$ : "", A.stderr, A.stdout];
  let B = [A.message];
  if ("stderr" in A && typeof A.stderr === "string") B.push(A.stderr);
  if ("stdout" in A && typeof A.stdout === "string") B.push(A.stdout);
  return B;
}
function oEB(A) {
  if (A.length === 0) return "";
  return A.reduce((B, Q, Z) => {
    if (typeof Q === "number") return `${B}[${Q}]`;
    return Z === 0 ? Q : `${B}.${Q}`;
  }, "");
}
function xW5(A, B) {
  let Q = B.errors
      .filter((W) => W.code === "invalid_type" && W.received === "undefined" && W.message === "Required")
      .map((W) => oEB(W.path)),
    Z = B.errors.filter((W) => W.code === "unrecognized_keys").flatMap((W) => W.keys),
    G = B.errors
      .filter(
        (W) => W.code === "invalid_type" && "received" in W && W.received !== "undefined" && W.message !== "Required",
      )
      .map((W) => {
        let J = W;
        return { param: oEB(W.path), expected: J.expected, received: J.received };
      }),
    Y = B.message,
    I = [];
  if (Q.length > 0) {
    let W = Q.map((J) => `The required parameter \`${J}\` is missing`);
    I.push(...W);
  }
  if (Z.length > 0) {
    let W = Z.map((J) => `An unexpected parameter \`${J}\` was provided`);
    I.push(...W);
  }
  if (G.length > 0) {
    let W = G.map(
      ({ param: J, expected: X, received: F }) =>
        `The parameter \`${J}\` type is expected as \`${X}\` but provided as \`${F}\``,
    );
    I.push(...W);
  }
  if (I.length > 0)
    Y = `${A} failed due to the following ${I.length > 1 ? "issues" : "issue"}:
${I.join(`
`)}`;
  return Y;
}
function TS() {
  let A = [],
    B = null;
  function Q() {
    if (B) B();
  }
  return {
    get() {
      return A;
    },
    setUpdateCallback(Z) {
      B = Z;
    },
    remove(Z) {
      ((A = A.filter((G) => !Z.includes(G))), Q());
    },
    enqueue(Z) {
      ((A = [...A, Z]), Q());
    },
    dequeue() {
      if (A.length === 0) return;
      let [Z, ...G] = A;
      return ((A = G), Q(), Z);
    },
    popAllForEditing(Z, G) {
      if (A.length === 0) return;
      let Y = A.map((J) => J.value),
        I = [...Y, Z].filter(Boolean).join(`
`),
        W =
          Y.join(`
`).length +
          1 +
          G;
      return ((A = []), Q(), { text: I, cursorOffset: W });
    },
    isEmpty() {
      return A.length === 0;
    },
  };
}
function Z21(A, B, Q = "userSettings") {
  let Z = B.filter((X) => {
    if (mO0.has(X.name)) return !1;
    if (Q !== "built-in" && dO0.has(X.name)) return !1;
    return !0;
  });
  if (A.includes("*")) return { hasWildcard: !0, validTools: [], invalidTools: [], resolvedTools: Z };
  let G = new Map();
  for (let X of Z) G.set(X.name, X);
  let Y = [],
    I = [],
    W = [],
    J = new Set();
  for (let X of A) {
    let { toolName: F } = xz(X);
    if (F === TASK_TOOL_NAME) {
      Y.push(X);
      continue;
    }
    let V = G.get(F);
    if (V) {
      if ((Y.push(X), !J.has(V))) (W.push(V), J.add(V));
    } else I.push(X);
  }
  return { hasWildcard: !1, validTools: Y, invalidTools: I, resolvedTools: W };
}
function eEB(A, B) {
  if (B) return A ? `agent:${A}` : "agent:default";
  else return "agent:custom";
}
function nW1() {
  let B = E2()?.outputStyle ?? iW;
  if (B === iW) return;
  return B in Uu ? `outputStyle:${B}` : "outputStyle:custom";
}
var Af = A1(V1(), 1);
function ANB({ onDone: A }) {
  return (
    s0((B, Q) => {
      if ((Q.ctrl && (B === "c" || B === "d")) || Q.escape) A();
    }),
    Af.default.createElement(
      y,
      { flexDirection: "column", borderStyle: "round", padding: 1, borderDimColor: !0 },
      Af.default.createElement(
        y,
        { marginBottom: 1, flexDirection: "column" },
        Af.default.createElement(M, { bold: !0 }, "You've spent $5 on the Anthropic API this session."),
        Af.default.createElement(M, null, "Learn more about how to monitor your spending:"),
        Af.default.createElement(H5, { url: "https://docs.anthropic.com/s/claude-code-cost" }),
      ),
      Af.default.createElement(
        y,
        null,
        Af.default.createElement(xA, {
          options: [{ value: "ok", label: "Got it, thanks!" }],
          onChange: A,
          onCancel: A,
        }),
      ),
    )
  );
}
var D9 = A1(V1(), 1),
  S2 = A1(V1(), 1);
var aW1 = A1(V1(), 1);
function BNB() {
  let [A, B] = aW1.useState(0),
    [Q, Z] = aW1.useState({ show: !1 }),
    G = aW1.useCallback((Y, I = {}) => {
      let { timeoutMs: W = 8000 } = I;
      B((J) => {
        let X = J + 1;
        return (
          Z({ show: !0, content: Y }),
          setTimeout(() => {
            B((F) => {
              if (X === F) Z({ show: !1 });
              return F;
            });
          }, W),
          X
        );
      });
    }, []);
  return { notification: Q, addNotification: G };
}
var QNB = A1(V1(), 1);
function ZNB(A, B = !1) {
  QNB.useEffect(() => {
    if (!B) wg1(A);
  }, [A, B]);
}
var qg1 = A1(V1(), 1);
function GNB(A, B, Q) {
  let Z = qg1.useRef(!1);
  qg1.useEffect(() => {
    return;
  }, [B, A, Q]);
}
var S0 = A1(V1(), 1),
  sH = A1(V1(), 1);
import { randomUUID as vW5 } from "crypto";
import * as INB from "path";
var bW5 = [
    { value: "both", label: "Restore code and conversation" },
    { value: "conversation", label: "Restore conversation" },
    { value: "code", label: "Restore code" },
  ],
  fW5 = [
    { value: "conversation", label: "Restore conversation" },
    { value: "nevermind", label: "Never mind" },
  ],
  hW5 = 7,
  gW5 = 5;
function WNB({ messages: A, onPreRestore: B, onRestoreMessage: Q, onRestoreCode: Z, onClose: G }) {
  let Y = AA(),
    [I] = dB(),
    [W, J] = sH.useState(void 0),
    X = Dq("tengu_use_file_checkpoints"),
    F = X ? gW5 : hW5,
    V = sH.useMemo(vW5, []),
    K = sH.useMemo(() => [...A.filter(mW5), { ...bA({ content: "" }), uuid: V }], [A, V]),
    [H, z] = sH.useState(K.length - 1),
    D = Math.max(0, Math.min(H - Math.floor(F / 2), K.length - F)),
    [C, w] = sH.useState(void 0),
    [E, L] = sH.useState(void 0),
    [O, R] = sH.useState(!1),
    [P, _] = sH.useState("both");
  sH.useEffect(() => {
    Y1("tengu_message_selector_opened", {});
  }, []);
  async function b(Q1) {
    let J1 = A.indexOf(Q1),
      R1 = A.length - 1 - J1;
    if (
      (Y1("tengu_message_selector_selected", { index_from_end: R1, message_type: Q1.type, is_current_prompt: !1 }),
      !A.includes(Q1))
    ) {
      G();
      return;
    }
    if (X) {
      w(Q1);
      let s1 = YU0(I.fileHistory, Q1.uuid);
      if (s1) L(s1);
    } else if (I.checkpointing.autocheckpointEnabled) {
      w(Q1);
      let s1 = Q1.autocheckpoint?.checkpointId;
      if (s1) {
        let Z0 = aL0(s1, I.checkpointing);
        if (Z0?.commit) {
          let _0 = await sL0(Z0, I.checkpointing);
          if (!_0 || _0.insertions > 0 || _0.deletions > 0) L(_0);
        }
      }
    } else {
      (B(), R(!0));
      try {
        (await Q(Q1), R(!1), G());
      } catch (s1) {
        (U1(s1, H3A), R(!1), J("Failed to restore message"));
      }
    }
  }
  async function S(Q1) {
    if ((Y1("tengu_message_selector_restore_option_selected", { option: Q1 }), !C)) {
      J("Message not found.");
      return;
    }
    if (Q1 === "nevermind") {
      (w(void 0), G());
      return;
    }
    (B(), R(!0), J(void 0));
    let J1 = null,
      R1 = null;
    if (Q1 === "code" || Q1 === "both")
      try {
        await Z(C, X);
      } catch (s1) {
        ((J1 = s1), U1(J1, z3A));
      }
    if (Q1 === "conversation" || Q1 === "both")
      try {
        await Q(C);
      } catch (s1) {
        ((R1 = s1), U1(R1, D3A));
      }
    if ((R(!1), w(void 0), R1 && J1)) J("Failed to restore conversation and code");
    else if (R1) J("Failed to restore conversation");
    else if (J1) J("Failed to restore code");
    else G();
  }
  let d = Z2();
  function u() {
    (Y1("tengu_message_selector_cancelled", {}), G());
  }
  s0((Q1, J1) => {
    if (J1.tab || J1.escape) {
      u();
      return;
    }
    if (O || W || C) return;
    if (J1.return) {
      b(K[H]);
      return;
    }
    if (J1.upArrow)
      if (J1.ctrl || J1.shift || J1.meta) z(0);
      else z((R1) => Math.max(0, R1 - 1));
    if (J1.downArrow)
      if (J1.ctrl || J1.shift || J1.meta) z(K.length - 1);
      else z((R1) => Math.min(K.length - 1, R1 + 1));
  });
  let o = (I.checkpointing.autocheckpointEnabled && I.checkpointing.status !== "initialized") || X,
    [m, j] = sH.useState({});
  sH.useEffect(() => {
    async function Q1() {
      if (X)
        Promise.all(
          K.map(async (J1, R1) => {
            if (A.indexOf(J1) >= 0) {
              let Z0 = YU0(I.fileHistory, J1.uuid);
              if (Z0 !== void 0) j((_0) => ({ ..._0, [R1]: Z0 }));
              else j((_0) => ({ ..._0, [R1]: void 0 }));
            }
          }),
        );
      else if (I.checkpointing.autocheckpointEnabled && !o)
        Promise.all(
          K.map(async (J1, R1) => {
            if (A.indexOf(J1) >= 0) {
              let Z0 = J1.autocheckpoint?.checkpointId;
              if (!Z0) j((_0) => ({ ..._0, [R1]: void 0 }));
              else {
                let _0 = aL0(Z0, I.checkpointing);
                if (_0?.commit) {
                  let D0 = await sL0(_0, I.checkpointing);
                  if (D0) j((C1) => ({ ...C1, [R1]: D0 }));
                } else j((D0) => ({ ...D0, [R1]: void 0 }));
              }
            }
          }),
        );
    }
    Q1();
  }, [K, o, A, I.checkpointing, I.fileHistory, X, j]);
  let r = X ? E && (E.filesChanged?.length || 0) > 0 : !!E;
  return S0.createElement(
    S0.Fragment,
    null,
    W &&
      S0.createElement(
        S0.Fragment,
        null,
        S0.createElement(
          y,
          { marginTop: 2, padding: 1, flexDirection: "column" },
          S0.createElement(M, { color: "error" }, "Error: ", W),
          S0.createElement(
            y,
            { marginTop: 1 },
            S0.createElement(
              M,
              { dimColor: !0 },
              d.pending ? `Press ${d.keyName} again to exit` : !O ? "Press Enter or Esc to exit" : "",
            ),
          ),
        ),
      ),
    !W &&
      S0.createElement(
        S0.Fragment,
        null,
        S0.createElement(
          y,
          { flexDirection: "column", borderStyle: "round", borderColor: "suggestion", paddingX: 1, marginTop: 1 },
          C &&
            S0.createElement(
              y,
              { flexDirection: "column", marginBottom: 1 },
              S0.createElement(
                y,
                { flexDirection: "column", marginBottom: 1 },
                S0.createElement(M, { bold: !0, color: "suggestion" }, "Rewind"),
                S0.createElement(
                  M,
                  { dimColor: !0 },
                  "Confirm you want to restore",
                  " ",
                  !E && "the conversation ",
                  "to the point before you sent this message:",
                ),
              ),
              S0.createElement(
                y,
                {
                  flexDirection: "column",
                  marginBottom: 1,
                  paddingLeft: 1,
                  borderStyle: "single",
                  borderRight: !1,
                  borderTop: !1,
                  borderBottom: !1,
                  borderLeft: !0,
                  borderLeftDimColor: !0,
                },
                S0.createElement(YNB, { userMessage: C, color: "text", isCurrent: !1 }),
                S0.createElement(M, { dimColor: !0 }, "(", Yu(new Date(C.timestamp)), ")"),
              ),
              S0.createElement(
                y,
                { flexDirection: "column", marginBottom: 1 },
                P === "both" || P === "conversation"
                  ? S0.createElement(
                      M,
                      { dimColor: !0 },
                      "The conversation will be ",
                      S0.createElement(M, { bold: !0 }, "forked"),
                      ".",
                    )
                  : S0.createElement(
                      M,
                      { dimColor: !0 },
                      "The conversation will be ",
                      S0.createElement(M, { bold: !0 }, "unchanged"),
                      ".",
                    ),
                r && (P === "both" || P === "code")
                  ? S0.createElement(
                      y,
                      { flexDirection: "row" },
                      X
                        ? S0.createElement(uW5, { diffStatsForRestore: E })
                        : S0.createElement(
                            S0.Fragment,
                            null,
                            S0.createElement(
                              M,
                              { dimColor: !0 },
                              "This affects all code",
                              " ",
                              E &&
                                S0.createElement(
                                  M,
                                  { dimColor: !0 },
                                  "(",
                                  S0.createElement(M, { color: "diffAddedWord" }, E.insertions, " insert(+)", " "),
                                  S0.createElement(M, { color: "diffRemovedWord" }, E.deletions, " delete(-)"),
                                  ")",
                                ),
                              " ",
                              "in ",
                              Y.length > 60 ? "your cwd." : Y,
                            ),
                          ),
                    )
                  : S0.createElement(
                      M,
                      { dimColor: !0 },
                      "The code will be ",
                      S0.createElement(M, { bold: !0 }, "unchanged"),
                      ".",
                    ),
              ),
              S0.createElement(xA, {
                isDisabled: O,
                options: r ? bW5 : fW5,
                focusValue: r ? "both" : "conversation",
                onFocus: (Q1) => _(Q1),
                onChange: (Q1) => S(Q1),
                onCancel: () => w(void 0),
              }),
            ),
          !C &&
            S0.createElement(
              S0.Fragment,
              null,
              S0.createElement(
                y,
                { flexDirection: "column", marginBottom: 1 },
                S0.createElement(M, { bold: !0, color: "suggestion" }, "Rewind"),
                I.checkpointing.autocheckpointEnabled || X
                  ? S0.createElement(M, { dimColor: !0 }, "Restore the code and/or conversation to the point before…")
                  : S0.createElement(M, { dimColor: !0 }, "Restore (and fork) the conversation to the point before…"),
              ),
              S0.createElement(
                y,
                { width: "100%", flexDirection: "column" },