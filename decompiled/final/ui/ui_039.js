/**
 * ╔════════════════════════════════════════════════════════════════╗
 * ║  Claude Code Decompiled - 完整逻辑还原版 v3.0                   ║
 * ╚════════════════════════════════════════════════════════════════╝
 *
 * 原始文件: ui_039.js
 * 处理时间: 2025-12-09T03:41:39.441Z
 * 变量映射: 0 个已识别变量
 *
 * 注意: 代码逻辑100%保留，仅添加变量名解释注释
 *
 */

/**
 * Claude Code Decompiled
 * Category: ui
 * File: 39/53
 * Lines: 328926 - 330422 (1497 lines)
 * Original file: cli.js
 */

        upsilon: "υ",
        UpTee: "⊥",
        UpTeeArrow: "↥",
        upuparrows: "⇈",
        urcorn: "⌝",
        urcorner: "⌝",
        urcrop: "⌎",
        Uring: "Ů",
        uring: "ů",
        urtri: "◹",
        Uscr: "\uD835\uDCB0",
        uscr: "\uD835\uDCCA",
        utdot: "⋰",
        Utilde: "Ũ",
        utilde: "ũ",
        utri: "▵",
        utrif: "▴",
        uuarr: "⇈",
        Uuml: "Ü",
        uuml: "ü",
        uwangle: "⦧",
        vangrt: "⦜",
        varepsilon: "ϵ",
        varkappa: "ϰ",
        varnothing: "∅",
        varphi: "ϕ",
        varpi: "ϖ",
        varpropto: "∝",
        vArr: "⇕",
        varr: "↕",
        varrho: "ϱ",
        varsigma: "ς",
        varsubsetneq: "⊊︀",
        varsubsetneqq: "⫋︀",
        varsupsetneq: "⊋︀",
        varsupsetneqq: "⫌︀",
        vartheta: "ϑ",
        vartriangleleft: "⊲",
        vartriangleright: "⊳",
        Vbar: "⫫",
        vBar: "⫨",
        vBarv: "⫩",
        Vcy: "В",
        vcy: "в",
        VDash: "⊫",
        Vdash: "⊩",
        vDash: "⊨",
        vdash: "⊢",
        Vdashl: "⫦",
        Vee: "⋁",
        vee: "∨",
        veebar: "⊻",
        veeeq: "≚",
        vellip: "⋮",
        Verbar: "‖",
        verbar: "|",
        Vert: "‖",
        vert: "|",
        VerticalBar: "∣",
        VerticalLine: "|",
        VerticalSeparator: "❘",
        VerticalTilde: "≀",
        VeryThinSpace: " ",
        Vfr: "\uD835\uDD19",
        vfr: "\uD835\uDD33",
        vltri: "⊲",
        vnsub: "⊂⃒",
        vnsup: "⊃⃒",
        Vopf: "\uD835\uDD4D",
        vopf: "\uD835\uDD67",
        vprop: "∝",
        vrtri: "⊳",
        Vscr: "\uD835\uDCB1",
        vscr: "\uD835\uDCCB",
        vsubnE: "⫋︀",
        vsubne: "⊊︀",
        vsupnE: "⫌︀",
        vsupne: "⊋︀",
        Vvdash: "⊪",
        vzigzag: "⦚",
        Wcirc: "Ŵ",
        wcirc: "ŵ",
        wedbar: "⩟",
        Wedge: "⋀",
        wedge: "∧",
        wedgeq: "≙",
        weierp: "℘",
        Wfr: "\uD835\uDD1A",
        wfr: "\uD835\uDD34",
        Wopf: "\uD835\uDD4E",
        wopf: "\uD835\uDD68",
        wp: "℘",
        wr: "≀",
        wreath: "≀",
        Wscr: "\uD835\uDCB2",
        wscr: "\uD835\uDCCC",
        xcap: "⋂",
        xcirc: "◯",
        xcup: "⋃",
        xdtri: "▽",
        Xfr: "\uD835\uDD1B",
        xfr: "\uD835\uDD35",
        xhArr: "⟺",
        xharr: "⟷",
        Xi: "Ξ",
        xi: "ξ",
        xlArr: "⟸",
        xlarr: "⟵",
        xmap: "⟼",
        xnis: "⋻",
        xodot: "⨀",
        Xopf: "\uD835\uDD4F",
        xopf: "\uD835\uDD69",
        xoplus: "⨁",
        xotime: "⨂",
        xrArr: "⟹",
        xrarr: "⟶",
        Xscr: "\uD835\uDCB3",
        xscr: "\uD835\uDCCD",
        xsqcup: "⨆",
        xuplus: "⨄",
        xutri: "△",
        xvee: "⋁",
        xwedge: "⋀",
        Yacute: "Ý",
        yacute: "ý",
        YAcy: "Я",
        yacy: "я",
        Ycirc: "Ŷ",
        ycirc: "ŷ",
        Ycy: "Ы",
        ycy: "ы",
        yen: "¥",
        Yfr: "\uD835\uDD1C",
        yfr: "\uD835\uDD36",
        YIcy: "Ї",
        yicy: "ї",
        Yopf: "\uD835\uDD50",
        yopf: "\uD835\uDD6A",
        Yscr: "\uD835\uDCB4",
        yscr: "\uD835\uDCCE",
        YUcy: "Ю",
        yucy: "ю",
        Yuml: "Ÿ",
        yuml: "ÿ",
        Zacute: "Ź",
        zacute: "ź",
        Zcaron: "Ž",
        zcaron: "ž",
        Zcy: "З",
        zcy: "з",
        Zdot: "Ż",
        zdot: "ż",
        zeetrf: "ℨ",
        ZeroWidthSpace: "​",
        Zeta: "Ζ",
        zeta: "ζ",
        Zfr: "ℨ",
        zfr: "\uD835\uDD37",
        ZHcy: "Ж",
        zhcy: "ж",
        zigrarr: "⇝",
        Zopf: "ℤ",
        zopf: "\uD835\uDD6B",
        Zscr: "\uD835\uDCB5",
        zscr: "\uD835\uDCCF",
        zwj: "‍",
        zwnj: "‌"
    });
    Jx5.entityMap = Jx5.HTML_ENTITIES
});
var KO2 = U((zx5) => {
    var WRA = eOA().NAMESPACE,
        I80 = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
        IO2 = new RegExp("[\\-\\.0-9" + I80.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),
        YO2 = new RegExp("^" + I80.source + IO2.source + "*(?::" + I80.source + IO2.source + "*)?$"),
        IRA = 0,
        ri = 1,
        RJA = 2,
        YRA = 3,
        TJA = 4,
        PJA = 5,
        JRA = 6,
        l81 = 7;

    function jJA(A, Q) {
        if (this.message = A, this.locator = Q, Error.captureStackTrace) Error.captureStackTrace(this, jJA)
    }
    jJA.prototype = Error();
    jJA.prototype.name = jJA.name;

    function XO2() {}
    XO2.prototype = {
        parse: function(A, Q, B) {
            var G = this.domBuilder;
            G.startDocument(), FO2(Q, Q = {}), Fx5(A, Q, B, G, this.errorHandler), G.endDocument()
        }
    };

    function Fx5(A, Q, B, G, Z) {
        function I(QA) {
            if (QA > 65535) {
                QA -= 65536;
                var IA = 55296 + (QA >> 10),
                    HA = 56320 + (QA & 1023);
                return String.fromCharCode(IA, HA)
            } else return String.fromCharCode(QA)
        }

        function Y(QA) {
            var IA = QA.slice(1, -1);
            if (Object.hasOwnProperty.call(B, IA)) return B[IA];
            else if (IA.charAt(0) === "#") return I(parseInt(IA.substr(1).replace("x", "0x")));
            else return Z.error("entity not found:" + QA), QA
        }

        function J(QA) {
            if (QA > C) {
                var IA = A.substring(C, QA).replace(/&#?\w+;/g, Y);
                K && W(C), G.characters(IA, 0, QA - C), C = QA
            }
        }

        function W(QA, IA) {
            while (QA >= F && (IA = V.exec(A))) X = IA.index, F = X + IA[0].length, K.lineNumber++;
            K.columnNumber = QA - X + 1
        }
        var X = 0,
            F = 0,
            V = /.*(?:\r\n?|\n)|.*$/g,
            K = G.locator,
            D = [{
                currentNSMap: Q
            }],
            H = {},
            C = 0;
        while (!0) {
            try {
                var E = A.indexOf("<", C);
                if (E < 0) {
                    if (!A.substr(C).match(/^\s*$/)) {
                        var z = G.doc,
                            w = z.createTextNode(A.substr(C));
                        z.appendChild(w), G.currentElement = w
                    }
                    return
                }
                if (E > C) J(E);
                switch (A.charAt(E + 1)) {
                    case "/":
                        var u = A.indexOf(">", E + 3),
                            N = A.substring(E + 2, u).replace(/[ \t\n\r]+$/g, ""),
                            q = D.pop();
                        if (u < 0) N = A.substring(E + 2).replace(/[\s<].*/, ""), Z.error("end tag name: " + N + " is not complete:" + q.tagName), u = E + 1 + N.length;
                        else if (N.match(/\s</)) N = N.replace(/[\s<].*/, ""), Z.error("end tag name: " + N + " maybe not complete"), u = E + 1 + N.length;
                        var R = q.localNSMap,
                            P = q.tagName == N,
                            y = P || q.tagName && q.tagName.toLowerCase() == N.toLowerCase();
                        if (y) {
                            if (G.endElement(q.uri, q.localName, N), R) {
                                for (var v in R)
                                    if (Object.prototype.hasOwnProperty.call(R, v)) G.endPrefixMapping(v)
                            }
                            if (!P) Z.fatalError("end tag name: " + N + " is not match the current start tagName:" + q.tagName)
                        } else D.push(q);
                        u++;
                        break;
                    case "?":
                        K && W(E), u = Cx5(A, E, G);
                        break;
                    case "!":
                        K && W(E), u = Hx5(A, E, G, Z);
                        break;
                    default:
                        K && W(E);
                        var x = new VO2,
                            p = D[D.length - 1].currentNSMap,
                            u = Vx5(A, E, x, p, Y, Z),
                            o = x.length;
                        if (!x.closed && Dx5(A, u, x.tagName, H)) {
                            if (x.closed = !0, !B.nbsp) Z.warning("unclosed xml attribute")
                        }
                        if (K && o) {
                            var l = JO2(K, {});
                            for (var k = 0; k < o; k++) {
                                var d = x[k];
                                W(d.offset), d.locator = JO2(K, {})
                            }
                            if (G.locator = l, WO2(x, G, p)) D.push(x);
                            G.locator = K
                        } else if (WO2(x, G, p)) D.push(x);
                        if (WRA.isHTML(x.uri) && !x.closed) u = Kx5(A, u, x.tagName, Y, G);
                        else u++
                }
            } catch (QA) {
                if (QA instanceof jJA) throw QA;
                Z.error("element parse error: " + QA), u = -1
            }
            if (u > C) C = u;
            else J(Math.max(E, C) + 1)
        }
    }

    function JO2(A, Q) {
        return Q.lineNumber = A.lineNumber, Q.columnNumber = A.columnNumber, Q
    }

    function Vx5(A, Q, B, G, Z, I) {
        function Y(D, H, C) {
            if (B.attributeNames.hasOwnProperty(D)) I.fatalError("Attribute " + D + " redefined");
            B.addValue(D, H.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, Z), C)
        }
        var J, W, X = ++Q,
            F = IRA;
        while (!0) {
            var V = A.charAt(X);
            switch (V) {
                case "=":
                    if (F === ri) J = A.slice(Q, X), F = YRA;
                    else if (F === RJA) F = YRA;
                    else throw Error("attribute equal must after attrName");
                    break;
                case "'":
                case '"':
                    if (F === YRA || F === ri) {
                        if (F === ri) I.warning('attribute value must after "="'), J = A.slice(Q, X);
                        if (Q = X + 1, X = A.indexOf(V, Q), X > 0) W = A.slice(Q, X), Y(J, W, Q - 1), F = PJA;
                        else throw Error("attribute value no end '" + V + "' match")
                    } else if (F == TJA) W = A.slice(Q, X), Y(J, W, Q), I.warning('attribute "' + J + '" missed start quot(' + V + ")!!"), Q = X + 1, F = PJA;
                    else throw Error('attribute value must after "="');
                    break;
                case "/":
                    switch (F) {
                        case IRA:
                            B.setTagName(A.slice(Q, X));
                        case PJA:
                        case JRA:
                        case l81:
                            F = l81, B.closed = !0;
                        case TJA:
                        case ri:
                            break;
                        case RJA:
                            B.closed = !0;
                            break;
                        default:
                            throw Error("attribute invalid close char('/')")
                    }
                    break;
                case "":
                    if (I.error("unexpected end of input"), F == IRA) B.setTagName(A.slice(Q, X));
                    return X;
                case ">":
                    switch (F) {
                        case IRA:
                            B.setTagName(A.slice(Q, X));
                        case PJA:
                        case JRA:
                        case l81:
                            break;
                        case TJA:
                        case ri:
                            if (W = A.slice(Q, X), W.slice(-1) === "/") B.closed = !0, W = W.slice(0, -1);
                        case RJA:
                            if (F === RJA) W = J;
                            if (F == TJA) I.warning('attribute "' + W + '" missed quot(")!'), Y(J, W, Q);
                            else {
                                if (!WRA.isHTML(G[""]) || !W.match(/^(?:disabled|checked|selected)$/i)) I.warning('attribute "' + W + '" missed value!! "' + W + '" instead!!');
                                Y(W, W, Q)
                            }
                            break;
                        case YRA:
                            throw Error("attribute value missed!!")
                    }
                    return X;
                case "":
                    V = " ";
                default:
                    if (V <= " ") switch (F) {
                        case IRA:
                            B.setTagName(A.slice(Q, X)), F = JRA;
                            break;
                        case ri:
                            J = A.slice(Q, X), F = RJA;
                            break;
                        case TJA:
                            var W = A.slice(Q, X);
                            I.warning('attribute "' + W + '" missed quot(")!!'), Y(J, W, Q);
                        case PJA:
                            F = JRA;
                            break
                    } else switch (F) {
                        case RJA:
                            var K = B.tagName;
                            if (!WRA.isHTML(G[""]) || !J.match(/^(?:disabled|checked|selected)$/i)) I.warning('attribute "' + J + '" missed value!! "' + J + '" instead2!!');
                            Y(J, J, Q), Q = X, F = ri;
                            break;
                        case PJA:
                            I.warning('attribute space is required"' + J + '"!!');
                        case JRA:
                            F = ri, Q = X;
                            break;
                        case YRA:
                            F = TJA, Q = X;
                            break;
                        case l81:
                            throw Error("elements closed character '/' and '>' must be connected to")
                    }
            }
            X++
        }
    }

    function WO2(A, Q, B) {
        var G = A.tagName,
            Z = null,
            V = A.length;
        while (V--) {
            var I = A[V],
                Y = I.qName,
                J = I.value,
                K = Y.indexOf(":");
            if (K > 0) var W = I.prefix = Y.slice(0, K),
                X = Y.slice(K + 1),
                F = W === "xmlns" && X;
            else X = Y, W = null, F = Y === "xmlns" && "";
            if (I.localName = X, F !== !1) {
                if (Z == null) Z = {}, FO2(B, B = {});
                B[F] = Z[F] = J, I.uri = WRA.XMLNS, Q.startPrefixMapping(F, J)
            }
        }
        var V = A.length;
        while (V--) {
            I = A[V];
            var W = I.prefix;
            if (W) {
                if (W === "xml") I.uri = WRA.XML;
                if (W !== "xmlns") I.uri = B[W || ""]
            }
        }
        var K = G.indexOf(":");
        if (K > 0) W = A.prefix = G.slice(0, K), X = A.localName = G.slice(K + 1);
        else W = null, X = A.localName = G;
        var D = A.uri = B[W || ""];
        if (Q.startElement(D, X, G, A), A.closed) {
            if (Q.endElement(D, X, G), Z) {
                for (W in Z)
                    if (Object.prototype.hasOwnProperty.call(Z, W)) Q.endPrefixMapping(W)
            }
        } else return A.currentNSMap = B, A.localNSMap = Z, !0
    }

    function Kx5(A, Q, B, G, Z) {
        if (/^(?:script|textarea)$/i.test(B)) {
            var I = A.indexOf("</" + B + ">", Q),
                Y = A.substring(Q + 1, I);
            if (/[&<]/.test(Y)) {
                if (/^script$/i.test(B)) return Z.characters(Y, 0, Y.length), I;
                return Y = Y.replace(/&#?\w+;/g, G), Z.characters(Y, 0, Y.length), I
            }
        }
        return Q + 1
    }

    function Dx5(A, Q, B, G) {
        var Z = G[B];
        if (Z == null) {
            if (Z = A.lastIndexOf("</" + B + ">"), Z < Q) Z = A.lastIndexOf("</" + B);
            G[B] = Z
        }
        return Z < Q
    }

    function FO2(A, Q) {
        for (var B in A)
            if (Object.prototype.hasOwnProperty.call(A, B)) Q[B] = A[B]
    }

    function Hx5(A, Q, B, G) {
        var Z = A.charAt(Q + 2);
        switch (Z) {
            case "-":
                if (A.charAt(Q + 3) === "-") {
                    var I = A.indexOf("-->", Q + 4);
                    if (I > Q) return B.comment(A, Q + 4, I - Q - 4), I + 3;
                    else return G.error("Unclosed comment"), -1
                } else return -1;
            default:
                if (A.substr(Q + 3, 6) == "CDATA[") {
                    var I = A.indexOf("]]>", Q + 9);
                    return B.startCDATA(), B.characters(A, Q + 9, I - Q - 9), B.endCDATA(), I + 3
                }
                var Y = Ex5(A, Q),
                    J = Y.length;
                if (J > 1 && /!doctype/i.test(Y[0][0])) {
                    var W = Y[1][0],
                        X = !1,
                        F = !1;
                    if (J > 3) {
                        if (/^public$/i.test(Y[2][0])) X = Y[3][0], F = J > 4 && Y[4][0];
                        else if (/^system$/i.test(Y[2][0])) F = Y[3][0]
                    }
                    var V = Y[J - 1];
                    return B.startDTD(W, X, F), B.endDTD(), V.index + V[0].length
                }
        }
        return -1
    }

    function Cx5(A, Q, B) {
        var G = A.indexOf("?>", Q);
        if (G) {
            var Z = A.substring(Q, G).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
            if (Z) {
                var I = Z[0].length;
                return B.processingInstruction(Z[1], Z[2]), G + 2
            } else return -1
        }
        return -1
    }

    function VO2() {
        this.attributeNames = {}
    }
    VO2.prototype = {
        setTagName: function(A) {
            if (!YO2.test(A)) throw Error("invalid tagName:" + A);
            this.tagName = A
        },
        addValue: function(A, Q, B) {
            if (!YO2.test(A)) throw Error("invalid attribute:" + A);
            this.attributeNames[A] = this.length, this[this.length++] = {
                qName: A,
                value: Q,
                offset: B
            }
        },
        length: 0,
        getLocalName: function(A) {
            return this[A].localName
        },
        getLocator: function(A) {
            return this[A].locator
        },
        getQName: function(A) {
            return this[A].qName
        },
        getURI: function(A) {
            return this[A].uri
        },
        getValue: function(A) {
            return this[A].value
        }
    };

    function Ex5(A, Q) {
        var B, G = [],
            Z = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
        Z.lastIndex = Q, Z.exec(A);
        while (B = Z.exec(A))
            if (G.push(B), B[1]) return G
    }
    zx5.XMLReader = XO2;
    zx5.ParseError = jJA
});
var $O2 = U((Rx5) => {
    var wx5 = eOA(),
        qx5 = Z80(),
        DO2 = ZO2(),
        EO2 = KO2(),
        Nx5 = qx5.DOMImplementation,
        HO2 = wx5.NAMESPACE,
        Lx5 = EO2.ParseError,
        Mx5 = EO2.XMLReader;

    function zO2(A) {
        return A.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`)
    }

    function UO2(A) {
        this.options = A || {
            locator: {}
        }
    }
    UO2.prototype.parseFromString = function(A, Q) {
        var B = this.options,
            G = new Mx5,
            Z = B.domBuilder || new XRA,
            I = B.errorHandler,
            Y = B.locator,
            J = B.xmlns || {},
            W = /\/x?html?$/.test(Q),
            X = W ? DO2.HTML_ENTITIES : DO2.XML_ENTITIES;
        if (Y) Z.setDocumentLocator(Y);
        if (G.errorHandler = Ox5(I, Z, Y), G.domBuilder = B.domBuilder || Z, W) J[""] = HO2.HTML;
        J.xml = J.xml || HO2.XML;
        var F = B.normalizeLineEndings || zO2;
        if (A && typeof A === "string") G.parse(F(A), J, X);
        else G.errorHandler.error("invalid doc source");
        return Z.doc
    };

    function Ox5(A, Q, B) {
        if (!A) {
            if (Q instanceof XRA) return Q;
            A = Q
        }
        var G = {},
            Z = A instanceof Function;
        B = B || {};

        function I(Y) {
            var J = A[Y];
            if (!J && Z) J = A.length == 2 ? function(W) {
                A(Y, W)
            } : A;
            G[Y] = J && function(W) {
                J("[xmldom " + Y + "]\t" + W + Y80(B))
            } || function() {}
        }
        return I("warning"), I("error"), I("fatalError"), G
    }

    function XRA() {
        this.cdata = !1
    }

    function SJA(A, Q) {
        Q.lineNumber = A.lineNumber, Q.columnNumber = A.columnNumber
    }
    XRA.prototype = {
        startDocument: function() {
            if (this.doc = new Nx5().createDocument(null, null, null), this.locator) this.doc.documentURI = this.locator.systemId
        },
        startElement: function(A, Q, B, G) {
            var Z = this.doc,
                I = Z.createElementNS(A, B || Q),
                Y = G.length;
            i81(this, I), this.currentElement = I, this.locator && SJA(this.locator, I);
            for (var J = 0; J < Y; J++) {
                var A = G.getURI(J),
                    W = G.getValue(J),
                    B = G.getQName(J),
                    X = Z.createAttributeNS(A, B);
                this.locator && SJA(G.getLocator(J), X), X.value = X.nodeValue = W, I.setAttributeNode(X)
            }
        },
        endElement: function(A, Q, B) {
            var G = this.currentElement,
                Z = G.tagName;
            this.currentElement = G.parentNode
        },
        startPrefixMapping: function(A, Q) {},
        endPrefixMapping: function(A) {},
        processingInstruction: function(A, Q) {
            var B = this.doc.createProcessingInstruction(A, Q);
            this.locator && SJA(this.locator, B), i81(this, B)
        },
        ignorableWhitespace: function(A, Q, B) {},
        characters: function(A, Q, B) {
            if (A = CO2.apply(this, arguments), A) {
                if (this.cdata) var G = this.doc.createCDATASection(A);
                else var G = this.doc.createTextNode(A);
                if (this.currentElement) this.currentElement.appendChild(G);
                else if (/^\s*$/.test(A)) this.doc.appendChild(G);
                this.locator && SJA(this.locator, G)
            }
        },
        skippedEntity: function(A) {},
        endDocument: function() {
            this.doc.normalize()
        },
        setDocumentLocator: function(A) {
            if (this.locator = A) A.lineNumber = 0
        },
        comment: function(A, Q, B) {
            A = CO2.apply(this, arguments);
            var G = this.doc.createComment(A);
            this.locator && SJA(this.locator, G), i81(this, G)
        },
        startCDATA: function() {
            this.cdata = !0
        },
        endCDATA: function() {
            this.cdata = !1
        },
        startDTD: function(A, Q, B) {
            var G = this.doc.implementation;
            if (G && G.createDocumentType) {
                var Z = G.createDocumentType(A, Q, B);
                this.locator && SJA(this.locator, Z), i81(this, Z), this.doc.doctype = Z
            }
        },
        warning: function(A) {
            console.warn("[xmldom warning]\t" + A, Y80(this.locator))
        },
        error: function(A) {
            console.error("[xmldom error]\t" + A, Y80(this.locator))
        },
        fatalError: function(A) {
            throw new Lx5(A, this.locator)
        }
    };

    function Y80(A) {
        if (A) return `
@` + (A.systemId || "") + "#[line:" + A.lineNumber + ",col:" + A.columnNumber + "]"
    }

    function CO2(A, Q, B) {
        if (typeof A == "string") return A.substr(Q, B);
        else {
            if (A.length >= Q + B || Q) return new java.lang.String(A, Q, B) + "";
            return A
        }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(A) {
        XRA.prototype[A] = function() {
            return null
        }
    });

    function i81(A, Q) {
        if (!A.currentElement) A.doc.appendChild(Q);
        else A.currentElement.appendChild(Q)
    }
    Rx5.__DOMHandler = XRA;
    Rx5.normalizeLineEndings = zO2;
    Rx5.DOMParser = UO2
});
var qO2 = U((Sx5) => {
    var wO2 = Z80();
    Sx5.DOMImplementation = wO2.DOMImplementation;
    Sx5.XMLSerializer = wO2.XMLSerializer;
    Sx5.DOMParser = $O2().DOMParser
});
var LO2 = U((fx5) => {
    var {
        DOMParser: xx5
    } = qO2();
    fx5.parse = bx5;
    var n81 = 3,
        NO2 = 4,
        vx5 = 8;

    function J80(A) {
        return A.nodeType === n81 || A.nodeType === vx5 || A.nodeType === NO2
    }

    function yh(A) {
        if (!A.childNodes || A.childNodes.length === 0) return !0;
        else return !1
    }

    function Z0A(A, Q) {
        if (!A) throw Error(Q)
    }

    function bx5(A) {
        var Q = new xx5().parseFromString(A);
        Z0A(Q.documentElement.nodeName === "plist", "malformed document. First element should be <plist>");
        var B = _JA(Q.documentElement);
        if (B.length == 1) B = B[0];
        return B
    }

    function _JA(A) {
        var Q, B, G, Z, I, Y, J, W;
        if (!A) return null;
        if (A.nodeName === "plist") {
            if (I = [], yh(A)) return I;
            for (Q = 0; Q < A.childNodes.length; Q++)
                if (!J80(A.childNodes[Q])) I.push(_JA(A.childNodes[Q]));
            return I
        } else if (A.nodeName === "dict") {
            if (B = {}, G = null, J = 0, yh(A)) return B;
            for (Q = 0; Q < A.childNodes.length; Q++) {
                if (J80(A.childNodes[Q])) continue;
                if (J % 2 === 0) Z0A(A.childNodes[Q].nodeName === "key", "Missing key while parsing <dict/>."), G = _JA(A.childNodes[Q]);
                else Z0A(A.childNodes[Q].nodeName !== "key", 'Unexpected key "' + _JA(A.childNodes[Q]) + '" while parsing <dict/>.'), B[G] = _JA(A.childNodes[Q]);
                J += 1
            }
            if (J % 2 === 1) B[G] = "";
            return B
        } else if (A.nodeName === "array") {
            if (I = [], yh(A)) return I;
            for (Q = 0; Q < A.childNodes.length; Q++)
                if (!J80(A.childNodes[Q])) {
                    if (Y = _JA(A.childNodes[Q]), Y != null) I.push(Y)
                } return I
        } else if (A.nodeName === "#text");
        else if (A.nodeName === "key") {
            if (yh(A)) return "";
            return Z0A(A.childNodes[0].nodeValue !== "__proto__", "__proto__ keys can lead to prototype pollution. More details on CVE-2022-22912"), A.childNodes[0].nodeValue
        } else if (A.nodeName === "string") {
            if (Y = "", yh(A)) return Y;
            for (Q = 0; Q < A.childNodes.length; Q++) {
                var W = A.childNodes[Q].nodeType;
                if (W === n81 || W === NO2) Y += A.childNodes[Q].nodeValue
            }
            return Y
        } else if (A.nodeName === "integer") return Z0A(!yh(A), 'Cannot parse "" as integer.'), parseInt(A.childNodes[0].nodeValue, 10);
        else if (A.nodeName === "real") {
            Z0A(!yh(A), 'Cannot parse "" as real.'), Y = "";
            for (Q = 0; Q < A.childNodes.length; Q++)
                if (A.childNodes[Q].nodeType === n81) Y += A.childNodes[Q].nodeValue;
            return parseFloat(Y)
        } else if (A.nodeName === "data") {
            if (Y = "", yh(A)) return Buffer.from(Y, "base64");
            for (Q = 0; Q < A.childNodes.length; Q++)
                if (A.childNodes[Q].nodeType === n81) Y += A.childNodes[Q].nodeValue.replace(/\s+/g, "");
            return Buffer.from(Y, "base64")
        } else if (A.nodeName === "date") return Z0A(!yh(A), 'Cannot parse "" as Date.'), new Date(A.childNodes[0].nodeValue);
        else if (A.nodeName === "null") return null;
        else if (A.nodeName === "true") return !0;
        else if (A.nodeName === "false") return !1;
        else throw Error("Invalid PLIST tag " + A.nodeName)
    }
});
var Fy = U((MO2, oi) => {
    (function() {
        var A, Q, B, G, Z, I, Y, J = {}.hasOwnProperty;
        A = function(W, ...X) {
            var F, V, K, D;
            if (Z(Object.assign)) Object.assign.apply(null, arguments);
            else
                for (F = 0, K = X.length; F < K; F++)
                    if (D = X[F], D != null)
                        for (V in D) {
                            if (!J.call(D, V)) continue;
                            W[V] = D[V]
                        }
            return W
        }, Z = function(W) {
            return !!W && Object.prototype.toString.call(W) === "[object Function]"
        }, I = function(W) {
            var X;
            return !!W && ((X = typeof W) === "function" || X === "object")
        }, B = function(W) {
            if (Z(Array.isArray)) return Array.isArray(W);
            else return Object.prototype.toString.call(W) === "[object Array]"
        }, G = function(W) {
            var X;
            if (B(W)) return !W.length;
            else {
                for (X in W) {
                    if (!J.call(W, X)) continue;
                    return !1
                }
                return !0
            }
        }, Y = function(W) {
            var X, F;
            return I(W) && (F = Object.getPrototypeOf(W)) && (X = F.constructor) && typeof X === "function" && X instanceof X && Function.prototype.toString.call(X) === Function.prototype.toString.call(Object)
        }, Q = function(W) {
            if (Z(W.valueOf)) return W.valueOf();
            else return W
        }, MO2.assign = A, MO2.isFunction = Z, MO2.isObject = I, MO2.isArray = B, MO2.isEmpty = G, MO2.isPlainObject = Y, MO2.getValue = Q
    }).call(MO2)
});
var W80 = U((OO2, RO2) => {
    (function() {
        var A;
        RO2.exports = A = class {
            hasFeature(B, G) {
                return !0
            }
            createDocumentType(B, G, Z) {
                throw Error("This DOM method is not implemented.")
            }
            createDocument(B, G, Z) {
                throw Error("This DOM method is not implemented.")
            }
            createHTMLDocument(B) {
                throw Error("This DOM method is not implemented.")
            }
            getFeature(B, G) {
                throw Error("This DOM method is not implemented.")
            }
        }
    }).call(OO2)
});
var jO2 = U((TO2, PO2) => {
    (function() {
        var A;
        PO2.exports = A = class {
            constructor() {}
            handleError(B) {
                throw Error(B)
            }
        }
    }).call(TO2)
});
var kO2 = U((SO2, _O2) => {
    (function() {
        var A;
        _O2.exports = A = function() {
            class Q {
                constructor(B) {
                    this.arr = B || []
                }
                item(B) {
                    return this.arr[B] || null
                }
                contains(B) {
                    return this.arr.indexOf(B) !== -1
                }
            }
            return Object.defineProperty(Q.prototype, "length", {
                get: function() {
                    return this.arr.length
                }
            }), Q
        }.call(this)
    }).call(SO2)
});
var vO2 = U((yO2, xO2) => {
    (function() {
        var A, Q, B;
        Q = jO2(), B = kO2(), xO2.exports = A = function() {
            class G {
                constructor() {
                    var Z;
                    this.defaultParams = {
                        "canonical-form": !1,
                        "cdata-sections": !1,
                        comments: !1,
                        "datatype-normalization": !1,
                        "element-content-whitespace": !0,
                        entities: !0,
                        "error-handler": new Q,
                        infoset: !0,
                        "validate-if-schema": !1,
                        namespaces: !0,
                        "namespace-declarations": !0,
                        "normalize-characters": !1,
                        "schema-location": "",
                        "schema-type": "",
                        "split-cdata-sections": !0,
                        validate: !1,
                        "well-formed": !0
                    }, this.params = Z = Object.create(this.defaultParams)
                }
                getParameter(Z) {
                    if (this.params.hasOwnProperty(Z)) return this.params[Z];
                    else return null
                }
                canSetParameter(Z, I) {
                    return !0
                }
                setParameter(Z, I) {
                    if (I != null) return this.params[Z] = I;
                    else return delete this.params[Z]
                }
            }
            return Object.defineProperty(G.prototype, "parameterNames", {
                get: function() {
                    return new B(Object.keys(this.defaultParams))
                }
            }), G
        }.call(this)
    }).call(yO2)
});
var bW = U((bO2, fO2) => {
    (function() {
        fO2.exports = {
            Element: 1,
            Attribute: 2,
            Text: 3,
            CData: 4,
            EntityReference: 5,
            EntityDeclaration: 6,
            ProcessingInstruction: 7,
            Comment: 8,
            Document: 9,
            DocType: 10,
            DocumentFragment: 11,
            NotationDeclaration: 12,
            Declaration: 201,
            Raw: 202,
            AttributeDeclaration: 203,
            ElementDeclaration: 204,
            Dummy: 205
        }
    }).call(bO2)
});
var X80 = U((hO2, gO2) => {
    (function() {
        var A, Q, B;
        A = bW(), B = Mq(), gO2.exports = Q = function() {
            class G {
                constructor(Z, I, Y) {
                    if (this.parent = Z, this.parent) this.options = this.parent.options, this.stringify = this.parent.stringify;
                    if (I == null) throw Error("Missing attribute name. " + this.debugInfo(I));
                    this.name = this.stringify.name(I), this.value = this.stringify.attValue(Y), this.type = A.Attribute, this.isId = !1, this.schemaTypeInfo = null
                }
                clone() {
                    return Object.create(this)
                }
                toString(Z) {
                    return this.options.writer.attribute(this, this.options.writer.filterOptions(Z))
                }
                debugInfo(Z) {
                    if (Z = Z || this.name, Z == null) return "parent: <" + this.parent.name + ">";
                    else return "attribute: {" + Z + "}, parent: <" + this.parent.name + ">"
                }
                isEqualNode(Z) {
                    if (Z.namespaceURI !== this.namespaceURI) return !1;
                    if (Z.prefix !== this.prefix) return !1;
                    if (Z.localName !== this.localName) return !1;
                    if (Z.value !== this.value) return !1;
                    return !0
                }
            }
            return Object.defineProperty(G.prototype, "nodeType", {
                get: function() {
                    return this.type
                }
            }), Object.defineProperty(G.prototype, "ownerElement", {
                get: function() {
                    return this.parent
                }
            }), Object.defineProperty(G.prototype, "textContent", {
                get: function() {
                    return this.value
                },
                set: function(Z) {
                    return this.value = Z || ""
                }
            }), Object.defineProperty(G.prototype, "namespaceURI", {
                get: function() {
                    return ""
                }
            }), Object.defineProperty(G.prototype, "prefix", {
                get: function() {
                    return ""
                }
            }), Object.defineProperty(G.prototype, "localName", {
                get: function() {
                    return this.name
                }
            }), Object.defineProperty(G.prototype, "specified", {
                get: function() {
                    return !0
                }
            }), G
        }.call(this)
    }).call(hO2)
});
var a81 = U((uO2, mO2) => {
    (function() {
        var A;
        mO2.exports = A = function() {
            class Q {
                constructor(B) {
                    this.nodes = B
                }
                clone() {
                    return this.nodes = null
                }
                getNamedItem(B) {
                    return this.nodes[B]
                }
                setNamedItem(B) {
                    var G = this.nodes[B.nodeName];
                    return this.nodes[B.nodeName] = B, G || null
                }
                removeNamedItem(B) {
                    var G = this.nodes[B];
                    return delete this.nodes[B], G || null
                }
                item(B) {
                    return this.nodes[Object.keys(this.nodes)[B]] || null
                }
                getNamedItemNS(B, G) {
                    throw Error("This DOM method is not implemented.")
                }
                setNamedItemNS(B) {
                    throw Error("This DOM method is not implemented.")
                }
                removeNamedItemNS(B, G) {
                    throw Error("This DOM method is not implemented.")
                }
            }
            return Object.defineProperty(Q.prototype, "length", {
                get: function() {
                    return Object.keys(this.nodes).length || 0
                }
            }), Q
        }.call(this)
    }).call(uO2)
});
var s81 = U((dO2, cO2) => {
    (function() {
        var A, Q, B, G, Z, I, Y, J, W = {}.hasOwnProperty;
        ({
            isObject: J,
            isFunction: Y,
            getValue: I
        } = Fy()), Z = Mq(), A = bW(), Q = X80(), G = a81(), cO2.exports = B = function() {
            class X extends Z {
                constructor(F, V, K) {
                    var D, H, C, E;
                    super(F);
                    if (V == null) throw Error("Missing element name. " + this.debugInfo());
                    if (this.name = this.stringify.name(V), this.type = A.Element, this.attribs = {}, this.schemaTypeInfo = null, K != null) this.attribute(K);
                    if (F.type === A.Document) {
                        if (this.isRoot = !0, this.documentObject = F, F.rootObject = this, F.children) {
                            E = F.children;
                            for (H = 0, C = E.length; H < C; H++)
                                if (D = E[H], D.type === A.DocType) {
                                    D.name = this.name;
                                    break
                                }
                        }
                    }
                }
                clone() {
                    var F, V, K, D;
                    if (K = Object.create(this), K.isRoot) K.documentObject = null;
                    K.attribs = {}, D = this.attribs;
                    for (V in D) {
                        if (!W.call(D, V)) continue;
                        F = D[V], K.attribs[V] = F.clone()
                    }
                    return K.children = [], this.children.forEach(function(H) {
                        var C = H.clone();
                        return C.parent = K, K.children.push(C)
                    }), K
                }
                attribute(F, V) {
                    var K, D;
                    if (F != null) F = I(F);
                    if (J(F))
                        for (K in F) {
                            if (!W.call(F, K)) continue;
                            D = F[K], this.attribute(K, D)
                        } else {
                            if (Y(V)) V = V.apply();
                            if (this.options.keepNullAttributes && V == null) this.attribs[F] = new Q(this, F, "");
                            else if (V != null) this.attribs[F] = new Q(this, F, V)
                        }
                    return this
                }
                removeAttribute(F) {
                    var V, K, D;
                    if (F == null) throw Error("Missing attribute name. " + this.debugInfo());
                    if (F = I(F), Array.isArray(F))
                        for (K = 0, D = F.length; K < D; K++) V = F[K], delete this.attribs[V];
                    else delete this.attribs[F];
                    return this
                }
                toString(F) {
                    return this.options.writer.element(this, this.options.writer.filterOptions(F))
                }
                att(F, V) {
                    return this.attribute(F, V)
                }
                a(F, V) {
                    return this.attribute(F, V)
                }
                getAttribute(F) {
                    if (this.attribs.hasOwnProperty(F)) return this.attribs[F].value;
                    else return null
                }
                setAttribute(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getAttributeNode(F) {
                    if (this.attribs.hasOwnProperty(F)) return this.attribs[F];
                    else return null
                }
                setAttributeNode(F) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                removeAttributeNode(F) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getElementsByTagName(F) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getAttributeNS(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                setAttributeNS(F, V, K) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                removeAttributeNS(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getAttributeNodeNS(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                setAttributeNodeNS(F) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getElementsByTagNameNS(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                hasAttribute(F) {
                    return this.attribs.hasOwnProperty(F)
                }
                hasAttributeNS(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                setIdAttribute(F, V) {
                    if (this.attribs.hasOwnProperty(F)) return this.attribs[F].isId;
                    else return V
                }
                setIdAttributeNS(F, V, K) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                setIdAttributeNode(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getElementsByTagName(F) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getElementsByTagNameNS(F, V) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                getElementsByClassName(F) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                isEqualNode(F) {
                    var V, K, D;
                    if (!super.isEqualNode(F)) return !1;
                    if (F.namespaceURI !== this.namespaceURI) return !1;
                    if (F.prefix !== this.prefix) return !1;
                    if (F.localName !== this.localName) return !1;
                    if (F.attribs.length !== this.attribs.length) return !1;
                    for (V = K = 0, D = this.attribs.length - 1; 0 <= D ? K <= D : K >= D; V = 0 <= D ? ++K : --K)
                        if (!this.attribs[V].isEqualNode(F.attribs[V])) return !1;
                    return !0
                }
            }
            return Object.defineProperty(X.prototype, "tagName", {
                get: function() {
                    return this.name
                }
            }), Object.defineProperty(X.prototype, "namespaceURI", {
                get: function() {
                    return ""
                }
            }), Object.defineProperty(X.prototype, "prefix", {
                get: function() {
                    return ""
                }
            }), Object.defineProperty(X.prototype, "localName", {
                get: function() {
                    return this.name
                }
            }), Object.defineProperty(X.prototype, "id", {
                get: function() {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
            }), Object.defineProperty(X.prototype, "className", {
                get: function() {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
            }), Object.defineProperty(X.prototype, "classList", {
                get: function() {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
            }), Object.defineProperty(X.prototype, "attributes", {
                get: function() {
                    if (!this.attributeMap || !this.attributeMap.nodes) this.attributeMap = new G(this.attribs);
                    return this.attributeMap
                }
            }), X
        }.call(this)
    }).call(dO2)
});
var FRA = U((pO2, lO2) => {
    (function() {
        var A, Q;
        Q = Mq(), lO2.exports = A = function() {
            class B extends Q {
                constructor(G) {
                    super(G);
                    this.value = ""
                }
                clone() {
                    return Object.create(this)
                }
                substringData(G, Z) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                appendData(G) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                insertData(G, Z) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                deleteData(G, Z) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                replaceData(G, Z, I) {
                    throw Error("This DOM method is not implemented." + this.debugInfo())
                }
                isEqualNode(G) {
                    if (!super.isEqualNode(G)) return !1;
                    if (G.data !== this.data) return !1;
                    return !0
                }
            }
            return Object.defineProperty(B.prototype, "data", {
                get: function() {
                    return this.value
                },
                set: function(G) {
                    return this.value = G || ""
                }
            }), Object.defineProperty(B.prototype, "length", {
                get: function() {
                    return this.value.length
                }
            }), Object.defineProperty(B.prototype, "textContent", {
                get: function() {
                    return this.value
                },
                set: function(G) {
                    return this.value = G || ""
                }
            }), B
        }.call(this)
    }).call(pO2)
});
var r81 = U((iO2, nO2) => {
    (function() {
        var A, Q, B;
        A = bW(), B = FRA(), nO2.exports = Q = class extends B {
            constructor(Z, I) {
                super(Z);
                if (I == null) throw Error("Missing CDATA text. " + this.debugInfo());
                this.name = "#cdata-section", this.type = A.CData, this.value = this.stringify.cdata(I)
            }
            clone() {
                return Object.create(this)
            }
            toString(Z) {
                return this.options.writer.cdata(this, this.options.writer.filterOptions(Z))
            }
        }
    }).call(iO2)
});
var o81 = U((aO2, sO2) => {
    (function() {
        var A, Q, B;
        A = bW(), Q = FRA(), sO2.exports = B = class extends Q {
            constructor(Z, I) {
                super(Z);
                if (I == null) throw Error("Missing comment text. " + this.debugInfo());
                this.name = "#comment", this.type = A.Comment, this.value = this.stringify.comment(I)
            }
            clone() {
                return Object.create(this)
            }
            toString(Z) {
                return this.options.writer.comment(this, this.options.writer.filterOptions(Z))
            }
        }
    }).call(aO2)
});
var t81 = U((rO2, oO2) => {
    (function() {
        var A, Q, B, G;
        ({
            isObject: G
        } = Fy()), B = Mq(), A = bW(), oO2.exports = Q = class extends B {
            constructor(I, Y, J, W) {
                super(I);
                if (G(Y))({
                    version: Y,
                    encoding: J,
                    standalone: W
                } = Y);
                if (!Y) Y = "1.0";
                if (this.type = A.Declaration, this.version = this.stringify.xmlVersion(Y), J != null) this.encoding = this.stringify.xmlEncoding(J);
                if (W != null) this.standalone = this.stringify.xmlStandalone(W)
            }
            toString(I) {
                return this.options.writer.declaration(this, this.options.writer.filterOptions(I))
            }
        }
    }).call(rO2)
});
var e81 = U((tO2, eO2) => {
    (function() {
        var A, Q, B;
        B = Mq(), A = bW(), eO2.exports = Q = class extends B {
            constructor(Z, I, Y, J, W, X) {
                super(Z);
                if (I == null) throw Error("Missing DTD element name. " + this.debugInfo());
                if (Y == null) throw Error("Missing DTD attribute name. " + this.debugInfo(I));
                if (!J) throw Error("Missing DTD attribute type. " + this.debugInfo(I));
                if (!W) throw Error("Missing DTD attribute default. " + this.debugInfo(I));
                if (W.indexOf("#") !== 0) W = "#" + W;
                if (!W.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(I));
                if (X && !W.match(/^(#FIXED|#DEFAULT)$/)) throw Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(I));
                if (this.elementName = this.stringify.name(I), this.type = A.AttributeDeclaration, this.attributeName = this.stringify.name(Y), this.attributeType = this.stringify.dtdAttType(J), X) this.defaultValue = this.stringify.dtdAttDefault(X);
                this.defaultValueType = W
            }
            toString(Z) {
                return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(Z))
            }
        }
    }).call(tO2)
});
var A61 = U((AR2, QR2) => {
    (function() {
        var A, Q, B, G;
        ({
            isObject: G
        } = Fy()), B = Mq(), A = bW(), QR2.exports = Q = function() {
            class Z extends B {
                constructor(I, Y, J, W) {
                    super(I);
                    if (J == null) throw Error("Missing DTD entity name. " + this.debugInfo(J));
                    if (W == null) throw Error("Missing DTD entity value. " + this.debugInfo(J));
                    if (this.pe = !!Y, this.name = this.stringify.name(J), this.type = A.EntityDeclaration, !G(W)) this.value = this.stringify.dtdEntityValue(W), this.internal = !0;
                    else {
                        if (!W.pubID && !W.sysID) throw Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(J));
                        if (W.pubID && !W.sysID) throw Error("System identifier is required for a public external entity. " + this.debugInfo(J));
                        if (this.internal = !1, W.pubID != null) this.pubID = this.stringify.dtdPubID(W.pubID);
                        if (W.sysID != null) this.sysID = this.stringify.dtdSysID(W.sysID);
                        if (W.nData != null) this.nData = this.stringify.dtdNData(W.nData);
                        if (this.pe && this.nData) throw Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(J))
                    }
                }
                toString(I) {
                    return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(I))
                }
            }
            return Object.defineProperty(Z.prototype, "publicId", {
                get: function() {
                    return this.pubID
                }
            }), Object.defineProperty(Z.prototype, "systemId", {
                get: function() {
                    return this.sysID
                }
            }), Object.defineProperty(Z.prototype, "notationName", {
                get: function() {
                    return this.nData || null
                }
            }), Object.defineProperty(Z.prototype, "inputEncoding", {
                get: function() {
                    return null
                }
            }), Object.defineProperty(Z.prototype, "xmlEncoding", {
                get: function() {
                    return null
                }
            }), Object.defineProperty(Z.prototype, "xmlVersion", {
                get: function() {
                    return null
                }
            }), Z
        }.call(this)
    }).call(AR2)
});
var Q61 = U((BR2, GR2) => {
    (function() {
        var A, Q, B;
        B = Mq(), A = bW(), GR2.exports = Q = class extends B {
            constructor(Z, I, Y) {
                super(Z);
                if (I == null) throw Error("Missing DTD element name. " + this.debugInfo());
                if (!Y) Y = "(#PCDATA)";
                if (Array.isArray(Y)) Y = "(" + Y.join(",") + ")";
                this.name = this.stringify.name(I), this.type = A.ElementDeclaration, this.value = this.stringify.dtdElementValue(Y)
            }
            toString(Z) {
                return this.options.writer.dtdElement(this, this.options.writer.filterOptions(Z))
            }
        }
    }).call(BR2)
});
var B61 = U((ZR2, IR2) => {
    (function() {
        var A, Q, B;
        B = Mq(), A = bW(), IR2.exports = Q = function() {
            class G extends B {
                constructor(Z, I, Y) {
                    super(Z);
                    if (I == null) throw Error("Missing DTD notation name. " + this.debugInfo(I));
                    if (!Y.pubID && !Y.sysID) throw Error("Public or system identifiers are required for an external entity. " + this.debugInfo(I));
                    if (this.name = this.stringify.name(I), this.type = A.NotationDeclaration, Y.pubID != null) this.pubID = this.stringify.dtdPubID(Y.pubID);
                    if (Y.sysID != null) this.sysID = this.stringify.dtdSysID(Y.sysID)
                }
                toString(Z) {
                    return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(Z))
                }
            }